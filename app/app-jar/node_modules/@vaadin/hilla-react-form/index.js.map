{
  "version": 3,
  "sources": ["../../../scripts/register.js", "src/index.ts"],
  "sourcesContent": ["export function __REGISTER__(feature, vaadinObj = (window.Vaadin ??= {})) {\n  vaadinObj.registrations ??= [];\n  vaadinObj.registrations.push({\n    is: feature ? `${__NAME__}/${feature}` : __NAME__,\n    version: __VERSION__,\n  });\n}\n", "/* eslint-disable @typescript-eslint/unbound-method */\nimport {\n  _fromString,\n  _validity,\n  type AbstractModel,\n  type BinderConfiguration,\n  type BinderNode,\n  BinderRoot,\n  CHANGED,\n  type DetachedModelConstructor,\n  type FieldStrategy,\n  getBinderNode,\n  getDefaultFieldStrategy,\n  hasFromString,\n  isFieldElement,\n  type Validator,\n  type Value,\n  type ValueError,\n  type ArrayModel,\n  type ArrayItemModel,\n} from '@vaadin/hilla-lit-form';\nimport { useEffect, useMemo, useReducer, useRef } from 'react';\nimport type { Writable } from 'type-fest';\n\n// @ts-expect-error: esbuild injection\n// eslint-disable-next-line @typescript-eslint/no-unsafe-call\n__REGISTER__();\n\nlet isRendering = false;\n\nfunction useUpdate() {\n  const [_, count] = useReducer((x: number) => x + 1, 0);\n  return () => {\n    if (isRendering) {\n      return;\n    }\n    count();\n  };\n}\n\nexport type FieldDirectiveResult = Readonly<{\n  name: string;\n  onBlur(): void;\n  onChange(): void;\n  onInput(): void;\n  ref(element: HTMLElement | null): void;\n}>;\n\nexport type FieldDirective = (model: AbstractModel) => FieldDirectiveResult;\n\nexport type UseFormPartResult<M extends AbstractModel> = Readonly<{\n  defaultValue?: Value<M>;\n  dirty: boolean;\n  errors: readonly ValueError[];\n  invalid: boolean;\n  model: M;\n  name: string;\n  field: FieldDirective;\n  ownErrors: ReadonlyArray<ValueError<Value<M>>>;\n  required: boolean;\n  validators: ReadonlyArray<Validator<Value<M>>>;\n  value?: Value<M>;\n  visited: boolean;\n  addValidator(validator: Validator<Value<M>>): void;\n  setValidators(validators: ReadonlyArray<Validator<Value<M>>>): void;\n  setValue(value: Value<M> | undefined): void;\n  setVisited(visited: boolean): void;\n  validate(): Promise<readonly ValueError[]>;\n}>;\n\nexport type UseFormResult<M extends AbstractModel> = Omit<UseFormPartResult<M>, 'setValue' | 'value'> &\n  Readonly<{\n    value: Value<M>;\n    submitting: boolean;\n    setDefaultValue(value: Value<M>): void;\n    setValue(value: Value<M>): void;\n    submit(): Promise<Value<M> | undefined | void>;\n    reset(): void;\n    clear(): void;\n    read(value: Value<M> | null | undefined): void;\n    update(): void;\n  }>;\n\nexport type UseFormArrayPartResult<M extends ArrayModel> = Omit<UseFormPartResult<M>, 'field'> & {\n  items: ReadonlyArray<ArrayItemModel<M>>;\n};\n\ntype FieldState<T = unknown> = {\n  required: boolean;\n  invalid: boolean;\n  errorMessage: string;\n  strategy?: FieldStrategy<T>;\n  element?: HTMLElement;\n  changeBlurHandler(): void;\n  updateValue(): void;\n  markVisited(): void;\n  ref(element: HTMLElement | null): void;\n};\n\nfunction convertFieldValue<T extends AbstractModel>(model: T, fieldValue: unknown) {\n  return typeof fieldValue === 'string' && hasFromString(model) ? model[_fromString](fieldValue) : fieldValue;\n}\n\nfunction getFormPart<M extends AbstractModel>(node: BinderNode<M>): Omit<UseFormPartResult<M>, 'field'> {\n  return {\n    addValidator: node.addValidator.bind(node),\n    get defaultValue() {\n      return node.defaultValue;\n    },\n    dirty: node.dirty,\n    errors: node.errors,\n    invalid: node.invalid,\n    model: node.model,\n    name: node.name,\n    ownErrors: node.ownErrors,\n    required: node.required,\n    setValidators(validators) {\n      node.validators = validators;\n    },\n    setValue(value) {\n      node.value = value;\n    },\n    setVisited(visited: boolean) {\n      node.visited = visited;\n    },\n    validate: node.validate.bind(node),\n    validators: node.validators,\n    get value() {\n      return node.value;\n    },\n    visited: node.visited,\n  };\n}\n\nfunction useFields<M extends AbstractModel>(node: BinderNode<M>): FieldDirective {\n  const update = useUpdate();\n\n  return useMemo(() => {\n    const registry = new WeakMap<AbstractModel, FieldState>();\n\n    return ((model: AbstractModel) => {\n      isRendering = true;\n      const n = getBinderNode(model);\n\n      let fieldState = registry.get(model);\n\n      if (!fieldState) {\n        fieldState = {\n          element: undefined,\n          errorMessage: '',\n          invalid: false,\n          changeBlurHandler() {\n            fieldState!.updateValue();\n            fieldState!.markVisited();\n          },\n          markVisited() {\n            n.visited = true;\n          },\n          ref(element: HTMLElement | null) {\n            if (!element) {\n              fieldState!.element?.removeEventListener('change', fieldState!.changeBlurHandler);\n              fieldState!.element?.removeEventListener('input', fieldState!.updateValue);\n              fieldState!.element?.removeEventListener('blur', fieldState!.changeBlurHandler);\n              fieldState!.strategy?.removeEventListeners();\n              fieldState!.element = undefined;\n              fieldState!.strategy = undefined;\n              update();\n              return;\n            }\n\n            if (!isFieldElement(element)) {\n              throw new TypeError(`Element '${element.localName}' is not a form element`);\n            }\n\n            if (fieldState!.element !== element) {\n              fieldState!.element = element;\n              fieldState!.element.addEventListener('change', fieldState!.changeBlurHandler);\n              fieldState!.element.addEventListener('input', fieldState!.updateValue);\n              fieldState!.element.addEventListener('blur', fieldState!.changeBlurHandler);\n              fieldState!.strategy = getDefaultFieldStrategy(element, model);\n              update();\n            }\n          },\n          required: false,\n          strategy: undefined,\n          updateValue() {\n            if (fieldState!.strategy) {\n              // Remove invalid flag, so that .checkValidity() in Vaadin Components\n              // does not interfere with errors from Hilla.\n              fieldState!.strategy.invalid = false;\n              // When bad input is detected, skip reading new value in binder state\n              fieldState!.strategy.checkValidity();\n              n[_validity] = fieldState!.strategy.validity;\n              n.value = convertFieldValue(model, fieldState!.strategy.value);\n            }\n          },\n        };\n\n        registry.set(model, fieldState);\n      }\n\n      if (fieldState.strategy) {\n        const valueFromField = convertFieldValue(model, fieldState.strategy.value);\n        if (valueFromField !== n.value && !(Number.isNaN(n.value) && Number.isNaN(valueFromField))) {\n          fieldState.strategy.value = Number.isNaN(n.value) ? '' : n.value;\n        }\n\n        if (fieldState.required !== n.required) {\n          fieldState.required = n.required;\n          fieldState.strategy.required = n.required;\n        }\n\n        const firstError = n.ownErrors.at(0);\n        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n        const errorMessage = firstError?.message ?? '';\n        if (fieldState.errorMessage !== errorMessage) {\n          fieldState.errorMessage = errorMessage;\n          fieldState.strategy.errorMessage = errorMessage;\n        }\n\n        // Make sure invalid state is always in sync\n        fieldState.invalid = n.invalid;\n        fieldState.strategy.invalid = n.invalid;\n      }\n\n      isRendering = false;\n      return {\n        name: n.name,\n        ref: fieldState.ref,\n      };\n    }) as FieldDirective;\n  }, [node]);\n}\n\nexport function useForm<M extends AbstractModel>(\n  Model: DetachedModelConstructor<M>,\n  config?: BinderConfiguration<Value<M>>,\n): UseFormResult<M> {\n  const configRef = useRef<Writable<BinderConfiguration<Value<M>>>>({});\n  configRef.current.onSubmit = config?.onSubmit;\n  configRef.current.onChange = config?.onChange;\n  const update = useUpdate();\n  const binder = useMemo(() => new BinderRoot(Model, configRef.current), [Model]);\n  const field = useFields(binder);\n  const clear = binder.clear.bind(binder);\n\n  useEffect(() => {\n    binder.addEventListener(CHANGED.type, update);\n    clear(); // this allows to initialize the validation strategies (issue 2282)\n    return () => binder.removeEventListener(CHANGED.type, update);\n  }, [binder]);\n\n  return {\n    ...getFormPart(binder),\n    clear,\n    field,\n    read: binder.read.bind(binder),\n    reset: binder.reset.bind(binder),\n    setDefaultValue(defaultValue) {\n      binder.defaultValue = defaultValue;\n    },\n    setValue(value) {\n      binder.value = value;\n    },\n    submit: binder.submit.bind(binder),\n    value: binder.value,\n    submitting: binder.submitting,\n    update,\n  };\n}\n\nexport function useFormPart<M extends AbstractModel>(model: M): UseFormPartResult<M> {\n  isRendering = true;\n  const binderNode = getBinderNode(model);\n  const field = useFields(binderNode);\n  isRendering = false;\n\n  return {\n    ...getFormPart(binderNode),\n    field,\n  };\n}\n\n/**\n * Hook to access an array model part of a form. It provides the same API as `useFormPart`,\n * but adds an `items` property that allows to iterate over the items in form of an array of models.\n *\n * @param model - The array model to access\n * @returns The array model part of the form\n */\nexport function useFormArrayPart<M extends ArrayModel>(model: M): UseFormArrayPartResult<M> {\n  isRendering = true;\n  const binderNode = getBinderNode(model);\n  isRendering = false;\n  return {\n    ...getFormPart(binderNode),\n    items: Array.from(model, (item) => item.model as ArrayItemModel<M>),\n  };\n}\n"],
  "mappings": "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",
  "names": []
}
