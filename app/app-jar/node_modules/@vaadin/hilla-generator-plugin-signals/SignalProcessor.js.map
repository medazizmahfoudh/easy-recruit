{
  "version": 3,
  "sources": ["src/SignalProcessor.ts"],
  "sourcesContent": ["import type Plugin from '@vaadin/hilla-generator-core/Plugin.js';\nimport { template, transform, traverse } from '@vaadin/hilla-generator-utils/ast.js';\nimport createFullyUniqueIdentifier from '@vaadin/hilla-generator-utils/createFullyUniqueIdentifier.js';\nimport createSourceFile from '@vaadin/hilla-generator-utils/createSourceFile.js';\nimport DependencyManager from '@vaadin/hilla-generator-utils/dependencies/DependencyManager.js';\nimport PathManager from '@vaadin/hilla-generator-utils/dependencies/PathManager.js';\nimport ts, { type FunctionDeclaration, type Identifier, type SourceFile } from 'typescript';\n\nconst HILLA_REACT_SIGNALS = '@vaadin/hilla-react-signals';\n\nconst CONNECT_CLIENT = '$CONNECT_CLIENT$';\nconst METHOD_NAME = '$METHOD_NAME$';\nconst SIGNAL = '$SIGNAL$';\nconst RETURN_TYPE = '$RETURN_TYPE$';\nconst INITIAL_VALUE = '$INITIAL_VALUE$';\n\nconst signals = ['NumberSignal', 'ValueSignal'];\nconst genericSignals = ['ValueSignal'];\n\nexport default class SignalProcessor {\n  readonly #dependencyManager: DependencyManager;\n  readonly #owner: Plugin;\n  readonly #service: string;\n  readonly #methods: Map<string, string>;\n  readonly #sourceFile: SourceFile;\n\n  constructor(service: string, methods: Map<string, string>, sourceFile: SourceFile, owner: Plugin) {\n    this.#service = service;\n    this.#methods = methods;\n    this.#sourceFile = sourceFile;\n    this.#owner = owner;\n    this.#dependencyManager = new DependencyManager(new PathManager({ extension: '.js' }));\n    this.#dependencyManager.imports.fromCode(this.#sourceFile);\n  }\n\n  process(): SourceFile {\n    this.#owner.logger.debug(`Processing signals: ${this.#service}`);\n    const { imports } = this.#dependencyManager;\n\n    const [, connectClientId] = imports.default.iter().find(([path]) => path.includes('connect-client'))!;\n\n    const initTypeId = imports.named.getIdentifier('@vaadin/hilla-frontend', 'EndpointRequestInit');\n    let initTypeUsageCount = 0;\n    const functionParams: Map<string, ts.ParameterDeclaration[]> = new Map<string, ts.ParameterDeclaration[]>();\n\n    const [file] = ts.transform<SourceFile>(this.#sourceFile, [\n      transform((tsNode) => {\n        if (ts.isFunctionDeclaration(tsNode) && tsNode.name && this.#methods.has(tsNode.name.text)) {\n          const signalId = this.#replaceSignalImport(tsNode);\n          let initialValue: ts.Expression = signalId.text.startsWith('NumberSignal')\n            ? ts.factory.createNumericLiteral('0')\n            : ts.factory.createIdentifier('undefined');\n          const filteredParams = tsNode.parameters.filter(\n            (p) => !p.type || !ts.isTypeReferenceNode(p.type) || p.type.typeName !== initTypeId,\n          );\n          // `filteredParams` can be altered after, need to store the param names now\n          const paramNames = filteredParams.map((p) => (p.name as ts.Identifier).text).join(', ');\n          let genericReturnType;\n          if (genericSignals.includes(signalId.text)) {\n            genericReturnType = (tsNode.type as ts.TypeReferenceNode).typeArguments![0];\n            const defaultValueType = SignalProcessor.#getDefaultValueType(genericReturnType);\n            if (defaultValueType) {\n              const { alias, param } = SignalProcessor.#createDefaultValueParameter(defaultValueType);\n              initialValue = alias;\n              filteredParams.push(param);\n            }\n          }\n          const returnType = genericReturnType ?? signalId;\n          if (filteredParams.length > 0) {\n            functionParams.set(tsNode.name.text, filteredParams);\n          }\n          return template(\n            `function ${METHOD_NAME}(): ${RETURN_TYPE} {\n  return new ${SIGNAL}(${INITIAL_VALUE}, { client: ${CONNECT_CLIENT}, endpoint: '${this.#service}', method: '${tsNode.name.text}'${paramNames.length ? `, params: { ${paramNames} }` : ''} });\n}`,\n            (statements) => statements,\n            [\n              transform((node) => (ts.isIdentifier(node) && node.text === METHOD_NAME ? tsNode.name : node)),\n              transform((node) => (ts.isIdentifier(node) && node.text === SIGNAL ? signalId : node)),\n              transform((node) => (ts.isIdentifier(node) && node.text === RETURN_TYPE ? returnType : node)),\n              transform((node) => (ts.isIdentifier(node) && node.text === CONNECT_CLIENT ? connectClientId : node)),\n              transform((node) => (ts.isIdentifier(node) && node.text === INITIAL_VALUE ? initialValue : node)),\n            ],\n          );\n        }\n        return tsNode;\n      }),\n      transform((tsNode) => {\n        if (\n          ts.isFunctionDeclaration(tsNode) &&\n          tsNode.name &&\n          this.#methods.has(tsNode.name.text) &&\n          functionParams.has(tsNode.name.text)\n        ) {\n          return ts.factory.updateFunctionDeclaration(\n            tsNode,\n            tsNode.modifiers,\n            tsNode.asteriskToken,\n            tsNode.name,\n            tsNode.typeParameters,\n            functionParams.get(tsNode.name.text)!,\n            tsNode.type,\n            tsNode.body,\n          );\n        }\n        return tsNode;\n      }),\n      transform((tsNode) => {\n        if (ts.isFunctionDeclaration(tsNode)) {\n          if (\n            !(tsNode.name && this.#methods.has(tsNode.name.text)) &&\n            tsNode.parameters.some((p) => p.type && ts.isTypeReferenceNode(p.type) && p.type.typeName === initTypeId)\n          ) {\n            initTypeUsageCount += 1;\n          }\n        }\n        return tsNode;\n      }),\n    ]).transformed;\n\n    if (initTypeUsageCount === 0) {\n      imports.named.remove('@vaadin/hilla-frontend', 'EndpointRequestInit');\n    }\n\n    return createSourceFile(\n      [\n        ...this.#dependencyManager.imports.toCode(),\n        ...file.statements.filter((statement) => !ts.isImportDeclaration(statement)),\n      ],\n      file.fileName,\n    );\n  }\n\n  static #getDefaultValueType(node: ts.Node) {\n    if (\n      ts.isUnionTypeNode(node) &&\n      node.types.length &&\n      ts.isTypeReferenceNode(node.types[0]) &&\n      node.types[0].typeArguments?.length === 1 &&\n      ts.isUnionTypeNode(node.types[0].typeArguments[0])\n    ) {\n      return node.types[0].typeArguments[0];\n    }\n\n    return undefined;\n  }\n\n  static #createDefaultValueParameter(returnType: ts.TypeNode) {\n    const alias = createFullyUniqueIdentifier('defaultValue');\n    const bindingPattern = ts.factory.createObjectBindingPattern([\n      ts.factory.createBindingElement(undefined, ts.factory.createIdentifier('defaultValue'), alias, undefined),\n    ]);\n    const paramType = ts.factory.createTypeLiteralNode([\n      ts.factory.createPropertySignature(undefined, ts.factory.createIdentifier('defaultValue'), undefined, returnType),\n    ]);\n    // Return both the alias and the full parameter\n    return {\n      alias,\n      param: ts.factory.createParameterDeclaration(undefined, undefined, bindingPattern, undefined, paramType),\n    };\n  }\n\n  #replaceSignalImport(method: FunctionDeclaration): Identifier {\n    const { imports } = this.#dependencyManager;\n\n    if (method.type) {\n      const type = traverse(method.type, (node) =>\n        ts.isIdentifier(node) && signals.includes(node.text) ? node : undefined,\n      );\n\n      if (type) {\n        const signalId = imports.named.getIdentifier(HILLA_REACT_SIGNALS, type.text);\n\n        if (signalId) {\n          return signalId;\n        }\n\n        const result = imports.default.iter().find(([_p, id]) => id.text === type.text);\n\n        if (result) {\n          const [path] = result;\n          imports.default.remove(path);\n          return imports.named.add(HILLA_REACT_SIGNALS, type.text, false, type);\n        }\n      }\n    }\n\n    throw new Error('Signal type not found');\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
