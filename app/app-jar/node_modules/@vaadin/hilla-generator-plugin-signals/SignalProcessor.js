import { template, transform, traverse } from "@vaadin/hilla-generator-utils/ast.js";
import createFullyUniqueIdentifier from "@vaadin/hilla-generator-utils/createFullyUniqueIdentifier.js";
import createSourceFile from "@vaadin/hilla-generator-utils/createSourceFile.js";
import DependencyManager from "@vaadin/hilla-generator-utils/dependencies/DependencyManager.js";
import PathManager from "@vaadin/hilla-generator-utils/dependencies/PathManager.js";
import ts, {} from "typescript";
const HILLA_REACT_SIGNALS = "@vaadin/hilla-react-signals";
const CONNECT_CLIENT = "$CONNECT_CLIENT$";
const METHOD_NAME = "$METHOD_NAME$";
const SIGNAL = "$SIGNAL$";
const RETURN_TYPE = "$RETURN_TYPE$";
const INITIAL_VALUE = "$INITIAL_VALUE$";
const signals = ["NumberSignal", "ValueSignal"];
const genericSignals = ["ValueSignal"];
class SignalProcessor {
  #dependencyManager;
  #owner;
  #service;
  #methods;
  #sourceFile;
  constructor(service, methods, sourceFile, owner) {
    this.#service = service;
    this.#methods = methods;
    this.#sourceFile = sourceFile;
    this.#owner = owner;
    this.#dependencyManager = new DependencyManager(new PathManager({ extension: ".js" }));
    this.#dependencyManager.imports.fromCode(this.#sourceFile);
  }
  process() {
    this.#owner.logger.debug(`Processing signals: ${this.#service}`);
    const { imports } = this.#dependencyManager;
    const [, connectClientId] = imports.default.iter().find(([path]) => path.includes("connect-client"));
    const initTypeId = imports.named.getIdentifier("@vaadin/hilla-frontend", "EndpointRequestInit");
    let initTypeUsageCount = 0;
    const functionParams = /* @__PURE__ */ new Map();
    const [file] = ts.transform(this.#sourceFile, [
      transform((tsNode) => {
        if (ts.isFunctionDeclaration(tsNode) && tsNode.name && this.#methods.has(tsNode.name.text)) {
          const signalId = this.#replaceSignalImport(tsNode);
          let initialValue = signalId.text.startsWith("NumberSignal") ? ts.factory.createNumericLiteral("0") : ts.factory.createIdentifier("undefined");
          const filteredParams = tsNode.parameters.filter(
            (p) => !p.type || !ts.isTypeReferenceNode(p.type) || p.type.typeName !== initTypeId
          );
          const paramNames = filteredParams.map((p) => p.name.text).join(", ");
          let genericReturnType;
          if (genericSignals.includes(signalId.text)) {
            genericReturnType = tsNode.type.typeArguments[0];
            const defaultValueType = SignalProcessor.#getDefaultValueType(genericReturnType);
            if (defaultValueType) {
              const { alias, param } = SignalProcessor.#createDefaultValueParameter(defaultValueType);
              initialValue = alias;
              filteredParams.push(param);
            }
          }
          const returnType = genericReturnType ?? signalId;
          if (filteredParams.length > 0) {
            functionParams.set(tsNode.name.text, filteredParams);
          }
          return template(
            `function ${METHOD_NAME}(): ${RETURN_TYPE} {
  return new ${SIGNAL}(${INITIAL_VALUE}, { client: ${CONNECT_CLIENT}, endpoint: '${this.#service}', method: '${tsNode.name.text}'${paramNames.length ? `, params: { ${paramNames} }` : ""} });
}`,
            (statements) => statements,
            [
              transform((node) => ts.isIdentifier(node) && node.text === METHOD_NAME ? tsNode.name : node),
              transform((node) => ts.isIdentifier(node) && node.text === SIGNAL ? signalId : node),
              transform((node) => ts.isIdentifier(node) && node.text === RETURN_TYPE ? returnType : node),
              transform((node) => ts.isIdentifier(node) && node.text === CONNECT_CLIENT ? connectClientId : node),
              transform((node) => ts.isIdentifier(node) && node.text === INITIAL_VALUE ? initialValue : node)
            ]
          );
        }
        return tsNode;
      }),
      transform((tsNode) => {
        if (ts.isFunctionDeclaration(tsNode) && tsNode.name && this.#methods.has(tsNode.name.text) && functionParams.has(tsNode.name.text)) {
          return ts.factory.updateFunctionDeclaration(
            tsNode,
            tsNode.modifiers,
            tsNode.asteriskToken,
            tsNode.name,
            tsNode.typeParameters,
            functionParams.get(tsNode.name.text),
            tsNode.type,
            tsNode.body
          );
        }
        return tsNode;
      }),
      transform((tsNode) => {
        if (ts.isFunctionDeclaration(tsNode)) {
          if (!(tsNode.name && this.#methods.has(tsNode.name.text)) && tsNode.parameters.some((p) => p.type && ts.isTypeReferenceNode(p.type) && p.type.typeName === initTypeId)) {
            initTypeUsageCount += 1;
          }
        }
        return tsNode;
      })
    ]).transformed;
    if (initTypeUsageCount === 0) {
      imports.named.remove("@vaadin/hilla-frontend", "EndpointRequestInit");
    }
    return createSourceFile(
      [
        ...this.#dependencyManager.imports.toCode(),
        ...file.statements.filter((statement) => !ts.isImportDeclaration(statement))
      ],
      file.fileName
    );
  }
  static #getDefaultValueType(node) {
    if (ts.isUnionTypeNode(node) && node.types.length && ts.isTypeReferenceNode(node.types[0]) && node.types[0].typeArguments?.length === 1 && ts.isUnionTypeNode(node.types[0].typeArguments[0])) {
      return node.types[0].typeArguments[0];
    }
    return void 0;
  }
  static #createDefaultValueParameter(returnType) {
    const alias = createFullyUniqueIdentifier("defaultValue");
    const bindingPattern = ts.factory.createObjectBindingPattern([
      ts.factory.createBindingElement(void 0, ts.factory.createIdentifier("defaultValue"), alias, void 0)
    ]);
    const paramType = ts.factory.createTypeLiteralNode([
      ts.factory.createPropertySignature(void 0, ts.factory.createIdentifier("defaultValue"), void 0, returnType)
    ]);
    return {
      alias,
      param: ts.factory.createParameterDeclaration(void 0, void 0, bindingPattern, void 0, paramType)
    };
  }
  #replaceSignalImport(method) {
    const { imports } = this.#dependencyManager;
    if (method.type) {
      const type = traverse(
        method.type,
        (node) => ts.isIdentifier(node) && signals.includes(node.text) ? node : void 0
      );
      if (type) {
        const signalId = imports.named.getIdentifier(HILLA_REACT_SIGNALS, type.text);
        if (signalId) {
          return signalId;
        }
        const result = imports.default.iter().find(([_p, id]) => id.text === type.text);
        if (result) {
          const [path] = result;
          imports.default.remove(path);
          return imports.named.add(HILLA_REACT_SIGNALS, type.text, false, type);
        }
      }
    }
    throw new Error("Signal type not found");
  }
}
export {
  SignalProcessor as default
};
//# sourceMappingURL=SignalProcessor.js.map
