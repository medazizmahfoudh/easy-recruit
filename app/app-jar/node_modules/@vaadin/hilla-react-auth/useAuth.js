import { jsx } from "react/jsx-runtime";
import {
  login as _login,
  logout as _logout,
  UnauthorizedResponseError
} from "@vaadin/hilla-frontend";
import { createContext, useContext, useEffect, useReducer } from "react";
const LOGIN_FETCH = "LOGIN_FETCH";
const LOGIN_SUCCESS = "LOGIN_SUCCESS";
const LOGIN_FAILURE = "LOGIN_FAILURE";
const LOGOUT = "LOGOUT";
function createAuthenticateThunk(dispatch, getAuthenticatedUser) {
  async function authenticate() {
    dispatch({ type: LOGIN_FETCH });
    const user = await getAuthenticatedUser().catch((error) => {
      if (error instanceof UnauthorizedResponseError) {
        return void 0;
      }
      throw error;
    });
    if (user) {
      dispatch({
        user,
        type: LOGIN_SUCCESS
      });
    } else {
      dispatch({
        error: "Not authenticated",
        type: LOGIN_FAILURE
      });
    }
  }
  return authenticate;
}
function createUnauthenticateThunk(dispatch) {
  return () => {
    dispatch({ type: LOGOUT });
  };
}
const initialState = {
  initializing: true,
  loading: false
};
function reducer(state, action) {
  switch (action.type) {
    case LOGIN_FETCH:
      return {
        initializing: false,
        loading: true
      };
    case LOGIN_SUCCESS:
      return {
        initializing: false,
        loading: false,
        user: action.user
      };
    case LOGIN_FAILURE:
      return {
        initializing: false,
        loading: false,
        error: action.error
      };
    case LOGOUT:
      return { initializing: false, loading: false };
    default:
      return state;
  }
}
const AuthContext = createContext({
  state: initialState,
  login() {
    throw new Error("AuthContext not initialized");
  },
  logout() {
    throw new Error("AuthContext not initialized");
  },
  hasAccess() {
    throw new Error("AuthContext not initialized");
  }
});
const getDefaultRoles = (user) => {
  const userWithRoles = user;
  return Array.isArray(userWithRoles.roles) ? userWithRoles.roles : [];
};
function AuthProvider({ children, getAuthenticatedUser, config }) {
  const [state, dispatch] = useReducer(reducer, initialState);
  const authenticate = createAuthenticateThunk(dispatch, getAuthenticatedUser);
  const unauthenticate = createUnauthenticateThunk(dispatch);
  async function login(username, password, options) {
    const result = await _login(username, password, options);
    if (!result.error) {
      await authenticate();
    }
    return result;
  }
  async function logout(options) {
    await _logout(options);
    unauthenticate();
  }
  function hasAccess({ loginRequired, requiresLogin, rolesAllowed }) {
    const requiresAuth = loginRequired ?? requiresLogin ?? rolesAllowed;
    if (!requiresAuth) {
      return true;
    }
    if (!state.user) {
      return false;
    }
    if (rolesAllowed) {
      const userRoles = config?.getRoles ? config.getRoles(state.user) : getDefaultRoles(state.user);
      return rolesAllowed.some((allowedRole) => userRoles.includes(allowedRole));
    }
    return true;
  }
  useEffect(() => {
    authenticate().catch(() => {
    });
  }, []);
  const auth = {
    state,
    login,
    logout,
    hasAccess
  };
  return /* @__PURE__ */ jsx(AuthContext.Provider, { value: auth, children });
}
function useAuth() {
  return useContext(AuthContext);
}
function configureAuth(getAuthenticatedUser, config) {
  function PreconfiguredAuthProvider({ children }) {
    return /* @__PURE__ */ jsx(AuthProvider, { getAuthenticatedUser, config, children });
  }
  return {
    AuthProvider: PreconfiguredAuthProvider,
    useAuth
  };
}
export {
  AuthContext,
  configureAuth
};
//# sourceMappingURL=useAuth.js.map
