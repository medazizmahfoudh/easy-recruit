{
  "version": 3,
  "sources": ["src/useAuth.tsx"],
  "sourcesContent": ["import {\n  login as _login,\n  type LoginOptions,\n  type LoginResult,\n  logout as _logout,\n  type LogoutOptions,\n  UnauthorizedResponseError,\n} from '@vaadin/hilla-frontend';\nimport { createContext, type Dispatch, useContext, useEffect, useReducer } from 'react';\n\ntype LoginFunction = (username: string, password: string) => Promise<LoginResult>;\ntype LogoutFunction = () => Promise<void>;\n\nconst LOGIN_FETCH = 'LOGIN_FETCH';\nconst LOGIN_SUCCESS = 'LOGIN_SUCCESS';\nconst LOGIN_FAILURE = 'LOGIN_FAILURE';\nconst LOGOUT = 'LOGOUT';\n\n/**\n * The type of the function that is used to get the authenticated user.\n */\nexport type GetUserFn<TUser> = () => Promise<TUser | undefined>;\n\ntype AuthState<TUser> = Readonly<{\n  initializing: boolean;\n  loading: boolean;\n  user?: TUser;\n  error?: string;\n  getAuthenticatedUser?: GetUserFn<TUser>;\n}>;\n\ntype LoginFetchAction = Readonly<{\n  type: typeof LOGIN_FETCH;\n}>;\n\ntype LoginSuccessAction = Readonly<{\n  user: unknown;\n  type: typeof LOGIN_SUCCESS;\n}>;\n\ntype LoginFailureAction = Readonly<{\n  error: string;\n  type: typeof LOGIN_FAILURE;\n}>;\n\ntype LoginActions = LoginFailureAction | LoginFetchAction | LoginSuccessAction;\n\ntype LogoutAction = Readonly<{\n  type: typeof LOGOUT;\n}>;\n\nfunction createAuthenticateThunk<TUser>(dispatch: Dispatch<LoginActions>, getAuthenticatedUser: GetUserFn<TUser>) {\n  async function authenticate() {\n    dispatch({ type: LOGIN_FETCH });\n\n    // Get user info from endpoint\n    const user = await getAuthenticatedUser().catch((error: unknown) => {\n      if (error instanceof UnauthorizedResponseError) {\n        // 401 response: the user is not authenticated\n        return undefined;\n      }\n\n      throw error;\n    });\n\n    if (user) {\n      dispatch({\n        user,\n        type: LOGIN_SUCCESS,\n      });\n    } else {\n      dispatch({\n        error: 'Not authenticated',\n        type: LOGIN_FAILURE,\n      });\n    }\n  }\n\n  return authenticate;\n}\n\nfunction createUnauthenticateThunk(dispatch: Dispatch<LogoutAction>) {\n  return () => {\n    dispatch({ type: LOGOUT });\n  };\n}\n\nconst initialState: AuthState<unknown> = {\n  initializing: true,\n  loading: false,\n};\n\nfunction reducer(state: AuthState<unknown>, action: LoginActions | LogoutAction) {\n  switch (action.type) {\n    case LOGIN_FETCH:\n      return {\n        initializing: false,\n        loading: true,\n      };\n    case LOGIN_SUCCESS:\n      return {\n        initializing: false,\n        loading: false,\n        user: action.user,\n      };\n    case LOGIN_FAILURE:\n      return {\n        initializing: false,\n        loading: false,\n        error: action.error,\n      };\n    case LOGOUT:\n      return { initializing: false, loading: false };\n    default:\n      return state;\n  }\n}\n\n/**\n * The properties that can be used to control access to a route.\n * They can be added to the route type handler as properties.\n */\nexport type AccessProps = Readonly<{\n  /**\n   * If true, the user must be logged in to access the route.\n   */\n  loginRequired?: boolean;\n  /**\n   * If true, the user must be logged in to access the route.\n   *\n   * @deprecated Use `loginRequired` instead.\n   */\n  requiresLogin?: boolean;\n  /**\n   * The list of roles that are allowed to access the route.\n   */\n  rolesAllowed?: readonly [string, ...string[]];\n}>;\n\n/**\n * The type of the authentication hook.\n */\nexport type Authentication<TUser> = Readonly<{\n  state: AuthState<TUser>;\n  login: LoginFunction;\n  logout: LogoutFunction;\n  hasAccess(accessProps: AccessProps): boolean;\n}>;\n\n/**\n * The hook that can be used to get the authentication state.\n * It returns the state of the authentication.\n */\nexport const AuthContext = createContext<Authentication<unknown>>({\n  state: initialState,\n  login() {\n    throw new Error('AuthContext not initialized');\n  },\n  logout() {\n    throw new Error('AuthContext not initialized');\n  },\n  hasAccess(): boolean {\n    throw new Error('AuthContext not initialized');\n  },\n});\n\ninterface AuthConfig<TUser> {\n  getRoles?(user: TUser): readonly string[];\n}\n\ninterface AuthProviderProps<TUser> extends React.PropsWithChildren {\n  getAuthenticatedUser: GetUserFn<TUser>;\n  config?: AuthConfig<TUser>;\n}\n\ninterface UserWithRoles {\n  roles?: any;\n}\n\nconst getDefaultRoles = (user: unknown) => {\n  const userWithRoles = user as UserWithRoles;\n  return Array.isArray(userWithRoles.roles) ? userWithRoles.roles : [];\n};\n\nfunction AuthProvider<TUser>({ children, getAuthenticatedUser, config }: AuthProviderProps<TUser>) {\n  const [state, dispatch] = useReducer(reducer, initialState);\n  const authenticate = createAuthenticateThunk(dispatch, getAuthenticatedUser);\n  const unauthenticate = createUnauthenticateThunk(dispatch);\n\n  async function login(username: string, password: string, options?: LoginOptions): Promise<LoginResult> {\n    const result = await _login(username, password, options);\n\n    if (!result.error) {\n      await authenticate();\n    }\n\n    return result;\n  }\n\n  async function logout(options?: LogoutOptions): Promise<void> {\n    await _logout(options);\n    unauthenticate();\n  }\n\n  function hasAccess({ loginRequired, requiresLogin, rolesAllowed }: AccessProps): boolean {\n    const requiresAuth = loginRequired ?? requiresLogin ?? rolesAllowed;\n    if (!requiresAuth) {\n      return true;\n    }\n\n    if (!state.user) {\n      return false;\n    }\n\n    if (rolesAllowed) {\n      const userRoles = config?.getRoles ? config.getRoles(state.user as TUser) : getDefaultRoles(state.user);\n      return rolesAllowed.some((allowedRole) => userRoles.includes(allowedRole));\n    }\n\n    return true;\n  }\n\n  useEffect(() => {\n    authenticate().catch(() => {\n      // Do nothing\n    });\n  }, []);\n\n  const auth = {\n    state,\n    login,\n    logout,\n    hasAccess,\n  };\n\n  return <AuthContext.Provider value={auth}>{children}</AuthContext.Provider>;\n}\n\nexport type AuthHook<TUser> = () => Authentication<TUser>;\n\n/**\n * The hook that can be used to authenticate the user.\n * It returns the state of the authentication and the functions\n * to authenticate and unauthenticate the user.\n */\nfunction useAuth<TUser>(): Authentication<TUser> {\n  return useContext(AuthContext) as Authentication<TUser>;\n}\n\ninterface AuthModule<TUser> {\n  AuthProvider: React.FC<React.PropsWithChildren>;\n  useAuth: AuthHook<TUser>;\n}\n\nexport function configureAuth<TUser>(\n  getAuthenticatedUser: GetUserFn<TUser>,\n  config?: AuthConfig<TUser>,\n): AuthModule<TUser> {\n  function PreconfiguredAuthProvider({ children }: React.PropsWithChildren) {\n    return (\n      <AuthProvider<TUser> getAuthenticatedUser={getAuthenticatedUser} config={config}>\n        {children}\n      </AuthProvider>\n    );\n  }\n\n  return {\n    AuthProvider: PreconfiguredAuthProvider,\n    useAuth: useAuth as AuthHook<TUser>,\n  };\n}\n"],
  "mappings": "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",
  "names": []
}
