import { nanoid } from "nanoid";
import { computed, signal, Signal } from "./core.js";
import { createSetStateEvent } from "./events.js";
const ENDPOINT = "SignalsHandler";
class DependencyTrackingSignal extends Signal {
  #onFirstSubscribe;
  #onLastUnsubscribe;
  // -1 means to ignore the first subscription that is created internally in the
  // FullStackSignal constructor.
  #subscribeCount = -1;
  constructor(value, onFirstSubscribe, onLastUnsubscribe) {
    if (!window.Vaadin?.featureFlags?.fullstackSignals) {
      throw new Error(
        `The Hilla Fullstack Signals API is currently considered experimental and may change in the future. To use it you need to explicitly enable it in Copilot or by adding com.vaadin.experimental.fullstackSignals=true to vaadin-featureflags.properties`
      );
    }
    super(value);
    this.#onFirstSubscribe = onFirstSubscribe;
    this.#onLastUnsubscribe = onLastUnsubscribe;
  }
  S(node) {
    super.S(node);
    if (this.#subscribeCount === 0) {
      this.#onFirstSubscribe();
    }
    this.#subscribeCount += 1;
  }
  U(node) {
    super.U(node);
    this.#subscribeCount -= 1;
    if (this.#subscribeCount === 0) {
      this.#onLastUnsubscribe();
    }
  }
}
class ServerConnection {
  #id;
  #config;
  #subscription;
  constructor(id, config) {
    this.#config = config;
    this.#id = id;
  }
  get subscription() {
    return this.#subscription;
  }
  connect() {
    const { client, endpoint, method, params } = this.#config;
    this.#subscription ??= client.subscribe(ENDPOINT, "subscribe", {
      providerEndpoint: endpoint,
      providerMethod: method,
      clientSignalId: this.#id,
      params
    });
    return this.#subscription;
  }
  async update(event) {
    await this.#config.client.call(ENDPOINT, "update", {
      clientSignalId: this.#id,
      event
    });
  }
  disconnect() {
    this.#subscription?.cancel();
    this.#subscription = void 0;
  }
}
const $update = Symbol("update");
const $processServerResponse = Symbol("processServerResponse");
class FullStackSignal extends DependencyTrackingSignal {
  /**
   * The unique identifier of the signal necessary to communicate with the
   * server.
   */
  id = nanoid();
  /**
   * The server connection manager.
   */
  server;
  /**
   * Defines whether the signal is currently awaits a server-side response.
   */
  pending = computed(() => this.#pending.value);
  /**
   * Defines whether the signal has an error.
   */
  error = computed(() => this.#error.value);
  #pending = signal(false);
  #error = signal(void 0);
  // Paused at the very start to prevent the signal from sending the initial
  // value to the server.
  #paused = true;
  constructor(value, config) {
    super(
      value,
      () => this.#connect(),
      () => this.#disconnect()
    );
    this.server = new ServerConnection(this.id, config);
    this.subscribe((v) => {
      if (!this.#paused) {
        this.#pending.value = true;
        this.#error.value = void 0;
        this[$update](createSetStateEvent(v));
      }
    });
    this.#paused = false;
  }
  /**
   * Sets the local value of the signal without sending any events to the server
   * @param value - The new value.
   * @internal
   */
  setValueLocal(value) {
    this.#paused = true;
    this.value = value;
    this.#paused = false;
  }
  /**
   * A method to update the server with the new value.
   *
   * @param event - The event to update the server with.
   */
  [$update](event) {
    this.server.update(event).catch((error) => {
      this.#error.value = error instanceof Error ? error : new Error(String(error));
    }).finally(() => {
      this.#pending.value = false;
    });
  }
  #connect() {
    this.server.connect().onSubscriptionLost(() => "resubscribe").onNext((event) => {
      this.#paused = true;
      this[$processServerResponse](event);
      this.#paused = false;
    });
  }
  #disconnect() {
    if (this.server.subscription === void 0) {
      return;
    }
    this.server.disconnect();
  }
}
export {
  $processServerResponse,
  $update,
  DependencyTrackingSignal,
  FullStackSignal
};
//# sourceMappingURL=FullStackSignal.js.map
