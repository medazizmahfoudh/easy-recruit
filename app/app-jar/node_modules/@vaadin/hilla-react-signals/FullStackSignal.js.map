{
  "version": 3,
  "sources": ["src/FullStackSignal.ts"],
  "sourcesContent": ["import type { ActionOnLostSubscription, ConnectClient, Subscription } from '@vaadin/hilla-frontend';\nimport { nanoid } from 'nanoid';\nimport { computed, signal, Signal } from './core.js';\nimport { createSetStateEvent, type StateEvent } from './events.js';\n\nconst ENDPOINT = 'SignalsHandler';\n\n/**\n * An abstraction of a signal that tracks the number of subscribers, and calls\n * the provided `onSubscribe` and `onUnsubscribe` callbacks for the first\n * subscription and the last unsubscription, respectively.\n * @internal\n */\nexport abstract class DependencyTrackingSignal<T> extends Signal<T> {\n  readonly #onFirstSubscribe: () => void;\n  readonly #onLastUnsubscribe: () => void;\n\n  // -1 means to ignore the first subscription that is created internally in the\n  // FullStackSignal constructor.\n  #subscribeCount = -1;\n\n  protected constructor(value: T | undefined, onFirstSubscribe: () => void, onLastUnsubscribe: () => void) {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n    if (!(window as any).Vaadin?.featureFlags?.fullstackSignals) {\n      // Remove when removing feature flag\n      throw new Error(\n        `The Hilla Fullstack Signals API is currently considered experimental and may change in the future. To use it you need to explicitly enable it in Copilot or by adding com.vaadin.experimental.fullstackSignals=true to vaadin-featureflags.properties`,\n      );\n    }\n    super(value);\n    this.#onFirstSubscribe = onFirstSubscribe;\n    this.#onLastUnsubscribe = onLastUnsubscribe;\n  }\n\n  protected override S(node: unknown): void {\n    super.S(node);\n    if (this.#subscribeCount === 0) {\n      this.#onFirstSubscribe();\n    }\n    this.#subscribeCount += 1;\n  }\n\n  protected override U(node: unknown): void {\n    super.U(node);\n    this.#subscribeCount -= 1;\n    if (this.#subscribeCount === 0) {\n      this.#onLastUnsubscribe();\n    }\n  }\n}\n\n/**\n * An object that describes a data object to connect to the signal provider\n * service.\n */\nexport type ServerConnectionConfig = Readonly<{\n  /**\n   * The client instance to be used for communication.\n   */\n  client: ConnectClient;\n\n  /**\n   * The name of the signal provider service endpoint.\n   */\n  endpoint: string;\n\n  /**\n   * The name of the signal provider service method.\n   */\n  method: string;\n\n  /**\n   * Optional object with method call arguments to be sent to the endpoint\n   * method that provides the signal when subscribing to it.\n   */\n  params?: Record<string, unknown>;\n}>;\n\n/**\n * A server connection manager.\n */\nclass ServerConnection<T> {\n  readonly #id: string;\n  readonly #config: ServerConnectionConfig;\n  #subscription?: Subscription<StateEvent<T>>;\n\n  constructor(id: string, config: ServerConnectionConfig) {\n    this.#config = config;\n    this.#id = id;\n  }\n\n  get subscription() {\n    return this.#subscription;\n  }\n\n  connect() {\n    const { client, endpoint, method, params } = this.#config;\n\n    this.#subscription ??= client.subscribe(ENDPOINT, 'subscribe', {\n      providerEndpoint: endpoint,\n      providerMethod: method,\n      clientSignalId: this.#id,\n      params,\n    });\n\n    return this.#subscription;\n  }\n\n  async update(event: StateEvent<T>): Promise<void> {\n    await this.#config.client.call(ENDPOINT, 'update', {\n      clientSignalId: this.#id,\n      event,\n    });\n  }\n\n  disconnect() {\n    this.#subscription?.cancel();\n    this.#subscription = undefined;\n  }\n}\n\nexport const $update = Symbol('update');\nexport const $processServerResponse = Symbol('processServerResponse');\n\n/**\n * A signal that holds a shared value. Each change to the value is propagated to\n * the server-side signal provider. At the same time, each change received from\n * the server-side signal provider is propagated to the local signal and it's\n * subscribers.\n *\n * @internal\n */\nexport abstract class FullStackSignal<T> extends DependencyTrackingSignal<T> {\n  /**\n   * The unique identifier of the signal necessary to communicate with the\n   * server.\n   */\n  readonly id = nanoid();\n\n  /**\n   * The server connection manager.\n   */\n  readonly server: ServerConnection<T>;\n\n  /**\n   * Defines whether the signal is currently awaits a server-side response.\n   */\n  readonly pending = computed(() => this.#pending.value);\n\n  /**\n   * Defines whether the signal has an error.\n   */\n  readonly error = computed(() => this.#error.value);\n\n  readonly #pending = signal(false);\n  readonly #error = signal<Error | undefined>(undefined);\n\n  // Paused at the very start to prevent the signal from sending the initial\n  // value to the server.\n  #paused = true;\n\n  constructor(value: T | undefined, config: ServerConnectionConfig) {\n    super(\n      value,\n      () => this.#connect(),\n      () => this.#disconnect(),\n    );\n    this.server = new ServerConnection(this.id, config);\n\n    this.subscribe((v) => {\n      if (!this.#paused) {\n        this.#pending.value = true;\n        this.#error.value = undefined;\n        this[$update](createSetStateEvent(v));\n      }\n    });\n\n    this.#paused = false;\n  }\n\n  /**\n   * Sets the local value of the signal without sending any events to the server\n   * @param value - The new value.\n   * @internal\n   */\n  protected setValueLocal(value: T): void {\n    this.#paused = true;\n    this.value = value;\n    this.#paused = false;\n  }\n\n  /**\n   * A method to update the server with the new value.\n   *\n   * @param event - The event to update the server with.\n   */\n  protected [$update](event: StateEvent<T>): void {\n    this.server\n      .update(event)\n      .catch((error: unknown) => {\n        this.#error.value = error instanceof Error ? error : new Error(String(error));\n      })\n      .finally(() => {\n        this.#pending.value = false;\n      });\n  }\n\n  /**\n   * A method with to process the server response. The implementation is\n   * specific for each signal type.\n   *\n   * @param event - The server response event.\n   */\n  protected abstract [$processServerResponse](event: StateEvent<T>): void;\n\n  #connect() {\n    this.server\n      .connect()\n      .onSubscriptionLost(() => 'resubscribe' as ActionOnLostSubscription)\n      .onNext((event: StateEvent<T>) => {\n        this.#paused = true;\n        this[$processServerResponse](event);\n        this.#paused = false;\n      });\n  }\n\n  #disconnect() {\n    if (this.server.subscription === undefined) {\n      return;\n    }\n    this.server.disconnect();\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
