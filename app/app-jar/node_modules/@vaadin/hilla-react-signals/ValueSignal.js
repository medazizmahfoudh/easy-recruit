import { createReplaceStateEvent } from "./events.js";
import { $processServerResponse, $update, FullStackSignal } from "./FullStackSignal.js";
class ValueSignal extends FullStackSignal {
  #pendingRequests = /* @__PURE__ */ new Map();
  /**
   * Sets the value.
   * Note that the value change event that is propagated to the server as the
   * result of this operation is not taking the last seen value into account and
   * will overwrite the shared value on the server unconditionally (AKA: "Last
   * Write Wins"). If you need to perform a conditional update, use the
   * `replace` method instead.
   *
   * @param value - The new value.
   */
  set(value) {
    this.value = value;
  }
  /**
   * Replaces the value with a new one only if the current value is equal to the
   * expected value.
   *
   * @param expected - The expected value.
   * @param newValue - The new value.
   */
  replace(expected, newValue) {
    this[$update](createReplaceStateEvent(expected, newValue));
  }
  /**
   * Tries to update the value by applying the callback function to the current
   * value. In case of a concurrent change, the callback is run again with an
   * updated input value. This is repeated until the result can be applied
   * without concurrent changes, or the operation is canceled.
   *
   * Note that there is no guarantee that cancel() will be effective always,
   * since a succeeding operation might already be on its way to the server.
   *
   * @param callback - The function that is applied on the current value to
   *                   produce the new value.
   * @returns An operation subscription that can be canceled.
   */
  update(callback) {
    const newValue = callback(this.value);
    const event = createReplaceStateEvent(this.value, newValue);
    this[$update](event);
    const waiter = Promise.withResolvers();
    const pendingRequest = { callback, waiter, canceled: false };
    this.#pendingRequests.set(event.id, pendingRequest);
    return {
      cancel: () => {
        pendingRequest.canceled = true;
        pendingRequest.waiter.resolve();
      }
    };
  }
  [$processServerResponse](event) {
    const record = this.#pendingRequests.get(event.id);
    if (record) {
      this.#pendingRequests.delete(event.id);
    }
    if (!event.accepted && record) {
      if (!record.canceled) {
        this.update(record.callback);
      }
    }
    if (event.accepted || event.type === "snapshot") {
      if (record) {
        record.waiter.resolve();
      }
      this.#applyAcceptedEvent(event);
    }
  }
  #applyAcceptedEvent(event) {
    if (event.type === "set" || event.type === "snapshot") {
      this.value = event.value;
    } else if (event.type === "replace") {
      if (JSON.stringify(this.value) === JSON.stringify(event.expected)) {
        this.value = event.value;
      }
    }
  }
}
export {
  ValueSignal
};
//# sourceMappingURL=ValueSignal.js.map
