import { protectRoute } from "@vaadin/hilla-react-auth";
import { createElement } from "react";
import {
  createBrowserRouter
} from "react-router-dom";
import { convertComponentNameToTitle } from "../shared/convertComponentNameToTitle.js";
import { transformTree } from "../shared/transformTree.js";
function isReactRouteModule(module) {
  return module ? "default" in module && typeof module.default === "function" : true;
}
function createRouteEntry(route) {
  return [`${route.path ?? ""}-${route.children ? "n" : "i"}`, route];
}
var RouteHandleFlags = /* @__PURE__ */ ((RouteHandleFlags2) => {
  RouteHandleFlags2["FLOW_LAYOUT"] = "flowLayout";
  RouteHandleFlags2["IGNORE_FALLBACK"] = "ignoreFallback";
  return RouteHandleFlags2;
})(RouteHandleFlags || {});
function hasRouteHandleFlag(route, flag) {
  return typeof route.handle === "object" && flag in route.handle && route.handle[flag];
}
class RouterConfigurationBuilder {
  #modifiers = [];
  /**
   * Adds the given routes to the current list of routes. All the routes are
   * deeply merged to preserve the path uniqueness.
   *
   * @param routes - A list of routes to add to the current list.
   */
  withReactRoutes(routes) {
    return this.update(routes);
  }
  /**
   * Adds the given file routes to the current list of routes. All the routes
   * are transformed to React RouterObjects and deeply merged to preserve the
   * path uniqueness.
   *
   * @param routes - A list of routes to add to the current list.
   */
  withFileRoutes(routes) {
    return this.update(routes, (original, added, children) => {
      if (added) {
        const { module, path, flowLayout } = added;
        if (!isReactRouteModule(module)) {
          throw new Error(`The module for the "${path}" section doesn't have the React component exported by default`);
        }
        const element = module?.default ? createElement(module.default) : void 0;
        const handle = {
          ...module?.config,
          title: module?.config?.title ?? convertComponentNameToTitle(module?.default),
          flowLayout: module?.config?.flowLayout ?? flowLayout
        };
        if (path === "" && !children) {
          return {
            ...original,
            element,
            handle,
            index: true
          };
        }
        return {
          ...original,
          path: module?.config?.route ?? path,
          element,
          children,
          handle
        };
      }
      return original;
    });
  }
  /**
   * Adds the given server route element to each branch of the current list of
   * routes.
   *
   * @param component - The React component to add to each branch of the
   * current list of routes.
   * @param config - An optional configuration that will be applied to
   * each fallback component.
   */
  withFallback(component, config) {
    this.withLayout(component);
    const fallbackRoutes = [
      { path: "*", element: createElement(component), handle: config },
      { index: true, element: createElement(component), handle: config }
    ];
    this.update(fallbackRoutes, (original, added, children) => {
      if (original && !hasRouteHandleFlag(original, "ignoreFallback" /* IGNORE_FALLBACK */)) {
        if (!children) {
          return original;
        }
        const _fallback = [...fallbackRoutes];
        if (children.some(({ path }) => path === "*")) {
          _fallback.shift();
        }
        if (children.some(({ index: i, path }) => i ?? path?.includes("?"))) {
          _fallback.pop();
        }
        return {
          ...original,
          children: [...children, ..._fallback]
        };
      }
      return added;
    });
    return this;
  }
  /**
   * Adds the layoutComponent as the parent layout to views with the flowLayouts ViewConfiguration set.
   *
   * @param layoutComponent - layout component to use, usually Flow
   */
  withLayout(layoutComponent) {
    this.#modifiers.push((originalRoutes) => {
      if (originalRoutes === void 0) {
        return originalRoutes;
      }
      const [serverRoutesTree, clientRoutesTree] = transformTree(
        originalRoutes,
        (routes, next) => (
          // Split single routes list onto two filtered lists
          routes.reduce(
            ([serverRoutesList, clientRoutesList], route) => {
              if (hasRouteHandleFlag(route, "flowLayout" /* FLOW_LAYOUT */)) {
                return [[...serverRoutesList ?? [], route], clientRoutesList];
              }
              if (!route.children?.length) {
                return [serverRoutesList, [...clientRoutesList ?? [], route]];
              }
              const [serverRouteSubtree, clientRouteSubtree] = next(...route.children);
              return [
                serverRouteSubtree ? [
                  ...serverRoutesList ?? [],
                  {
                    ...route,
                    children: serverRouteSubtree
                  }
                ] : serverRoutesList,
                clientRouteSubtree ? [
                  ...clientRoutesList ?? [],
                  {
                    ...route,
                    children: clientRouteSubtree
                  }
                ] : clientRoutesList
              ];
            },
            [void 0, void 0]
          )
        )
      );
      return [
        // The server subtree is wrapped with the server layout component,
        // which applies the top-level server layout to all matches.
        ...serverRoutesTree ? [
          {
            element: createElement(layoutComponent),
            children: serverRoutesTree,
            handle: {
              ["ignoreFallback" /* IGNORE_FALLBACK */]: true
            }
          }
        ] : [],
        // The client route subtree is preserved without wrapping.
        ...clientRoutesTree ?? []
      ];
    });
    return this;
  }
  /**
   * Protects all the routes that require authentication. For more details see
   * {@link @vaadin/hilla-react-auth#protectRoutes} function.
   *
   * @param redirectPath - the path to redirect to if the route is protected
   * and the user is not authenticated.
   */
  protect(redirectPath) {
    this.update(void 0, (route, _, children) => {
      const finalRoute = protectRoute(route, redirectPath);
      finalRoute.children = children;
      return finalRoute;
    });
    return this;
  }
  update(routes, callback = (original, overriding, children) => ({
    ...original,
    ...overriding,
    children
  })) {
    this.#modifiers.push(
      (existingRoutes) => transformTree(
        [existingRoutes, routes],
        ([original, added], next) => {
          if (original && added) {
            const originalMap = new Map(original.map((route) => createRouteEntry(route)));
            const addedMap = new Map(added.map((route) => createRouteEntry(route)));
            const paths = /* @__PURE__ */ new Set([...originalMap.keys(), ...addedMap.keys()]);
            for (const path of paths) {
              const originalRoute = originalMap.get(path);
              const addedRoute = addedMap.get(path);
              let route;
              if (originalRoute && addedRoute) {
                route = callback(originalRoute, addedRoute, next(originalRoute.children, addedRoute.children));
              } else if (originalRoute) {
                route = callback(originalRoute, void 0, next(originalRoute.children, void 0));
              } else {
                route = callback(void 0, addedRoute, next(void 0, addedRoute.children));
              }
              if (route) {
                originalMap.set(path, route);
              }
            }
            return [...originalMap.values()];
          } else if (original) {
            return original.map((route) => callback(route, void 0, next(route.children, void 0))).filter(Boolean);
          } else if (added) {
            return added.map((route) => callback(void 0, route, next(void 0, route.children))).filter(Boolean);
          }
          return void 0;
        }
      )
    );
    return this;
  }
  /**
   * Builds the router with the current list of routes.
   */
  build(options) {
    const routes = this.#modifiers.reduce((acc, mod) => mod(acc) ?? acc, void 0) ?? [];
    return {
      routes,
      router: createBrowserRouter([...routes], { basename: new URL(document.baseURI).pathname, ...options })
    };
  }
}
export {
  RouterConfigurationBuilder
};
//# sourceMappingURL=RouterConfigurationBuilder.js.map
