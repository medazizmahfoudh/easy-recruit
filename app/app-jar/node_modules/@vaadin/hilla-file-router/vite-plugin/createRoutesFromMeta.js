import { relative, sep } from "node:path";
import { fileURLToPath } from "node:url";
import { template, transform as transformer } from "@vaadin/hilla-generator-utils/ast.js";
import createSourceFile from "@vaadin/hilla-generator-utils/createSourceFile.js";
import ts, {
} from "typescript";
import { transformTree } from "../shared/transformTree.js";
import { convertFSRouteSegmentToURLPatternFormat } from "./utils.js";
const printer = ts.createPrinter({ newLine: ts.NewLineKind.LineFeed });
function relativize(url, generatedDir) {
  const result = relative(fileURLToPath(generatedDir), fileURLToPath(url)).replaceAll(sep, "/");
  if (!result.startsWith(".")) {
    return `./${result}`;
  }
  return result;
}
function createImport(mod, file) {
  const path = `${file.substring(0, file.lastIndexOf("."))}.js`;
  return template(`import * as ${mod} from '${path}';
`, ([statement]) => statement);
}
function createRouteData(path, flowLayout, mod, children) {
  const serverLayout = flowLayout ?? false;
  return template(
    `const route = createRoute("${path}",${serverLayout}${mod ? `, ${mod}` : ""}${children ? `, CHILDREN` : ""})`,
    ([statement]) => statement.declarationList.declarations[0].initializer,
    [
      transformer(
        (node) => ts.isIdentifier(node) && node.text === "CHILDREN" ? ts.factory.createArrayLiteralExpression(children, true) : node
      )
    ]
  );
}
function createRoutesFromMeta(views, { code: codeFile }) {
  const codeDir = new URL("./", codeFile);
  const imports = [];
  const errors = [];
  let id = 0;
  const routes = transformTree(views, (metas, next) => {
    errors.push(
      ...metas.map((route) => route.path).filter((item, index, arr) => arr.indexOf(item) !== index).map((dup) => `console.error("Two views share the same path: ${dup}");`)
    );
    return metas.map(({ file: file2, layout, path, children, flowLayout }) => {
      let _children;
      if (children) {
        _children = next(...children);
      }
      const currentId = id;
      id += 1;
      let mod;
      if (file2) {
        mod = `Page${currentId}`;
        imports.push(createImport(mod, relativize(file2, codeDir)));
      } else if (layout) {
        mod = `Layout${currentId}`;
        imports.push(createImport(mod, relativize(layout, codeDir)));
      }
      return createRouteData(convertFSRouteSegmentToURLPatternFormat(path), flowLayout, mod, _children);
    });
  });
  if (imports.length > 0) {
    const createRouteImport = template(
      'import { createRoute } from "@vaadin/hilla-file-router/runtime.js";',
      ([statement]) => statement
    );
    imports.unshift(createRouteImport);
  }
  imports.unshift(
    template(
      'import type { AgnosticRoute } from "@vaadin/hilla-file-router/types.js";',
      ([statement]) => statement
    )
  );
  const routeDeclaration = template(
    `import a from 'IMPORTS';

${errors.join("\n")}

const routes: readonly AgnosticRoute[] = ROUTE;

export default routes;
`,
    [
      transformer(
        (node) => ts.isImportDeclaration(node) && node.moduleSpecifier.text === "IMPORTS" ? imports : node
      ),
      transformer(
        (node) => ts.isIdentifier(node) && node.text === "ROUTE" ? ts.factory.createArrayLiteralExpression(routes, true) : node
      )
    ]
  );
  const file = createSourceFile(routeDeclaration, "file-routes.ts");
  return printer.printFile(file);
}
export {
  createRoutesFromMeta as default
};
//# sourceMappingURL=createRoutesFromMeta.js.map
