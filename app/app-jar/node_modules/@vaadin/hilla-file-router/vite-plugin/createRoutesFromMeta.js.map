{
  "version": 3,
  "sources": ["../src/vite-plugin/createRoutesFromMeta.ts"],
  "sourcesContent": ["import { relative, sep } from 'node:path';\nimport { fileURLToPath } from 'node:url';\nimport { template, transform as transformer } from '@vaadin/hilla-generator-utils/ast.js';\nimport createSourceFile from '@vaadin/hilla-generator-utils/createSourceFile.js';\nimport ts, {\n  type CallExpression,\n  type ImportDeclaration,\n  type StringLiteral,\n  type VariableStatement,\n} from 'typescript';\n\nimport { transformTree } from '../shared/transformTree.js';\nimport type { RouteMeta } from './collectRoutesFromFS.js';\nimport type { RuntimeFileUrls } from './generateRuntimeFiles.js';\nimport { convertFSRouteSegmentToURLPatternFormat } from './utils.js';\n\nconst printer = ts.createPrinter({ newLine: ts.NewLineKind.LineFeed });\n\n/**\n * Convert a file URL to a relative path from the generated directory.\n *\n * @param url - The file URL to convert.\n * @param generatedDir - The directory where the generated view file will be stored.\n */\nfunction relativize(url: URL, generatedDir: URL): string {\n  const result = relative(fileURLToPath(generatedDir), fileURLToPath(url)).replaceAll(sep, '/');\n\n  if (!result.startsWith('.')) {\n    return `./${result}`;\n  }\n\n  return result;\n}\n\n/**\n * Create an import declaration for a `views` module.\n *\n * @param mod - The name of the route module to import.\n * @param file - The file path of the module.\n */\nfunction createImport(mod: string, file: string): ImportDeclaration {\n  const path = `${file.substring(0, file.lastIndexOf('.'))}.js`;\n  return template(`import * as ${mod} from '${path}';\\n`, ([statement]) => statement as ts.ImportDeclaration);\n}\n\n/**\n * Create an abstract route creation function call. The nested function calls create a route tree.\n *\n * @param path - The path of the route.\n * @param mod - The name of the route module imported as a namespace.\n * @param children - The list of child route call expressions.\n */\nfunction createRouteData(\n  path: string,\n  flowLayout: boolean | undefined,\n  mod: string | undefined,\n  children?: readonly CallExpression[],\n): CallExpression {\n  const serverLayout = flowLayout ?? false;\n  return template(\n    `const route = createRoute(\"${path}\",${serverLayout}${mod ? `, ${mod}` : ''}${children ? `, CHILDREN` : ''})`,\n    ([statement]) => (statement as VariableStatement).declarationList.declarations[0].initializer as CallExpression,\n    [\n      transformer((node) =>\n        ts.isIdentifier(node) && node.text === 'CHILDREN'\n          ? ts.factory.createArrayLiteralExpression(children, true)\n          : node,\n      ),\n    ],\n  );\n}\n\n/**\n * Loads all the files from the received metadata and creates a framework-agnostic route tree.\n *\n * @param views - The abstract route tree.\n * @param generatedDir - The directory where the generated view file will be stored.\n */\nexport default function createRoutesFromMeta(views: readonly RouteMeta[], { code: codeFile }: RuntimeFileUrls): string {\n  const codeDir = new URL('./', codeFile);\n  const imports: ImportDeclaration[] = [];\n  const errors: string[] = [];\n  let id = 0;\n\n  const routes = transformTree<readonly RouteMeta[], readonly CallExpression[]>(views, (metas, next) => {\n    errors.push(\n      ...metas\n        .map((route) => route.path)\n        .filter((item, index, arr) => arr.indexOf(item) !== index)\n        .map((dup) => `console.error(\"Two views share the same path: ${dup}\");`),\n    );\n\n    return metas.map(({ file, layout, path, children, flowLayout }) => {\n      let _children: readonly CallExpression[] | undefined;\n\n      if (children) {\n        _children = next(...children);\n      }\n\n      const currentId = id;\n      id += 1;\n\n      let mod: string | undefined;\n      if (file) {\n        mod = `Page${currentId}`;\n        imports.push(createImport(mod, relativize(file, codeDir)));\n      } else if (layout) {\n        mod = `Layout${currentId}`;\n        imports.push(createImport(mod, relativize(layout, codeDir)));\n      }\n\n      return createRouteData(convertFSRouteSegmentToURLPatternFormat(path), flowLayout, mod, _children);\n    });\n  });\n\n  // Prepend the import for `createRoute` if it was used\n  if (imports.length > 0) {\n    const createRouteImport = template(\n      'import { createRoute } from \"@vaadin/hilla-file-router/runtime.js\";',\n      ([statement]) => statement as ts.ImportDeclaration,\n    );\n    imports.unshift(createRouteImport);\n  }\n\n  imports.unshift(\n    template(\n      'import type { AgnosticRoute } from \"@vaadin/hilla-file-router/types.js\";',\n      ([statement]) => statement as ts.ImportDeclaration,\n    ),\n  );\n\n  const routeDeclaration = template(\n    `import a from 'IMPORTS';\n\n${errors.join('\\n')}\n\nconst routes: readonly AgnosticRoute[] = ROUTE;\n\nexport default routes;\n`,\n    [\n      transformer((node) =>\n        ts.isImportDeclaration(node) && (node.moduleSpecifier as StringLiteral).text === 'IMPORTS' ? imports : node,\n      ),\n      transformer((node) =>\n        ts.isIdentifier(node) && node.text === 'ROUTE' ? ts.factory.createArrayLiteralExpression(routes, true) : node,\n      ),\n    ],\n  );\n\n  const file = createSourceFile(routeDeclaration, 'file-routes.ts');\n  return printer.printFile(file);\n}\n"],
  "mappings": "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",
  "names": ["file"]
}
