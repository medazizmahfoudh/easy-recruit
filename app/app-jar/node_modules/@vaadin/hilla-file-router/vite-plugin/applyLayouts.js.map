{
  "version": 3,
  "sources": ["../src/vite-plugin/applyLayouts.ts"],
  "sourcesContent": ["import { existsSync } from 'node:fs';\nimport { readFile } from 'node:fs/promises';\nimport type { RouteMeta } from './collectRoutesFromFS.js';\n\n/**\n * The information about a particular server-side layout.\n */\nexport type LayoutMeta = Readonly<{\n  path: string;\n}>;\n\nfunction stripLeadingSlash(path: string) {\n  return path.startsWith('/') ? path.slice(1) : path;\n}\n\nfunction enableFlowLayout(route: RouteMeta): RouteMeta {\n  const routeWithFlowLayout = {\n    ...route,\n    flowLayout: true,\n  };\n  return route.children\n    ? {\n        ...routeWithFlowLayout,\n        children: route.children.map(enableFlowLayout),\n      }\n    : routeWithFlowLayout;\n}\n\n/**\n * Check if there is a layout available that can handle the given path.\n * Layouts match the starting parts of the path so '/' will match all paths\n * and '/home' matches '/home' anything with the start path '/home/*'\n *\n * @param layoutPaths - available layout paths\n * @param path - to check for layout\n */\nfunction layoutExists(layoutPaths: string[], path: string) {\n  const splitPath: string[] = path.split('/');\n\n  return layoutPaths.some((layout) => {\n    if (layout.length === 0) {\n      return true;\n    }\n    const splitLayout: string[] = layout.split('/');\n    if (splitLayout.length > splitPath.length) {\n      return false;\n    }\n    for (let i = 0; i < splitLayout.length; i++) {\n      if (splitPath[i] !== splitLayout[i]) {\n        return false;\n      }\n    }\n    return true;\n  });\n}\n\n/**\n * Enables Flow layout flag on the matching routes based on the information from the layouts JSON file.\n *\n * @param routeMeta - The routes tree to process.\n * @param layoutsFile - The server layouts JSON file.\n * @returns Processed routes tree.\n */\nexport default async function applyLayouts(\n  routeMeta: readonly RouteMeta[],\n  layoutsFile: URL,\n): Promise<readonly RouteMeta[]> {\n  if (!existsSync(layoutsFile)) {\n    return routeMeta;\n  }\n  const layoutContents = await readFile(layoutsFile, 'utf-8');\n  const availableLayouts: readonly LayoutMeta[] = JSON.parse(layoutContents);\n  const layoutPaths = availableLayouts.map((layout) => stripLeadingSlash(layout.path));\n\n  return routeMeta.map((route) =>\n    layoutExists(layoutPaths, stripLeadingSlash(route.path)) ? enableFlowLayout(route) : route,\n  );\n}\n"],
  "mappings": "AAAA,SAAS,kBAAkB;AAC3B,SAAS,gBAAgB;AAUzB,SAAS,kBAAkB,MAAc;AACvC,SAAO,KAAK,WAAW,GAAG,IAAI,KAAK,MAAM,CAAC,IAAI;AAChD;AAEA,SAAS,iBAAiB,OAA6B;AACrD,QAAM,sBAAsB;AAAA,IAC1B,GAAG;AAAA,IACH,YAAY;AAAA,EACd;AACA,SAAO,MAAM,WACT;AAAA,IACE,GAAG;AAAA,IACH,UAAU,MAAM,SAAS,IAAI,gBAAgB;AAAA,EAC/C,IACA;AACN;AAUA,SAAS,aAAa,aAAuB,MAAc;AACzD,QAAM,YAAsB,KAAK,MAAM,GAAG;AAE1C,SAAO,YAAY,KAAK,CAAC,WAAW;AAClC,QAAI,OAAO,WAAW,GAAG;AACvB,aAAO;AAAA,IACT;AACA,UAAM,cAAwB,OAAO,MAAM,GAAG;AAC9C,QAAI,YAAY,SAAS,UAAU,QAAQ;AACzC,aAAO;AAAA,IACT;AACA,aAAS,IAAI,GAAG,IAAI,YAAY,QAAQ,KAAK;AAC3C,UAAI,UAAU,CAAC,MAAM,YAAY,CAAC,GAAG;AACnC,eAAO;AAAA,MACT;AAAA,IACF;AACA,WAAO;AAAA,EACT,CAAC;AACH;AASA,eAAO,aACL,WACA,aAC+B;AAC/B,MAAI,CAAC,WAAW,WAAW,GAAG;AAC5B,WAAO;AAAA,EACT;AACA,QAAM,iBAAiB,MAAM,SAAS,aAAa,OAAO;AAC1D,QAAM,mBAA0C,KAAK,MAAM,cAAc;AACzE,QAAM,cAAc,iBAAiB,IAAI,CAAC,WAAW,kBAAkB,OAAO,IAAI,CAAC;AAEnF,SAAO,UAAU;AAAA,IAAI,CAAC,UACpB,aAAa,aAAa,kBAAkB,MAAM,IAAI,CAAC,IAAI,iBAAiB,KAAK,IAAI;AAAA,EACvF;AACF;",
  "names": []
}
