import { dirname } from "path/posix";
import {
  convertReferenceSchemaToPath,
  convertReferenceSchemaToSpecifier,
  decomposeSchema,
  isComposedSchema,
  isEmptyObject,
  isEnumSchema,
  isNullableSchema,
  isObjectSchema,
  isReferenceSchema
} from "@vaadin/hilla-generator-core/Schema.js";
import {
  convertFullyQualifiedNameToRelativePath,
  simplifyFullyQualifiedName
} from "@vaadin/hilla-generator-core/utils.js";
import createSourceFile from "@vaadin/hilla-generator-utils/createSourceFile.js";
import DependencyManager from "@vaadin/hilla-generator-utils/dependencies/DependencyManager.js";
import PathManager from "@vaadin/hilla-generator-utils/dependencies/PathManager.js";
import ts, {
} from "typescript";
import TypeSchemaProcessor from "./TypeSchemaProcessor.js";
import { findTypeParameters } from "./utils.js";
class EntityProcessor {
  #component;
  #dependencies;
  #fullyQualifiedName;
  #name;
  #outputPathManager = new PathManager({ extension: "ts" });
  #owner;
  #path;
  constructor(name, component, owner) {
    this.#component = component;
    this.#owner = owner;
    this.#fullyQualifiedName = name;
    this.#name = simplifyFullyQualifiedName(name);
    this.#path = convertFullyQualifiedNameToRelativePath(name);
    this.#dependencies = new DependencyManager(new PathManager({ extension: ".js", relativeTo: dirname(this.#path) }));
  }
  get #id() {
    const id = ts.factory.createIdentifier(this.#name);
    this.#dependencies.exports.default.set(id);
    return id;
  }
  process() {
    this.#owner.logger.debug(`Processing entity: ${this.#name}`);
    const declaration = isEnumSchema(this.#component) ? this.#processEnum(this.#component) : this.#processExtendedClass(this.#component);
    const statements = declaration ? [declaration] : [];
    const { exports, imports } = this.#dependencies;
    return createSourceFile(
      [...imports.toCode(), ...statements, ...exports.toCode()],
      this.#outputPathManager.createRelativePath(this.#path)
    );
  }
  #processClass(schema) {
    const { logger } = this.#owner;
    if (!isObjectSchema(schema)) {
      logger.debug(schema, `Component is not an object: '${this.#fullyQualifiedName}'`);
      return void 0;
    }
    if (isEmptyObject(schema)) {
      logger.debug(`Component has no properties:' ${this.#fullyQualifiedName}'`);
    }
    return ts.factory.createInterfaceDeclaration(
      void 0,
      this.#id,
      EntityProcessor.#processTypeParameters(schema),
      void 0,
      this.#processTypeElements(schema)
    );
  }
  #processEnum({ enum: members }) {
    return ts.factory.createEnumDeclaration(
      void 0,
      this.#id,
      members.map((member) => ts.factory.createEnumMember(member, ts.factory.createStringLiteral(member)))
    );
  }
  #processExtendedClass(schema) {
    const { logger } = this.#owner;
    if (isComposedSchema(schema)) {
      const decomposed = decomposeSchema(schema);
      if (decomposed.length > 2) {
        logger.debug(
          schema,
          `Schema for '${this.#fullyQualifiedName}' has more than two components. This plugin will ignore it.`
        );
        return void 0;
      }
      const [parent, child] = decomposed;
      if (!isReferenceSchema(parent)) {
        logger.debug(parent, "Only reference schema allowed for parent class");
        return void 0;
      }
      const declaration = this.#processClass(child);
      const identifier = this.#processParentClass(parent);
      return declaration && ts.factory.updateInterfaceDeclaration(
        declaration,
        declaration.modifiers,
        declaration.name,
        declaration.typeParameters,
        [
          ts.factory.createHeritageClause(ts.SyntaxKind.ExtendsKeyword, [
            ts.factory.createExpressionWithTypeArguments(identifier, void 0)
          ])
        ],
        declaration.members
      );
    }
    return this.#processClass(schema);
  }
  #processParentClass(schema) {
    const { imports, paths } = this.#dependencies;
    const specifier = convertReferenceSchemaToSpecifier(schema);
    const path = paths.createRelativePath(convertReferenceSchemaToPath(schema));
    return imports.default.getIdentifier(path) ?? imports.default.add(path, specifier, true);
  }
  #processTypeElements({ properties }) {
    return Object.entries(properties ?? {}).map(([name, schema]) => {
      const [type] = new TypeSchemaProcessor(schema, this.#dependencies).process();
      return ts.factory.createPropertySignature(
        void 0,
        name,
        isNullableSchema(schema) ? ts.factory.createToken(ts.SyntaxKind.QuestionToken) : void 0,
        type
      );
    });
  }
  static #processTypeParameters(schema) {
    return findTypeParameters(schema)?.map(String).map(
      (name) => ts.factory.createTypeParameterDeclaration(
        void 0,
        name,
        void 0,
        ts.factory.createKeywordTypeNode(ts.SyntaxKind.UnknownKeyword)
      )
    );
  }
}
export {
  EntityProcessor
};
//# sourceMappingURL=EntityProcessor.js.map
