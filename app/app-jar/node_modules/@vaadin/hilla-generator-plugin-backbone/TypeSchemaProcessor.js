import {
  convertReferenceSchemaToPath,
  convertReferenceSchemaToSpecifier,
  decomposeSchema,
  isArraySchema,
  isBooleanSchema,
  isComposedSchema,
  isIntegerSchema,
  isMapSchema,
  isNullableSchema,
  isNumberSchema,
  isReferenceSchema,
  isStringSchema
} from "@vaadin/hilla-generator-core/Schema.js";
import ts, {} from "typescript";
import { findTypeArguments, findTypeVariable } from "./utils.js";
function createBoolean() {
  return ts.factory.createKeywordTypeNode(ts.SyntaxKind.BooleanKeyword);
}
function createNumber() {
  return ts.factory.createKeywordTypeNode(ts.SyntaxKind.NumberKeyword);
}
function createString() {
  return ts.factory.createKeywordTypeNode(ts.SyntaxKind.StringKeyword);
}
function createUndefined() {
  return ts.factory.createKeywordTypeNode(ts.SyntaxKind.UndefinedKeyword);
}
function createUnknown() {
  return ts.factory.createKeywordTypeNode(ts.SyntaxKind.UnknownKeyword);
}
function unwrapPossiblyNullableSchema(schema) {
  if (isComposedSchema(schema)) {
    const [result] = decomposeSchema(schema);
    return result;
  }
  return schema;
}
class TypeSchemaProcessor {
  #dependencies;
  #schema;
  constructor(schema, dependencies) {
    this.#schema = schema;
    this.#dependencies = dependencies;
  }
  process() {
    let node;
    const unwrappedSchema = unwrapPossiblyNullableSchema(this.#schema);
    const typeVariable = findTypeVariable(this.#schema);
    if (typeVariable) {
      return [ts.factory.createTypeReferenceNode(typeVariable)];
    }
    if (isReferenceSchema(unwrappedSchema)) {
      const typeArguments = this.#processTypeArguments(this.#schema);
      node = this.#processReference(unwrappedSchema, typeArguments);
    } else if (isArraySchema(unwrappedSchema)) {
      node = this.#processArray(unwrappedSchema);
    } else if (isMapSchema(unwrappedSchema)) {
      node = this.#processMap(unwrappedSchema);
    } else if (isBooleanSchema(unwrappedSchema)) {
      node = createBoolean();
    } else if (isIntegerSchema(unwrappedSchema) || isNumberSchema(unwrappedSchema)) {
      node = createNumber();
    } else if (isStringSchema(unwrappedSchema)) {
      node = createString();
    } else {
      node = createUnknown();
    }
    return isNullableSchema(this.#schema) ? [node, createUndefined()] : [node];
  }
  #processArray(schema) {
    const nodes = new TypeSchemaProcessor(schema.items, this.#dependencies).process();
    return ts.factory.createTypeReferenceNode("Array", [ts.factory.createUnionTypeNode(nodes)]);
  }
  #processMap({ additionalProperties: valuesType }) {
    let valuesTypeNode;
    if (typeof valuesType !== "boolean") {
      const nodes = new TypeSchemaProcessor(valuesType, this.#dependencies).process();
      valuesTypeNode = ts.factory.createUnionTypeNode(nodes);
    } else {
      valuesTypeNode = ts.factory.createKeywordTypeNode(ts.SyntaxKind.UnknownKeyword);
    }
    return ts.factory.createTypeReferenceNode("Record", [
      ts.factory.createKeywordTypeNode(ts.SyntaxKind.StringKeyword),
      valuesTypeNode
    ]);
  }
  #processTypeArguments(schema) {
    return findTypeArguments(schema)?.allOf.map((s) => new TypeSchemaProcessor(s, this.#dependencies).process()).map((t) => ts.factory.createUnionTypeNode(t));
  }
  #processReference(schema, typeArguments) {
    const { imports, paths } = this.#dependencies;
    const specifier = convertReferenceSchemaToSpecifier(schema);
    const path = paths.createRelativePath(convertReferenceSchemaToPath(schema));
    const identifier = imports.default.getIdentifier(path) ?? imports.default.add(path, specifier, true);
    return ts.factory.createTypeReferenceNode(identifier, typeArguments);
  }
}
export {
  TypeSchemaProcessor as default
};
//# sourceMappingURL=TypeSchemaProcessor.js.map
