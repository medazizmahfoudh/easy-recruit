import atmosphere from "atmosphere.js";
import { getCsrfTokenHeadersForEndpointRequest } from "./CsrfUtils.js";
import {
  isClientMessage
} from "./FluxMessages.js";
var State = /* @__PURE__ */ ((State2) => {
  State2["ACTIVE"] = "active";
  State2["INACTIVE"] = "inactive";
  State2["RECONNECTING"] = "reconnecting";
  return State2;
})(State || {});
var ActionOnLostSubscription = /* @__PURE__ */ ((ActionOnLostSubscription2) => {
  ActionOnLostSubscription2["RESUBSCRIBE"] = "resubscribe";
  ActionOnLostSubscription2["REMOVE"] = "remove";
  return ActionOnLostSubscription2;
})(ActionOnLostSubscription || {});
class FluxConnection extends EventTarget {
  state = "inactive" /* INACTIVE */;
  #endpointInfos = /* @__PURE__ */ new Map();
  #nextId = 0;
  #onCompleteCallbacks = /* @__PURE__ */ new Map();
  #onErrorCallbacks = /* @__PURE__ */ new Map();
  #onNextCallbacks = /* @__PURE__ */ new Map();
  #pendingMessages = [];
  #socket;
  constructor(connectPrefix, atmosphereOptions) {
    super();
    this.#connectWebsocket(connectPrefix.replace(/connect$/u, ""), atmosphereOptions ?? {});
  }
  /**
   * Subscribes to the flux returned by the given endpoint name + method name using the given parameters.
   *
   * @param endpointName - the endpoint to connect to
   * @param methodName - the method in the endpoint to connect to
   * @param parameters - the parameters to use
   * @returns a subscription
   */
  subscribe(endpointName, methodName, parameters) {
    const id = this.#nextId.toString();
    this.#nextId += 1;
    const params = parameters ?? [];
    const msg = { "@type": "subscribe", endpointName, id, methodName, params };
    this.#send(msg);
    this.#endpointInfos.set(id, { endpointName, methodName, params });
    const hillaSubscription = {
      cancel: () => {
        if (!this.#endpointInfos.has(id)) {
          return;
        }
        const closeMessage = { "@type": "unsubscribe", id };
        this.#send(closeMessage);
        this.#removeSubscription(id);
      },
      context(context) {
        context.addController({
          hostDisconnected() {
            hillaSubscription.cancel();
          }
        });
        return hillaSubscription;
      },
      onComplete: (callback) => {
        this.#onCompleteCallbacks.set(id, callback);
        return hillaSubscription;
      },
      onError: (callback) => {
        this.#onErrorCallbacks.set(id, callback);
        return hillaSubscription;
      },
      onNext: (callback) => {
        this.#onNextCallbacks.set(id, callback);
        return hillaSubscription;
      },
      onSubscriptionLost: (callback) => {
        if (this.#endpointInfos.has(id)) {
          this.#endpointInfos.get(id).reconnect = callback;
        } else {
          console.warn(`"onReconnect" value not set for subscription "${id}" because it was already canceled`);
        }
        return hillaSubscription;
      }
    };
    return hillaSubscription;
  }
  #connectWebsocket(prefix, atmosphereOptions) {
    const extraHeaders = getCsrfTokenHeadersForEndpointRequest(document);
    const pushUrl = "HILLA/push";
    const url = prefix.length === 0 ? pushUrl : (prefix.endsWith("/") ? prefix : `${prefix}/`) + pushUrl;
    this.#socket = atmosphere.subscribe?.({
      contentType: "application/json; charset=UTF-8",
      enableProtocol: true,
      transport: "websocket",
      fallbackTransport: "websocket",
      headers: extraHeaders,
      maxReconnectOnClose: 1e7,
      reconnectInterval: 5e3,
      timeout: -1,
      trackMessageLength: true,
      url,
      onClose: () => {
        if (this.state !== "inactive" /* INACTIVE */) {
          this.state = "inactive" /* INACTIVE */;
          this.dispatchEvent(new CustomEvent("state-changed", { detail: { active: false } }));
        }
      },
      onError: (response) => {
        console.error("error in push communication", response);
      },
      onMessage: (response) => {
        if (response.responseBody) {
          this.#handleMessage(JSON.parse(response.responseBody));
        }
      },
      onMessagePublished: (response) => {
        if (response?.responseBody) {
          this.#handleMessage(JSON.parse(response.responseBody));
        }
      },
      onOpen: () => {
        if (this.state !== "active" /* ACTIVE */) {
          this.state = "active" /* ACTIVE */;
          this.dispatchEvent(new CustomEvent("state-changed", { detail: { active: true } }));
          this.#sendPendingMessages();
        }
      },
      onReopen: () => {
        if (this.state !== "active" /* ACTIVE */) {
          const toBeRemoved = [];
          this.#endpointInfos.forEach((endpointInfo, id) => {
            if (endpointInfo.reconnect?.() === "resubscribe" /* RESUBSCRIBE */) {
              this.#send({
                "@type": "subscribe",
                endpointName: endpointInfo.endpointName,
                id,
                methodName: endpointInfo.methodName,
                params: endpointInfo.params
              });
            } else {
              toBeRemoved.push(id);
            }
          });
          toBeRemoved.forEach((id) => this.#removeSubscription(id));
          this.state = "active" /* ACTIVE */;
          this.dispatchEvent(new CustomEvent("state-changed", { detail: { active: true } }));
          this.#sendPendingMessages();
        }
      },
      onReconnect: () => {
        if (this.state !== "reconnecting" /* RECONNECTING */) {
          this.state = "reconnecting" /* RECONNECTING */;
        }
      },
      onFailureToReconnect: () => {
        if (this.state !== "inactive" /* INACTIVE */) {
          this.state = "inactive" /* INACTIVE */;
          this.dispatchEvent(new CustomEvent("state-changed", { detail: { active: false } }));
        }
      },
      ...atmosphereOptions
    });
  }
  #handleMessage(message) {
    if (isClientMessage(message)) {
      const { id } = message;
      const endpointInfo = this.#endpointInfos.get(id);
      if (message["@type"] === "update") {
        const callback = this.#onNextCallbacks.get(id);
        if (callback) {
          callback(message.item);
        }
      } else if (message["@type"] === "complete") {
        this.#onCompleteCallbacks.get(id)?.();
        this.#removeSubscription(id);
      } else {
        const callback = this.#onErrorCallbacks.get(id);
        if (callback) {
          callback();
        }
        this.#removeSubscription(id);
        if (!callback) {
          throw new Error(
            endpointInfo ? `Error in ${endpointInfo.endpointName}.${endpointInfo.methodName}(${JSON.stringify(endpointInfo.params)}): ${message.message}` : `Error in unknown subscription: ${message.message}`
          );
        }
      }
    } else {
      throw new Error(`Unknown message from server: ${String(message)}`);
    }
  }
  #removeSubscription(id) {
    this.#onNextCallbacks.delete(id);
    this.#onCompleteCallbacks.delete(id);
    this.#onErrorCallbacks.delete(id);
    this.#endpointInfos.delete(id);
  }
  #send(message) {
    if (this.state === "inactive" /* INACTIVE */) {
      this.#pendingMessages.push(message);
    } else {
      this.#socket?.push?.(JSON.stringify(message));
    }
  }
  #sendPendingMessages() {
    this.#pendingMessages.forEach((msg) => this.#send(msg));
    this.#pendingMessages = [];
  }
}
export {
  ActionOnLostSubscription,
  FluxConnection,
  State
};
//# sourceMappingURL=FluxConnection.js.map
