{
  "version": 3,
  "sources": ["src/Field.ts"],
  "sourcesContent": ["/* eslint-disable accessor-pairs,sort-keys */\nimport { type ElementPart, noChange, nothing, type PropertyPart } from 'lit';\nimport { directive, Directive, type DirectiveParameters, type PartInfo, PartType } from 'lit/directive.js';\nimport { getBinderNode } from './BinderNode.js';\nimport {\n  _fromString,\n  type AbstractModel,\n  ArrayModel,\n  BooleanModel,\n  hasFromString,\n  NumberModel,\n  ObjectModel,\n} from './Models.js';\nimport { StringModel } from './Models.js';\nimport type { ValueError } from './Validation.js';\nimport { _validity, defaultValidity } from './Validity.js';\n\nexport interface FieldBase<T> {\n  required: boolean;\n  invalid: boolean;\n  errorMessage: string;\n  value: T | undefined;\n}\n\n/**\n * Subset of the HTML constraint validation API with the `checkValidity()` method.\n */\nexport type FieldConstraintValidation = Readonly<{\n  validity: ValidityState;\n  checkValidity(): boolean;\n}>;\n\nexport type FieldElement<T = unknown> = FieldBase<T> & HTMLElement & Partial<FieldConstraintValidation>;\n\nconst props = ['required', 'invalid', 'errorMessage', 'value', 'validity', 'checkValidity'];\n\nexport function isFieldElement<T>(element: HTMLElement): element is FieldElement<T> {\n  return props.some((prop) => prop in element);\n}\n\ninterface FieldElementHolder<T> {\n  get element(): FieldElement<T>;\n\n  /**\n   * @param element - the new element value\n   * @deprecated will be read-only in future\n   */\n  set element(element: FieldElement<T>);\n}\n\ninterface Field<T> extends FieldBase<T> {\n  readonly model?: AbstractModel<T>;\n}\n\ninterface FieldState<T> extends Field<T>, FieldElementHolder<T> {\n  name: string;\n  validity: ValidityState;\n  strategy: FieldStrategy<T>;\n}\n\nexport type FieldStrategy<T = any> = Field<T> &\n  FieldConstraintValidation & {\n    removeEventListeners(): void;\n  };\n\nexport abstract class AbstractFieldStrategy<T = any, E extends FieldElement<T> = FieldElement<T>>\n  implements FieldStrategy<T>\n{\n  abstract required: boolean;\n\n  abstract invalid: boolean;\n\n  readonly model?: AbstractModel<T>;\n\n  #element: E;\n\n  /**\n   * @privateRemarks\n   * Fallback for missing .validity property API in Vaadin components.\n   */\n  #validityFallback: ValidityState = defaultValidity;\n\n  constructor(element: E, model?: AbstractModel<T>) {\n    this.#element = element;\n    this.model = model;\n  }\n\n  get element(): E {\n    return this.#element;\n  }\n\n  /**\n   * @param element - the new element value\n   * @deprecated will be read-only in future\n   */\n  set element(element: E) {\n    this.#element = element;\n  }\n\n  get value(): T | undefined {\n    return this.#element.value;\n  }\n\n  set value(value: T | undefined) {\n    if (this.model instanceof StringModel || this.model instanceof NumberModel) {\n      this.#element.value = value ?? ('' as T);\n      return;\n    }\n    this.#element.value = value;\n  }\n\n  set errorMessage(_: string) {}\n\n  get validity(): ValidityState {\n    return this.#element.validity ?? this.#validityFallback;\n  }\n\n  checkValidity(): boolean {\n    if (!this.#element.checkValidity) {\n      return true;\n    }\n\n    const valid = this.#element.checkValidity();\n    this.#validityFallback = {\n      ...defaultValidity,\n      valid,\n      ...(valid ? {} : this.#detectValidityError()),\n    };\n    return valid;\n  }\n\n  setAttribute(key: string, val: any): void {\n    if (val) {\n      this.#element.setAttribute(key, '');\n    } else {\n      this.#element.removeAttribute(key);\n    }\n  }\n\n  removeEventListeners(): void {}\n\n  #detectValidityError(): Readonly<Partial<ValidityState>> {\n    if (!('inputElement' in this.#element)) {\n      // Not a Vaadin component field\n      return { customError: true };\n    }\n\n    const inputElement = this.#element.inputElement as FieldElement<string>;\n\n    if (this.#element.value === '') {\n      if (inputElement.value === '') {\n        return { valueMissing: true };\n      }\n      // Some value is entered, but not meaningful to the\n      // web component \u2014 assume parse error.\n      return { badInput: true };\n    }\n    // Unknown constraint violation\n    return { customError: true };\n  }\n}\n\nexport class VaadinFieldStrategy<T = any, E extends FieldElement<T> = FieldElement<T>> extends AbstractFieldStrategy<\n  T,\n  E\n> {\n  #invalid = false;\n  readonly #boundOnValidated = this.#onValidated.bind(this);\n\n  constructor(element: E, model?: AbstractModel<T>) {\n    super(element, model);\n    element.addEventListener('validated', this.#boundOnValidated);\n  }\n\n  set required(value: boolean) {\n    this.element.required = value;\n  }\n\n  set invalid(value: boolean) {\n    this.#invalid = value;\n    this.element.invalid = value;\n  }\n\n  override set errorMessage(value: string) {\n    this.element.errorMessage = value;\n  }\n\n  override removeEventListeners(): void {\n    this.element.removeEventListener('validated', this.#boundOnValidated);\n  }\n\n  #onValidated(e: Event): void {\n    if (!(e instanceof CustomEvent) || typeof e.detail !== 'object') {\n      return;\n    }\n\n    // Override built-in changes of the `invalid` flag in Vaadin components\n    // to keep the `invalid` property state of the web component in sync.\n    const invalid = !(e.detail satisfies Partial<ValidityState> as Partial<ValidityState>).valid;\n    if (this.#invalid !== invalid) {\n      this.element.invalid = this.#invalid;\n    }\n  }\n\n  override checkValidity(): boolean {\n    // Ignore the `invalid` property of the Vaadin component to avoid\n    // reading the component's internal old validation state and validate\n    // the element based on the current state.\n    const isElementInvalid = this.element.invalid;\n    this.element.invalid = false;\n    const valid = super.checkValidity();\n    this.element.invalid = isElementInvalid;\n    return valid;\n  }\n}\n\nexport class GenericFieldStrategy<T = any, E extends FieldElement<T> = FieldElement<T>> extends AbstractFieldStrategy<\n  T,\n  E\n> {\n  set required(value: boolean) {\n    this.setAttribute('required', value);\n  }\n\n  set invalid(value: boolean) {\n    this.setAttribute('invalid', value);\n  }\n}\n\ntype CheckedFieldElement<T> = FieldElement<T> & {\n  checked: boolean;\n};\n\nexport class CheckedFieldStrategy<\n  T = any,\n  E extends CheckedFieldElement<T> = CheckedFieldElement<T>,\n> extends GenericFieldStrategy<T, E> {\n  override get value(): T | undefined {\n    if (this.model instanceof BooleanModel) {\n      return this.element.checked as T;\n    }\n\n    return this.element.checked ? this.element.value : undefined;\n  }\n\n  override set value(val: T | undefined) {\n    (this.element as { checked: boolean }).checked = /^(true|on)$/iu.test(String(val));\n  }\n}\n\nexport class CheckedGroupFieldStrategy<\n  T = any,\n  E extends FieldElement<T> = FieldElement<T>,\n> extends GenericFieldStrategy<T, E> {\n  override get value(): T | undefined {\n    return super.value;\n  }\n\n  override set value(val: T | undefined) {\n    super.value = val ?? ([] as T);\n  }\n}\n\ntype ComboBoxFieldElement<T> = FieldElement<T> & {\n  value: string;\n  selectedItem: T | null;\n};\n\nexport class ComboBoxFieldStrategy<\n  T,\n  E extends ComboBoxFieldElement<T> = ComboBoxFieldElement<T>,\n> extends VaadinFieldStrategy<T, E> {\n  override get value(): T | undefined {\n    if (this.model && (this.model instanceof ObjectModel || this.model instanceof ArrayModel)) {\n      const { selectedItem } = this.element;\n      return selectedItem ?? undefined;\n    }\n\n    return super.value;\n  }\n\n  override set value(val: T | undefined) {\n    if (this.model instanceof ObjectModel || this.model instanceof ArrayModel) {\n      this.element.selectedItem = val ?? null;\n    } else {\n      super.value = val;\n    }\n  }\n}\n\nexport class VaadinStringFieldStrategy extends VaadinFieldStrategy<string> {\n  override get value(): string | undefined {\n    return super.value;\n  }\n\n  override set value(val: string | undefined) {\n    // Some Vaadin components (e.g. vaadin-time-picker) do not support setting\n    // the value to `null` or `undefined`. Instead, set it to an empty string.\n    super.value = val ?? '';\n  }\n}\nfunction isEmptyObject(val: any): boolean {\n  return val && typeof val === 'object' && !Array.isArray(val) && Object.keys(val).length === 0;\n}\n\nexport class VaadinDateTimeFieldStrategy<\n  T = string,\n  E extends FieldElement<T> = FieldElement<T>,\n> extends VaadinFieldStrategy<T, E> {\n  override get value(): T | undefined {\n    return super.value;\n  }\n\n  override set value(val: T | undefined) {\n    const timestamp = Date.parse(val as string);\n\n    if (!val || isEmptyObject(val) || Number.isNaN(timestamp)) {\n      super.value = '' as T;\n      return;\n    }\n\n    const date = new Date(timestamp);\n    // Convert to ISO 8601 local combined date and time representation\n    const tzOffsetMs = 60 * 1000 * date.getTimezoneOffset();\n    super.value = new Date(timestamp - tzOffsetMs).toISOString().slice(0, 19) as T;\n  }\n}\n\ntype MultiSelectComboBoxFieldElement<T> = FieldElement<T> & {\n  value: never;\n  selectedItems: T;\n};\n\nexport class MultiSelectComboBoxFieldStrategy<\n  T,\n  E extends MultiSelectComboBoxFieldElement<T> = MultiSelectComboBoxFieldElement<T>,\n> extends VaadinFieldStrategy<T, E> {\n  override get value(): T {\n    return this.element.selectedItems;\n  }\n\n  override set value(val: any) {\n    this.element.selectedItems = val;\n  }\n}\n\ntype SelectedFieldElement<T> = FieldElement<T> & {\n  value: never;\n  selected: T;\n};\n\nexport class SelectedFieldStrategy<\n  T,\n  E extends SelectedFieldElement<T> = SelectedFieldElement<T>,\n> extends GenericFieldStrategy<T, E> {\n  override get value(): T {\n    return this.element.selected;\n  }\n\n  override set value(val: T) {\n    this.element.selected = val;\n  }\n}\n\ntype MaybeVaadinElementConstructor = {\n  readonly version?: string;\n};\n\nexport function getDefaultFieldStrategy<T>(elm: FieldElement<T>, model?: AbstractModel<T>): AbstractFieldStrategy<T> {\n  switch (elm.localName) {\n    case 'vaadin-checkbox':\n    case 'vaadin-radio-button':\n      return new CheckedFieldStrategy(elm as CheckedFieldElement<T>, model);\n    case 'vaadin-checkbox-group':\n      return new CheckedGroupFieldStrategy(elm, model);\n    case 'vaadin-combo-box':\n      return new ComboBoxFieldStrategy(elm as ComboBoxFieldElement<T>, model);\n    case 'vaadin-list-box':\n      return new SelectedFieldStrategy(elm as SelectedFieldElement<T>, model);\n    case 'vaadin-multi-select-combo-box':\n      return new MultiSelectComboBoxFieldStrategy(elm as MultiSelectComboBoxFieldElement<T>, model);\n    case 'vaadin-rich-text-editor':\n      return new GenericFieldStrategy(elm, model);\n    case 'vaadin-time-picker':\n      return new VaadinStringFieldStrategy(\n        elm as FieldElement<string>,\n        model as AbstractModel<string>,\n      ) as AbstractFieldStrategy<T>;\n    case 'vaadin-date-time-picker':\n      return new VaadinDateTimeFieldStrategy(elm, model) as AbstractFieldStrategy<T>;\n    default:\n      if (elm.localName === 'input' && /^(checkbox|radio)$/u.test((elm as unknown as HTMLInputElement).type)) {\n        return new CheckedFieldStrategy(elm as CheckedFieldElement<T>, model);\n      }\n      if ((elm.constructor as unknown as MaybeVaadinElementConstructor).version) {\n        return new VaadinFieldStrategy(elm, model);\n      }\n      return new GenericFieldStrategy(elm, model);\n  }\n}\n\nfunction convertFieldValue<T extends AbstractModel>(model: T, fieldValue: unknown) {\n  return typeof fieldValue === 'string' && hasFromString(model) ? model[_fromString](fieldValue) : fieldValue;\n}\n\n/**\n * Binds a form field component into a model.\n *\n * Example usage:\n *\n * ```\n * <vaadin-text-field ...=\"${field(model.name)}\">\n * </vaadin-text-field>\n * ```\n */\nexport const field = directive(\n  class extends Directive {\n    fieldState?: FieldState<any>;\n\n    constructor(partInfo: PartInfo) {\n      super(partInfo);\n      if (partInfo.type !== PartType.PROPERTY && partInfo.type !== PartType.ELEMENT) {\n        throw new Error('Use as \"<element {field(...)}\" or <element ...={field(...)}\"');\n      }\n    }\n\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    override render(_model: AbstractModel<any>, _effect?: (element: Element) => void) {\n      return nothing;\n    }\n\n    override update(part: ElementPart | PropertyPart, [model, effect]: DirectiveParameters<this>) {\n      const element = part.element as FieldElement & HTMLInputElement;\n\n      const binderNode = getBinderNode(model);\n\n      if (!this.fieldState) {\n        const fieldState = {\n          errorMessage: '',\n          name: '',\n          value: '',\n          required: false,\n          invalid: false,\n          model,\n          validity: defaultValidity,\n          element,\n          strategy: binderNode.binder.getFieldStrategy(element, model),\n        };\n\n        this.fieldState = fieldState;\n\n        const updateValueFromElement = () => {\n          fieldState.strategy.checkValidity();\n          // When bad input is detected, skip reading new value in binder state\n          if (!fieldState.strategy.validity.badInput) {\n            fieldState.value = fieldState.strategy.value;\n          }\n          fieldState.validity = fieldState.strategy.validity;\n          binderNode[_validity] = fieldState.validity;\n          binderNode.value = convertFieldValue(model, fieldState.value);\n          if (effect !== undefined) {\n            effect.call(element, element);\n          }\n        };\n\n        element.addEventListener('input', updateValueFromElement);\n\n        const changeBlurHandler = () => {\n          updateValueFromElement();\n          binderNode.visited = true;\n        };\n\n        element.addEventListener('blur', changeBlurHandler);\n        element.addEventListener('change', changeBlurHandler);\n      }\n\n      const { fieldState } = this;\n\n      if (fieldState.element !== element || fieldState.model !== model) {\n        fieldState.strategy = binderNode.binder.getFieldStrategy(element, model);\n      }\n\n      const { name } = binderNode;\n      if (name !== fieldState.name) {\n        fieldState.name = name;\n        element.setAttribute('name', name);\n      }\n\n      const { value } = binderNode;\n      const valueFromField = convertFieldValue(model, fieldState.value);\n      if (value !== valueFromField && !(Number.isNaN(value) && Number.isNaN(valueFromField))) {\n        const nonNanValue = Number.isNaN(value) ? '' : value;\n        fieldState.value = nonNanValue;\n        fieldState.strategy.value = nonNanValue;\n      }\n\n      const { required } = binderNode;\n      if (required !== fieldState.required) {\n        fieldState.required = required;\n        fieldState.strategy.required = required;\n      }\n\n      const firstError: ValueError<any> | undefined = binderNode.ownErrors[0];\n      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n      const errorMessage = firstError?.message || '';\n      if (errorMessage !== fieldState.errorMessage) {\n        fieldState.errorMessage = errorMessage;\n        fieldState.strategy.errorMessage = errorMessage;\n      }\n\n      const { invalid } = binderNode;\n      if (invalid !== fieldState.invalid) {\n        fieldState.invalid = invalid;\n        fieldState.strategy.invalid = invalid;\n      }\n\n      return noChange;\n    }\n  },\n);\n"],
  "mappings": "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",
  "names": ["fieldState"]
}
