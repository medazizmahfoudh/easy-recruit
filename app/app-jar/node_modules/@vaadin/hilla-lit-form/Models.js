import isNumeric from "validator/es/lib/isNumeric.js";
import { getBinderNode } from "./BinderNode.js";
import { IsNumber } from "./Validators.js";
const _createEmptyItemValue = Symbol("createEmptyItemValue");
const _parent = Symbol("parent");
const _key = Symbol("key");
const _fromString = Symbol("fromString");
const _validators = Symbol("validators");
const _meta = Symbol("meta");
const _getPropertyModel = Symbol("getPropertyModel");
const _enum = Symbol("enum");
const _items = Symbol("items");
const _optional = Symbol("optional");
function hasFromString(model) {
  return _fromString in model;
}
const modelDetachedParent = { $value$: void 0 };
function createDetachedModel(type) {
  return new type(modelDetachedParent, "$value$", false);
}
class AbstractModel {
  static createEmptyValue() {
    return void 0;
  }
  [_parent];
  [_validators];
  [_meta];
  [_optional];
  [_key];
  constructor(parent, key, optional, options) {
    this[_parent] = parent;
    this[_key] = key;
    this[_optional] = optional;
    this[_validators] = options?.validators ?? [];
    this[_meta] = options?.meta ?? {};
  }
  /**
   * @deprecated Use {@link BinderNode.value} with string conversion instead
   *
   * @example
   * ```ts
   * const result = String(binder.for(model).value);
   * ```
   */
  toString() {
    return String(this.valueOf());
  }
  /**
   * @deprecated Use {@link BinderNode.value} instead
   *
   * @example
   * ```ts
   * const result = binder.for(model).value;
   * ```
   */
  valueOf() {
    const { value } = getBinderNode(this);
    if (value === void 0) {
      throw new TypeError("Value is undefined");
    }
    return value;
  }
}
class PrimitiveModel extends AbstractModel {
}
class BooleanModel extends PrimitiveModel {
  static createEmptyValue = Boolean;
  [_fromString](str) {
    return ["true", "1", "yes"].includes(str.toLowerCase());
  }
}
class NumberModel extends PrimitiveModel {
  static createEmptyValue() {
    return NaN;
  }
  constructor(parent, key, optional, options) {
    const validators = [new IsNumber(optional), ...options?.validators ?? []];
    super(parent, key, optional, { ...options, validators });
  }
  [_fromString](str) {
    if (str === "")
      return void 0;
    return isNumeric(str) ? Number.parseFloat(str) : NaN;
  }
}
class StringModel extends PrimitiveModel {
  static createEmptyValue = String;
  [_fromString] = String;
}
function makeEnumEmptyValueCreator(type) {
  const { [_enum]: enumObject } = createDetachedModel(type);
  const defaultValue = Object.values(enumObject)[0];
  return () => defaultValue;
}
class EnumModel extends AbstractModel {
  [_fromString](value) {
    return value in this[_enum] ? value : void 0;
  }
}
function* getObjectModelOwnAndParentGetters(model) {
  for (let proto = Object.getPrototypeOf(model); proto !== ObjectModel.prototype; proto = Object.getPrototypeOf(proto)) {
    const descriptors = Object.getOwnPropertyDescriptors(proto);
    for (const [name, { get }] of Object.entries(descriptors)) {
      if (get) {
        yield [name, get];
      }
    }
  }
}
function makeObjectEmptyValueCreator(type) {
  const model = createDetachedModel(type);
  return () => {
    const obj = {};
    for (const [key, getter] of getObjectModelOwnAndParentGetters(model)) {
      const propertyModel = getter.call(model);
      obj[key] = propertyModel[_optional] ? void 0 : propertyModel.constructor.createEmptyValue();
    }
    return obj;
  };
}
class ObjectModel extends AbstractModel {
  static createEmptyValue = makeObjectEmptyValueCreator(ObjectModel);
  #properties = {};
  [_getPropertyModel](key, init) {
    if (!this.#properties[key]) {
      this.#properties[key] = init(this, key);
    }
    return this.#properties[key];
  }
}
class ArrayModel extends AbstractModel {
  static createEmptyValue() {
    return [];
  }
  [_createEmptyItemValue];
  // The `parent` parameter is AbstractModel here for purpose; for some reason, setting it to `ArrayModel<MItem>` or
  // `this` breaks the type inference in TS (v5.3.2).
  #createItem;
  #items = [];
  constructor(parent, key, optional, createItem, options) {
    super(parent, key, optional, options);
    this.#createItem = createItem;
    this[_createEmptyItemValue] = createItem(this, 0).constructor.createEmptyValue;
  }
  *[_items]() {
    const values = getBinderNode(this).value ?? [];
    if (values.length !== this.#items.length) {
      this.#items.length = values.length;
    }
    for (let i = 0; i < values.length; i++) {
      let item = this.#items[i];
      if (!item) {
        item = this.#createItem(this, i);
        this.#items[i] = item;
      }
      yield item;
    }
  }
  /**
   * Iterates over the current model and yields a binder node for every item
   * model.
   *
   * @deprecated Use the {@link m.items} function instead. For example, in React:
   * ```tsx
   * const {model, field} = useForm(GroupModel);
   * return Array.from(m.items(model.people), (personModel) =>
   *   <TextField label="Full name" {...field(personModel.fullName)} />
   * );
   * ```
   * In Lit:
   * ```ts
   * return html`${repeat(
   *   m.items(this.binder.model.people),
   *   (personModel) => html`<vaadin-text-field label="Full name" ${field(personModel.fullName)}></vaadin-text-field>`,
   * )}`;
   * ```
   */
  *[Symbol.iterator]() {
    for (const item of this[_items]()) {
      yield getBinderNode(item);
    }
  }
}
const m = {
  /**
   * Returns an iterator over item models in the array model.
   *
   * @param model - The array model to iterate over.
   * @returns An iterator over item models.
   */
  items(model) {
    return model[_items]();
  }
};
export {
  AbstractModel,
  ArrayModel,
  BooleanModel,
  EnumModel,
  NumberModel,
  ObjectModel,
  PrimitiveModel,
  StringModel,
  _createEmptyItemValue,
  _enum,
  _fromString,
  _getPropertyModel,
  _items,
  _key,
  _meta,
  _parent,
  _validators,
  createDetachedModel,
  getObjectModelOwnAndParentGetters,
  hasFromString,
  m,
  makeEnumEmptyValueCreator,
  makeObjectEmptyValueCreator,
  modelDetachedParent
};
//# sourceMappingURL=Models.js.map
