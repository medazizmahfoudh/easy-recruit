import {
  EndpointError,
  EndpointResponseError,
  EndpointValidationError,
  ForbiddenResponseError,
  UnauthorizedResponseError
} from "./chunk-FOJBNPP3.js";
import {
  ConnectionIndicator,
  ConnectionState
} from "./chunk-AVWG52NB.js";
import {
  __commonJS,
  __privateAdd,
  __privateGet,
  __privateMethod,
  __privateSet,
  __publicField,
  __toESM
} from "./chunk-547O27LD.js";

// node_modules/atmosphere.js/lib/atmosphere.js
var require_atmosphere = __commonJS({
  "node_modules/atmosphere.js/lib/atmosphere.js"(exports, module) {
    (function(root, factory) {
      if (typeof define === "function" && define.amd) {
        define(factory);
      } else if (typeof exports !== "undefined") {
        module.exports = factory();
      } else {
        root.atmosphere = factory();
      }
    })(exports, function() {
      "use strict";
      var atmosphere2 = {}, guid, offline = false, requests = [], callbacks = [], uuid = 0, hasOwn = Object.prototype.hasOwnProperty;
      atmosphere2 = {
        version: "3.1.3-javascript",
        onError: function(response) {
        },
        onClose: function(response) {
        },
        onOpen: function(response) {
        },
        onReopen: function(response) {
        },
        onMessage: function(response) {
        },
        onReconnect: function(request, response) {
        },
        onMessagePublished: function(response) {
        },
        onTransportFailure: function(errorMessage, _request) {
        },
        onLocalMessage: function(response) {
        },
        onFailureToReconnect: function(request, response) {
        },
        onClientTimeout: function(request) {
        },
        onOpenAfterResume: function(request) {
        },
        /**
         * Creates an object based on an atmosphere subscription that exposes functions defined by the Websocket interface.
         *
         * @class WebsocketApiAdapter
         * @param {Object} request the request object to build the underlying subscription
         * @constructor
         */
        WebsocketApiAdapter: function(request) {
          var _socket2, _adapter;
          request.onMessage = function(e) {
            _adapter.onmessage({ data: e.responseBody });
          };
          request.onMessagePublished = function(e) {
            _adapter.onmessage({ data: e.responseBody });
          };
          request.onOpen = function(e) {
            _adapter.onopen(e);
          };
          _adapter = {
            close: function() {
              _socket2.close();
            },
            send: function(data) {
              _socket2.push(data);
            },
            onmessage: function(e) {
            },
            onopen: function(e) {
            },
            onclose: function(e) {
            },
            onerror: function(e) {
            }
          };
          _socket2 = new atmosphere2.subscribe(request);
          return _adapter;
        },
        AtmosphereRequest: function(options) {
          var _request = {
            timeout: 3e5,
            method: "GET",
            headers: {},
            contentType: "",
            callback: null,
            url: "",
            data: "",
            suspend: true,
            maxRequest: -1,
            reconnect: true,
            maxStreamingLength: 1e7,
            lastIndex: 0,
            logLevel: "info",
            requestCount: 0,
            fallbackMethod: "GET",
            fallbackTransport: "streaming",
            transport: "long-polling",
            webSocketImpl: null,
            webSocketBinaryType: null,
            dispatchUrl: null,
            webSocketPathDelimiter: "@@",
            enableXDR: false,
            rewriteURL: false,
            attachHeadersAsQueryString: true,
            executeCallbackBeforeReconnect: false,
            readyState: 0,
            withCredentials: false,
            trackMessageLength: false,
            messageDelimiter: "|",
            connectTimeout: -1,
            reconnectInterval: 0,
            dropHeaders: true,
            uuid: 0,
            shared: false,
            readResponsesHeaders: false,
            maxReconnectOnClose: 5,
            enableProtocol: true,
            disableDisconnect: false,
            pollingInterval: 0,
            heartbeat: {
              client: null,
              server: null
            },
            ackInterval: 0,
            reconnectOnServerError: true,
            handleOnlineOffline: true,
            maxWebsocketErrorRetries: 1,
            curWebsocketErrorRetries: 0,
            unloadBackwardCompat: !navigator.sendBeacon,
            onError: function(response) {
            },
            onClose: function(response) {
            },
            onOpen: function(response) {
            },
            onMessage: function(response) {
            },
            onReopen: function(request, response) {
            },
            onReconnect: function(request, response) {
            },
            onMessagePublished: function(response) {
            },
            onTransportFailure: function(reason, request) {
            },
            onLocalMessage: function(request) {
            },
            onFailureToReconnect: function(request, response) {
            },
            onClientTimeout: function(request) {
            },
            onOpenAfterResume: function(request) {
            }
          };
          var _response = {
            status: 200,
            reasonPhrase: "OK",
            responseBody: "",
            messages: [],
            headers: [],
            state: "messageReceived",
            transport: "polling",
            error: null,
            request: null,
            partialMessage: "",
            errorHandled: false,
            closedByClientTimeout: false,
            ffTryingReconnect: false
          };
          var _websocket = null;
          var _sse = null;
          var _activeRequest = null;
          var _ieStream = null;
          var _jqxhr = null;
          var _subscribed = true;
          var _requestCount = 0;
          var _heartbeatInterval = 0;
          var _heartbeatPadding = "X";
          var _abortingConnection = false;
          var _localSocketF = null;
          var _storageService;
          var _localStorageService = null;
          var guid2 = atmosphere2.util.now();
          var _traceTimer;
          var _sharingKey;
          var _beforeUnloadState = false;
          _subscribe(options);
          function _init() {
            _subscribed = true;
            _abortingConnection = false;
            _requestCount = 0;
            _websocket = null;
            _sse = null;
            _activeRequest = null;
            _ieStream = null;
          }
          function _reinit() {
            _clearState();
            _init();
          }
          function _canLog(level) {
            if (level == "debug") {
              return _request.logLevel === "debug";
            } else if (level == "info") {
              return _request.logLevel === "info" || _request.logLevel === "debug";
            } else if (level == "warn") {
              return _request.logLevel === "warn" || _request.logLevel === "info" || _request.logLevel === "debug";
            } else if (level == "error") {
              return _request.logLevel === "error" || _request.logLevel === "warn" || _request.logLevel === "info" || _request.logLevel === "debug";
            } else {
              return false;
            }
          }
          function _debug(msg) {
            if (_canLog("debug")) {
              atmosphere2.util.debug(/* @__PURE__ */ new Date() + " Atmosphere: " + msg);
            }
          }
          function _verifyStreamingLength(ajaxRequest, rq) {
            if (_response.partialMessage === "" && rq.transport === "streaming" && ajaxRequest.responseText.length > rq.maxStreamingLength) {
              return true;
            }
            return false;
          }
          function _disconnect() {
            if (_request.enableProtocol && !_request.disableDisconnect && !_request.firstMessage) {
              var query = "X-Atmosphere-Transport=close&X-Atmosphere-tracking-id=" + _request.uuid;
              atmosphere2.util.each(_request.headers, function(name, value) {
                var h = atmosphere2.util.isFunction(value) ? value.call(this, _request, _request, _response) : value;
                if (h != null) {
                  query += "&" + encodeURIComponent(name) + "=" + encodeURIComponent(h);
                }
              });
              var url = _request.url.replace(/([?&])_=[^&]*/, query);
              url = url + (url === _request.url ? (/\?/.test(_request.url) ? "&" : "?") + query : "");
              var rq = {
                connected: false
              };
              var closeR = new atmosphere2.AtmosphereRequest(rq);
              closeR.connectTimeout = _request.connectTimeout;
              closeR.attachHeadersAsQueryString = false;
              closeR.dropHeaders = true;
              closeR.url = url;
              closeR.contentType = "text/plain";
              closeR.transport = "polling";
              closeR.method = "GET";
              closeR.data = "";
              closeR.heartbeat = null;
              if (_request.enableXDR) {
                closeR.enableXDR = _request.enableXDR;
              }
              _pushOnClose("", closeR);
            }
          }
          function _close() {
            _debug("Closing (AtmosphereRequest._close() called)");
            _abortingConnection = true;
            if (_request.reconnectId) {
              clearTimeout(_request.reconnectId);
              delete _request.reconnectId;
            }
            if (_request.heartbeatTimer) {
              clearTimeout(_request.heartbeatTimer);
            }
            _request.reconnect = false;
            _response.request = _request;
            _response.state = "unsubscribe";
            _response.responseBody = "";
            _response.status = 408;
            _response.partialMessage = "";
            _request.curWebsocketErrorRetries = 0;
            _invokeCallback();
            _disconnect();
            _clearState();
          }
          function _clearState() {
            _response.partialMessage = "";
            if (_request.id) {
              clearTimeout(_request.id);
            }
            if (_request.heartbeatTimer) {
              clearTimeout(_request.heartbeatTimer);
            }
            if (_request.reconnectId) {
              clearTimeout(_request.reconnectId);
              delete _request.reconnectId;
            }
            if (_ieStream != null) {
              _ieStream.close();
              _ieStream = null;
            }
            if (_jqxhr != null) {
              _jqxhr.abort();
              _jqxhr = null;
            }
            if (_activeRequest != null) {
              _activeRequest.abort();
              _activeRequest = null;
            }
            if (_websocket != null) {
              if (_websocket.canSendMessage) {
                _debug("invoking .close() on WebSocket object");
                _websocket.close();
              }
              _websocket = null;
            }
            if (_sse != null) {
              _sse.close();
              _sse = null;
            }
            _clearStorage();
          }
          function _clearStorage() {
            if (_storageService != null) {
              clearInterval(_traceTimer);
              document.cookie = _sharingKey + "=; expires=Thu, 01 Jan 1970 00:00:00 GMT; path=/";
              _storageService.signal("close", {
                reason: "",
                heir: !_abortingConnection ? guid2 : (_storageService.get("children") || [])[0]
              });
              _storageService.close();
            }
            if (_localStorageService != null) {
              _localStorageService.close();
            }
          }
          function _subscribe(options2) {
            _reinit();
            _request = atmosphere2.util.extend(_request, options2);
            _request.mrequest = _request.reconnect;
            if (!_request.reconnect) {
              _request.reconnect = true;
            }
          }
          function _supportWebsocket() {
            return _request.webSocketImpl != null || window.WebSocket || window.MozWebSocket;
          }
          function _supportSSE() {
            var url = atmosphere2.util.getAbsoluteURL(_request.url.toLowerCase());
            var parts = /^([\w\+\.\-]+:)(?:\/\/([^\/?#:]*)(?::(\d+))?)?/.exec(url);
            var crossOrigin = !!(parts && // protocol
            (parts[1] != window.location.protocol || // hostname
            parts[2] != window.location.hostname || // port
            (parts[3] || (parts[1] === "http:" ? 80 : 443)) != (window.location.port || (window.location.protocol === "http:" ? 80 : 443))));
            return window.EventSource && (!crossOrigin || !atmosphere2.util.browser.safari || atmosphere2.util.browser.vmajor >= 7);
          }
          function _execute() {
            if (_request.shared) {
              _localStorageService = _local(_request);
              if (_localStorageService != null) {
                if (_canLog("debug")) {
                  atmosphere2.util.debug("Storage service available. All communication will be local");
                }
                if (_localStorageService.open(_request)) {
                  return;
                }
              }
              if (_canLog("debug")) {
                atmosphere2.util.debug("No Storage service available.");
              }
              _localStorageService = null;
            }
            _request.firstMessage = uuid == 0 ? true : false;
            _request.isOpen = false;
            _request.ctime = atmosphere2.util.now();
            if (_request.uuid === 0) {
              _request.uuid = uuid;
            }
            _response.closedByClientTimeout = false;
            if (_request.transport !== "websocket" && _request.transport !== "sse") {
              _executeRequest(_request);
            } else if (_request.transport === "websocket") {
              if (!_supportWebsocket()) {
                _reconnectWithFallbackTransport("Websocket is not supported, using request.fallbackTransport (" + _request.fallbackTransport + ")");
              } else {
                _executeWebSocket(false);
              }
            } else if (_request.transport === "sse") {
              if (!_supportSSE()) {
                _reconnectWithFallbackTransport("Server Side Events(SSE) is not supported, using request.fallbackTransport (" + _request.fallbackTransport + ")");
              } else {
                _executeSSE(false);
              }
            }
          }
          function _local(request) {
            var trace, connector, orphan, name = "atmosphere-" + request.url, connectors = {
              storage: function() {
                function onstorage(event) {
                  if (event.key === name && event.newValue) {
                    listener(event.newValue);
                  }
                }
                if (!atmosphere2.util.storage) {
                  return;
                }
                var storage = window.localStorage, get = function(key) {
                  var item = storage.getItem(name + "-" + key);
                  return item === null ? [] : JSON.parse(item);
                }, set = function(key, value) {
                  storage.setItem(name + "-" + key, JSON.stringify(value));
                };
                return {
                  init: function() {
                    set("children", get("children").concat([guid2]));
                    atmosphere2.util.on(window, "storage", onstorage);
                    return get("opened");
                  },
                  signal: function(type, data) {
                    storage.setItem(name, JSON.stringify({
                      target: "p",
                      type,
                      data
                    }));
                  },
                  close: function() {
                    var children = get("children");
                    atmosphere2.util.off(window, "storage", onstorage);
                    if (children) {
                      if (removeFromArray(children, request.id)) {
                        set("children", children);
                      }
                    }
                  }
                };
              },
              windowref: function() {
                var win = window.open("", name.replace(/\W/g, ""));
                if (!win || win.closed || !win.callbacks) {
                  return;
                }
                return {
                  init: function() {
                    win.callbacks.push(listener);
                    win.children.push(guid2);
                    return win.opened;
                  },
                  signal: function(type, data) {
                    if (!win.closed && win.fire) {
                      win.fire(JSON.stringify({
                        target: "p",
                        type,
                        data
                      }));
                    }
                  },
                  close: function() {
                    if (!orphan) {
                      removeFromArray(win.callbacks, listener);
                      removeFromArray(win.children, guid2);
                    }
                  }
                };
              }
            };
            function removeFromArray(array, val) {
              var i, length = array.length;
              for (i = 0; i < length; i++) {
                if (array[i] === val) {
                  array.splice(i, 1);
                }
              }
              return length !== array.length;
            }
            function listener(string) {
              var command = JSON.parse(string), data = command.data;
              if (command.target === "c") {
                switch (command.type) {
                  case "open":
                    _open("opening", "local", _request);
                    break;
                  case "close":
                    if (!orphan) {
                      orphan = true;
                      if (data.reason === "aborted") {
                        _close();
                      } else {
                        if (data.heir === guid2) {
                          _execute();
                        } else {
                          setTimeout(function() {
                            _execute();
                          }, 100);
                        }
                      }
                    }
                    break;
                  case "message":
                    _prepareCallback(data, "messageReceived", 200, request.transport);
                    break;
                  case "localMessage":
                    _localMessage(data);
                    break;
                }
              }
            }
            function findTrace() {
              var matcher = new RegExp("(?:^|; )(" + encodeURIComponent(name) + ")=([^;]*)").exec(document.cookie);
              if (matcher) {
                return JSON.parse(decodeURIComponent(matcher[2]));
              }
            }
            trace = findTrace();
            if (!trace || atmosphere2.util.now() - trace.ts > 1e3) {
              return;
            }
            connector = connectors.storage() || connectors.windowref();
            if (!connector) {
              return;
            }
            return {
              open: function() {
                var parentOpened;
                _traceTimer = setInterval(function() {
                  var oldTrace = trace;
                  trace = findTrace();
                  if (!trace || oldTrace.ts === trace.ts) {
                    listener(JSON.stringify({
                      target: "c",
                      type: "close",
                      data: {
                        reason: "error",
                        heir: oldTrace.heir
                      }
                    }));
                  }
                }, 1e3);
                parentOpened = connector.init();
                if (parentOpened) {
                  setTimeout(function() {
                    _open("opening", "local", request);
                  }, 50);
                }
                return parentOpened;
              },
              send: function(event) {
                connector.signal("send", event);
              },
              localSend: function(event) {
                connector.signal("localSend", JSON.stringify({
                  id: guid2,
                  event
                }));
              },
              close: function() {
                if (!_abortingConnection) {
                  clearInterval(_traceTimer);
                  connector.signal("close");
                  connector.close();
                }
              }
            };
          }
          function share() {
            var storageService, name = "atmosphere-" + _request.url, servers = {
              // Powered by the storage event and the localStorage
              // http://www.w3.org/TR/webstorage/#event-storage
              storage: function() {
                function onstorage(event) {
                  if (event.key === name && event.newValue) {
                    listener(event.newValue);
                  }
                }
                if (!atmosphere2.util.storage) {
                  return;
                }
                var storage = window.localStorage;
                return {
                  init: function() {
                    atmosphere2.util.on(window, "storage", onstorage);
                  },
                  signal: function(type, data) {
                    storage.setItem(name, JSON.stringify({
                      target: "c",
                      type,
                      data
                    }));
                  },
                  get: function(key) {
                    return JSON.parse(storage.getItem(name + "-" + key));
                  },
                  set: function(key, value) {
                    storage.setItem(name + "-" + key, JSON.stringify(value));
                  },
                  close: function() {
                    atmosphere2.util.off(window, "storage", onstorage);
                    storage.removeItem(name);
                    storage.removeItem(name + "-opened");
                    storage.removeItem(name + "-children");
                  }
                };
              },
              // Powered by the window.open method
              // https://developer.mozilla.org/en/DOM/window.open
              windowref: function() {
                var neim = name.replace(/\W/g, ""), container = document.getElementById(neim), win;
                if (!container) {
                  container = document.createElement("div");
                  container.id = neim;
                  container.style.display = "none";
                  container.innerHTML = '<iframe name="' + neim + '"></iframe>';
                  document.body.appendChild(container);
                }
                win = container.firstChild.contentWindow;
                return {
                  init: function() {
                    win.callbacks = [listener];
                    win.fire = function(string) {
                      var i;
                      for (i = 0; i < win.callbacks.length; i++) {
                        win.callbacks[i](string);
                      }
                    };
                  },
                  signal: function(type, data) {
                    if (!win.closed && win.fire) {
                      win.fire(JSON.stringify({
                        target: "c",
                        type,
                        data
                      }));
                    }
                  },
                  get: function(key) {
                    return !win.closed ? win[key] : null;
                  },
                  set: function(key, value) {
                    if (!win.closed) {
                      win[key] = value;
                    }
                  },
                  close: function() {
                  }
                };
              }
            };
            function listener(string) {
              var command = JSON.parse(string), data = command.data;
              if (command.target === "p") {
                switch (command.type) {
                  case "send":
                    _push(data);
                    break;
                  case "localSend":
                    _localMessage(data);
                    break;
                  case "close":
                    _close();
                    break;
                }
              }
            }
            _localSocketF = function propagateMessageEvent(context) {
              storageService.signal("message", context);
            };
            function leaveTrace() {
              document.cookie = _sharingKey + "=" + // Opera's JSON implementation ignores a number whose a last digit of 0 strangely
              // but has no problem with a number whose a last digit of 9 + 1
              encodeURIComponent(JSON.stringify({
                ts: atmosphere2.util.now() + 1,
                heir: (storageService.get("children") || [])[0]
              })) + "; path=/";
            }
            storageService = servers.storage() || servers.windowref();
            storageService.init();
            if (_canLog("debug")) {
              atmosphere2.util.debug("Installed StorageService " + storageService);
            }
            storageService.set("children", []);
            if (storageService.get("opened") != null && !storageService.get("opened")) {
              storageService.set("opened", false);
            }
            _sharingKey = encodeURIComponent(name);
            leaveTrace();
            _traceTimer = setInterval(leaveTrace, 1e3);
            _storageService = storageService;
          }
          function _open(state, transport, request) {
            if (_request.shared && transport !== "local") {
              share();
            }
            if (_storageService != null) {
              _storageService.set("opened", true);
            }
            request.close = function() {
              _close();
            };
            if (_requestCount > 0 && state === "re-connecting") {
              request.isReopen = true;
              _tryingToReconnect(_response);
            } else if (!_response.error) {
              _response.request = request;
              var prevState = _response.state;
              _response.state = state;
              var prevTransport = _response.transport;
              _response.transport = transport;
              var _body = _response.responseBody;
              _invokeCallback();
              _response.responseBody = _body;
              _response.state = prevState;
              _response.transport = prevTransport;
            }
          }
          function _jsonp(request) {
            request.transport = "jsonp";
            var rq = _request, script;
            if (request != null && typeof request !== "undefined") {
              rq = request;
            }
            _jqxhr = {
              open: function() {
                var callback = "atmosphere" + ++guid2;
                function _reconnectOnFailure() {
                  rq.lastIndex = 0;
                  if (rq.openId) {
                    clearTimeout(rq.openId);
                  }
                  if (rq.heartbeatTimer) {
                    clearTimeout(rq.heartbeatTimer);
                  }
                  if (rq.reconnect && _requestCount++ < rq.maxReconnectOnClose) {
                    _open("re-connecting", rq.transport, rq);
                    _reconnect(_jqxhr, rq, request.reconnectInterval);
                    rq.openId = setTimeout(function() {
                      _triggerOpen(rq);
                    }, rq.reconnectInterval + 1e3);
                  } else {
                    _onError(0, "maxReconnectOnClose reached");
                  }
                }
                function poll() {
                  var url = rq.url;
                  if (rq.dispatchUrl != null) {
                    url += rq.dispatchUrl;
                  }
                  var data = rq.data;
                  if (rq.attachHeadersAsQueryString) {
                    url = _attachHeaders(rq);
                    if (data !== "") {
                      url += "&X-Atmosphere-Post-Body=" + encodeURIComponent(data);
                    }
                    data = "";
                  }
                  var head = document.head || document.getElementsByTagName("head")[0] || document.documentElement;
                  script = document.createElement("script");
                  script.src = url + "&jsonpTransport=" + callback;
                  script.clean = function() {
                    script.clean = script.onerror = script.onload = script.onreadystatechange = null;
                    if (script.parentNode) {
                      script.parentNode.removeChild(script);
                    }
                    if (++request.scriptCount === 2) {
                      request.scriptCount = 1;
                      _reconnectOnFailure();
                    }
                  };
                  script.onload = script.onreadystatechange = function() {
                    _debug("jsonp.onload");
                    if (!script.readyState || /loaded|complete/.test(script.readyState)) {
                      script.clean();
                    }
                  };
                  script.onerror = function() {
                    _debug("jsonp.onerror");
                    request.scriptCount = 1;
                    script.clean();
                  };
                  head.insertBefore(script, head.firstChild);
                }
                window[callback] = function(msg) {
                  _debug("jsonp.window");
                  request.scriptCount = 0;
                  if (rq.reconnect && rq.maxRequest === -1 || rq.requestCount++ < rq.maxRequest) {
                    if (!rq.executeCallbackBeforeReconnect) {
                      _reconnect(_jqxhr, rq, rq.pollingInterval);
                    }
                    if (msg != null && typeof msg !== "string") {
                      try {
                        msg = msg.message;
                      } catch (err) {
                      }
                    }
                    var skipCallbackInvocation = _trackMessageSize(msg, rq, _response);
                    if (!skipCallbackInvocation) {
                      _prepareCallback(_response.responseBody, "messageReceived", 200, rq.transport);
                    }
                    if (rq.executeCallbackBeforeReconnect) {
                      _reconnect(_jqxhr, rq, rq.pollingInterval);
                    }
                    _timeout(rq);
                  } else {
                    atmosphere2.util.log(_request.logLevel, ["JSONP reconnect maximum try reached " + _request.requestCount]);
                    _onError(0, "maxRequest reached");
                  }
                };
                setTimeout(function() {
                  poll();
                }, 50);
              },
              abort: function() {
                if (script && script.clean) {
                  script.clean();
                }
              }
            };
            _jqxhr.open();
          }
          function _getWebSocket(location) {
            if (_request.webSocketImpl != null) {
              return _request.webSocketImpl;
            } else {
              if (window.WebSocket) {
                return new WebSocket(location);
              } else {
                return new MozWebSocket(location);
              }
            }
          }
          function _buildWebSocketUrl() {
            return _attachHeaders(_request, atmosphere2.util.getAbsoluteURL(_request.webSocketUrl || _request.url)).replace(/^http/, "ws");
          }
          function _buildSSEUrl() {
            var url = _attachHeaders(_request);
            return url;
          }
          function _executeSSE(sseOpened) {
            _response.transport = "sse";
            var location = _buildSSEUrl();
            if (_canLog("debug")) {
              atmosphere2.util.debug("Invoking executeSSE");
              atmosphere2.util.debug("Using URL: " + location);
            }
            if (sseOpened && !_request.reconnect) {
              if (_sse != null) {
                _clearState();
              }
              return;
            }
            try {
              _sse = new EventSource(location, {
                withCredentials: _request.withCredentials
              });
            } catch (e) {
              _onError(0, e);
              _reconnectWithFallbackTransport("SSE failed. Downgrading to fallback transport and resending");
              return;
            }
            if (_request.connectTimeout > 0) {
              _request.id = setTimeout(function() {
                if (!sseOpened) {
                  _clearState();
                }
              }, _request.connectTimeout);
            }
            _sse.onopen = function() {
              _debug("sse.onopen");
              _timeout(_request);
              if (_canLog("debug")) {
                atmosphere2.util.debug("SSE successfully opened");
              }
              if (!_request.enableProtocol) {
                if (!sseOpened) {
                  _open("opening", "sse", _request);
                } else {
                  _open("re-opening", "sse", _request);
                }
              } else if (_request.isReopen) {
                _request.isReopen = false;
                _open("re-opening", _request.transport, _request);
              }
              sseOpened = true;
              if (_request.method === "POST") {
                _response.state = "messageReceived";
                _push(_request.data);
              }
            };
            _sse.onmessage = function(message) {
              _debug("sse.onmessage");
              _timeout(_request);
              if (!_request.enableXDR && window.location.host && message.origin && message.origin !== window.location.protocol + "//" + window.location.host) {
                atmosphere2.util.log(_request.logLevel, ["Origin was not " + window.location.protocol + "//" + window.location.host]);
                return;
              }
              _response.state = "messageReceived";
              _response.status = 200;
              message = message.data;
              var skipCallbackInvocation = _trackMessageSize(message, _request, _response);
              if (!skipCallbackInvocation) {
                _invokeCallback();
                _response.responseBody = "";
                _response.messages = [];
              }
            };
            _sse.onerror = function() {
              _debug("sse.onerror");
              clearTimeout(_request.id);
              if (_request.heartbeatTimer) {
                clearTimeout(_request.heartbeatTimer);
              }
              if (_response.closedByClientTimeout) {
                return;
              }
              _invokeClose(sseOpened);
              _clearState();
              if (_abortingConnection) {
                atmosphere2.util.log(_request.logLevel, ["SSE closed normally"]);
              } else if (!sseOpened) {
                _reconnectWithFallbackTransport("SSE failed. Downgrading to fallback transport and resending");
              } else if (_request.reconnect && _response.transport === "sse") {
                if (_requestCount++ < _request.maxReconnectOnClose) {
                  _open("re-connecting", _request.transport, _request);
                  if (_request.reconnectInterval > 0) {
                    var handleOnlineOffline = _request.handleOnlineOffline;
                    _request.handleOnlineOffline = false;
                    _request.reconnectId = setTimeout(function() {
                      _request.handleOnlineOffline = handleOnlineOffline;
                      _executeSSE(true);
                    }, _request.reconnectInterval);
                  } else {
                    _executeSSE(true);
                  }
                  _response.responseBody = "";
                  _response.messages = [];
                } else {
                  atmosphere2.util.log(_request.logLevel, ["SSE reconnect maximum try reached " + _requestCount]);
                  _onError(0, "maxReconnectOnClose reached");
                }
              }
            };
          }
          function _executeWebSocket(webSocketOpened) {
            _response.transport = "websocket";
            var location = _buildWebSocketUrl(_request.url);
            if (_canLog("debug")) {
              atmosphere2.util.debug("Invoking executeWebSocket, using URL: " + location);
            }
            if (webSocketOpened && !_request.reconnect) {
              if (_websocket != null) {
                _clearState();
              }
              return;
            }
            _websocket = _getWebSocket(location);
            if (_request.webSocketBinaryType != null) {
              _websocket.binaryType = _request.webSocketBinaryType;
            }
            if (_request.connectTimeout > 0) {
              _request.id = setTimeout(function() {
                if (!webSocketOpened) {
                  var _message = {
                    code: 1002,
                    reason: "Connection timeout after " + _request.connectTimeout + "ms.",
                    wasClean: false
                  };
                  var socket = _websocket;
                  try {
                    _clearState();
                  } catch (e) {
                  }
                  socket.onclose(_message);
                }
              }, _request.connectTimeout);
            }
            _websocket.onopen = function() {
              if (_websocket == null) {
                this.close();
                if (_request.transport == "websocket")
                  _close();
                return;
              }
              _debug("websocket.onopen");
              if (!_request.enableProtocol || _request.connectTimeout <= 0)
                _timeout(_request);
              offline = false;
              if (_canLog("debug")) {
                atmosphere2.util.debug("Websocket successfully opened");
              }
              var reopening = webSocketOpened;
              _websocket.canSendMessage = true;
              if (!_request.enableProtocol) {
                webSocketOpened = true;
                if (reopening) {
                  _open("re-opening", "websocket", _request);
                } else {
                  _open("opening", "websocket", _request);
                }
              }
              if (_request.method === "POST") {
                _response.state = "messageReceived";
                _websocket.send(_request.data);
              }
            };
            _websocket.onmessage = function(message) {
              if (_websocket == null) {
                this.close();
                if (_request.transport == "websocket")
                  _close();
                return;
              }
              _debug("websocket.onmessage");
              _timeout(_request);
              if (_request.enableProtocol) {
                webSocketOpened = true;
              }
              _response.state = "messageReceived";
              _response.status = 200;
              message = message.data;
              var isString = typeof message === "string";
              if (isString) {
                var skipCallbackInvocation = _trackMessageSize(message, _request, _response);
                if (!skipCallbackInvocation) {
                  _invokeCallback();
                  _response.responseBody = "";
                  _response.messages = [];
                }
              } else {
                message = _handleProtocol(_request, message);
                if (message === "")
                  return;
                _response.responseBody = message;
                _invokeCallback();
                _response.responseBody = null;
              }
            };
            _websocket.onerror = function() {
              _debug("websocket.onerror");
              clearTimeout(_request.id);
              if (_request.heartbeatTimer) {
                clearTimeout(_request.heartbeatTimer);
              }
              _response.error = true;
            };
            _websocket.onclose = function(message) {
              _debug("websocket.onclose");
              if (_response.transport !== "websocket")
                return;
              clearTimeout(_request.id);
              if (_response.state === "closed")
                return;
              var reason = message.reason;
              if (reason === "") {
                switch (message.code) {
                  case 1e3:
                    reason = "Normal closure; the connection successfully completed whatever purpose for which it was created.";
                    break;
                  case 1001:
                    reason = "The endpoint is going away, either because of a server failure or because the browser is navigating away from the page that opened the connection.";
                    break;
                  case 1002:
                    reason = "The endpoint is terminating the connection due to a protocol error.";
                    break;
                  case 1003:
                    reason = "The connection is being terminated because the endpoint received data of a type it cannot accept (for example, a text-only endpoint received binary data).";
                    break;
                  case 1004:
                    reason = "The endpoint is terminating the connection because a data frame was received that is too large.";
                    break;
                  case 1005:
                    reason = "Unknown: no status code was provided even though one was expected.";
                    break;
                  case 1006:
                    reason = "Connection was closed abnormally (that is, with no close frame being sent).";
                    break;
                }
              }
              if (_canLog("warn")) {
                atmosphere2.util.warn("Websocket closed, reason: " + reason + " - wasClean: " + message.wasClean);
              }
              if (_response.closedByClientTimeout || _request.handleOnlineOffline && offline) {
                if (_request.reconnectId) {
                  clearTimeout(_request.reconnectId);
                  delete _request.reconnectId;
                }
                return;
              }
              _invokeClose(webSocketOpened);
              _response.state = "closed";
              if (_abortingConnection) {
                atmosphere2.util.log(_request.logLevel, ["Websocket closed normally"]);
              } else if (_response.error && _request.curWebsocketErrorRetries < _request.maxWebsocketErrorRetries && _requestCount + 1 < _request.maxReconnectOnClose) {
                _response.error = false;
                _request.curWebsocketErrorRetries++;
                _reconnectWebSocket();
              } else if ((_response.error || !webSocketOpened || _request.maxWebsocketErrorRetries === 0) && _request.fallbackTransport !== "websocket") {
                _response.error = false;
                _reconnectWithFallbackTransport("Websocket failed on first connection attempt. Downgrading to " + _request.fallbackTransport + " and resending");
              } else if (_request.reconnect) {
                _reconnectWebSocket();
              }
            };
            var ua = navigator.userAgent.toLowerCase();
            var isAndroid = ua.indexOf("android") > -1;
            if (isAndroid && _websocket.url === void 0) {
              _websocket.onclose({
                reason: "Android 4.1 does not support websockets.",
                wasClean: false
              });
            }
          }
          function _handleProtocol(request, message) {
            var nMessage = message;
            if (request.transport === "polling") return nMessage;
            if (request.enableProtocol && request.firstMessage && atmosphere2.util.trim(message).length !== 0) {
              var pos = request.trackMessageLength ? 1 : 0;
              var messages = message.split(request.messageDelimiter);
              if (messages.length <= pos + 1) {
                return nMessage;
              }
              request.firstMessage = false;
              request.uuid = atmosphere2.util.trim(messages[pos]);
              if (messages.length <= pos + 2) {
                atmosphere2.util.log("error", ["Protocol data not sent by the server. If you enable protocol on client side, be sure to install JavascriptProtocol interceptor on server side.Also note that atmosphere-runtime 2.2+ should be used."]);
              }
              _heartbeatInterval = parseInt(atmosphere2.util.trim(messages[pos + 1]), 10);
              _heartbeatPadding = messages[pos + 2];
              if (request.transport !== "long-polling") {
                _triggerOpen(request);
              }
              uuid = request.uuid;
              nMessage = "";
              pos = request.trackMessageLength ? 4 : 3;
              if (messages.length > pos + 1) {
                for (var i = pos; i < messages.length; i++) {
                  nMessage += messages[i];
                  if (i + 1 !== messages.length) {
                    nMessage += request.messageDelimiter;
                  }
                }
              }
              if (request.ackInterval !== 0) {
                setTimeout(function() {
                  _push("...ACK...");
                }, request.ackInterval);
              }
            } else if (request.enableProtocol && request.firstMessage && atmosphere2.util.browser.msie && +atmosphere2.util.browser.version.split(".")[0] < 10) {
              atmosphere2.util.log(_request.logLevel, ["Receiving unexpected data from IE"]);
            } else {
              _triggerOpen(request);
            }
            return nMessage;
          }
          function _timeout(_request2) {
            clearTimeout(_request2.id);
            if (_request2.timeout > 0 && _request2.transport !== "polling") {
              _request2.id = setTimeout(function() {
                _onClientTimeout(_request2);
                _disconnect();
                _clearState();
              }, _request2.timeout);
            }
          }
          function _onClientTimeout(_request2) {
            _response.closedByClientTimeout = true;
            _response.state = "closedByClient";
            _response.responseBody = "";
            _response.status = 408;
            _response.messages = [];
            _invokeCallback();
          }
          function _onError(code, reason) {
            _clearState();
            clearTimeout(_request.id);
            _response.state = "error";
            _response.reasonPhrase = reason;
            _response.responseBody = "";
            _response.status = code;
            _response.messages = [];
            _invokeCallback();
          }
          function _trackMessageSize(message, request, response) {
            message = _handleProtocol(request, message);
            if (message.length === 0)
              return true;
            response.responseBody = message;
            if (request.trackMessageLength) {
              message = response.partialMessage + message;
              var messages = [];
              var messageStart = message.indexOf(request.messageDelimiter);
              if (messageStart != -1) {
                while (messageStart !== -1) {
                  var str = message.substring(0, messageStart);
                  var messageLength = +str;
                  if (isNaN(messageLength)) {
                    response.partialMessage = "";
                    throw new Error('message length "' + str + '" is not a number');
                  }
                  messageStart += request.messageDelimiter.length;
                  if (messageStart + messageLength > message.length) {
                    messageStart = -1;
                  } else {
                    messages.push(message.substring(messageStart, messageStart + messageLength));
                    message = message.substring(messageStart + messageLength, message.length);
                    messageStart = message.indexOf(request.messageDelimiter);
                  }
                }
                response.partialMessage = message;
                if (messages.length !== 0) {
                  response.responseBody = messages.join(request.messageDelimiter);
                  response.messages = messages;
                  return false;
                } else {
                  response.responseBody = "";
                  response.messages = [];
                  return true;
                }
              }
            }
            response.responseBody = message;
            response.messages = [message];
            return false;
          }
          function _reconnectWebSocket() {
            _clearState();
            if (_requestCount++ < _request.maxReconnectOnClose) {
              _open("re-connecting", _request.transport, _request);
              if (_request.reconnectInterval > 0) {
                var handleOnlineOffline = _request.handleOnlineOffline;
                _request.handleOnlineOffline = false;
                _request.reconnectId = setTimeout(function() {
                  _request.handleOnlineOffline = handleOnlineOffline;
                  _response.responseBody = "";
                  _response.messages = [];
                  _executeWebSocket(true);
                }, _request.reconnectInterval);
              } else {
                _response.responseBody = "";
                _response.messages = [];
                _executeWebSocket(true);
              }
            } else {
              atmosphere2.util.log(_request.logLevel, ["Websocket reconnect maximum try reached " + _requestCount]);
              _onError(0, "maxReconnectOnClose reached");
            }
          }
          function _reconnectWithFallbackTransport(errorMessage) {
            atmosphere2.util.log(_request.logLevel, [errorMessage]);
            _clearState();
            if (typeof _request.onTransportFailure !== "undefined") {
              _request.onTransportFailure(errorMessage, _request);
            } else if (typeof atmosphere2.util.onTransportFailure !== "undefined") {
              atmosphere2.util.onTransportFailure(errorMessage, _request);
            }
            if (_request.reconnect && _request.transport !== "none" || _request.transport == null) {
              _request.transport = _request.fallbackTransport;
              _request.method = _request.fallbackMethod;
              _response.transport = _request.fallbackTransport;
              _response.state = "";
              _request.fallbackTransport = "none";
              if (_request.reconnectInterval > 0) {
                var handleOnlineOffline = _request.handleOnlineOffline;
                _request.handleOnlineOffline = false;
                _request.reconnectId = setTimeout(function() {
                  _request.handleOnlineOffline = handleOnlineOffline;
                  _execute();
                }, _request.reconnectInterval);
              } else {
                _execute();
              }
            } else {
              _onError(500, "Unable to reconnect with fallback transport");
            }
          }
          function _attachHeaders(request, url) {
            var rq = _request;
            if (request != null && typeof request !== "undefined") {
              rq = request;
            }
            if (url == null) {
              url = rq.url;
            }
            if (!rq.attachHeadersAsQueryString)
              return url;
            if (url.indexOf("X-Atmosphere-Framework") !== -1) {
              return url;
            }
            url += url.indexOf("?") !== -1 ? "&" : "?";
            url += "X-Atmosphere-tracking-id=" + rq.uuid;
            url += "&X-Atmosphere-Framework=" + atmosphere2.version;
            url += "&X-Atmosphere-Transport=" + rq.transport;
            if (rq.trackMessageLength) {
              url += "&X-Atmosphere-TrackMessageSize=true";
            }
            if (rq.heartbeat !== null && rq.heartbeat.server !== null) {
              url += "&X-Heartbeat-Server=" + rq.heartbeat.server;
            }
            if (rq.contentType !== "") {
              url += "&Content-Type=" + (rq.transport === "websocket" ? rq.contentType : encodeURIComponent(rq.contentType));
            }
            if (rq.enableProtocol) {
              url += "&X-atmo-protocol=true";
            }
            atmosphere2.util.each(rq.headers, function(name, value) {
              var h = atmosphere2.util.isFunction(value) ? value.call(this, rq, request, _response) : value;
              if (h != null) {
                url += "&" + encodeURIComponent(name) + "=" + encodeURIComponent(h);
              }
            });
            return url;
          }
          function _triggerOpen(rq) {
            if (!rq.isOpen) {
              rq.isOpen = true;
              _open("opening", rq.transport, rq);
            } else if (rq.isReopen) {
              rq.isReopen = false;
              _open("re-opening", rq.transport, rq);
            } else if (_response.state === "messageReceived" && (rq.transport === "jsonp" || rq.transport === "long-polling")) {
              _openAfterResume(_response);
            } else {
              return;
            }
            _startHeartbeat(rq);
          }
          function _startHeartbeat(rq) {
            if (rq.heartbeatTimer != null) {
              clearTimeout(rq.heartbeatTimer);
            }
            if (!isNaN(_heartbeatInterval) && _heartbeatInterval > 0) {
              var _pushHeartbeat = function() {
                if (_canLog("debug")) {
                  atmosphere2.util.debug("Sending heartbeat");
                }
                _push(_heartbeatPadding);
                rq.heartbeatTimer = setTimeout(_pushHeartbeat, _heartbeatInterval);
              };
              rq.heartbeatTimer = setTimeout(_pushHeartbeat, _heartbeatInterval);
            }
          }
          function _executeRequest(request) {
            var rq = _request;
            if (request != null || typeof request !== "undefined") {
              rq = request;
            }
            rq.lastIndex = 0;
            rq.readyState = 0;
            if (rq.transport === "jsonp" || rq.enableXDR && atmosphere2.util.checkCORSSupport()) {
              _jsonp(rq);
              return;
            }
            if (atmosphere2.util.browser.msie && +atmosphere2.util.browser.version.split(".")[0] < 10) {
              if (rq.transport === "streaming") {
                if (rq.enableXDR && window.XDomainRequest) {
                  _ieXDR(rq);
                } else {
                  _ieStreaming(rq);
                }
                return;
              }
              if (rq.enableXDR && window.XDomainRequest) {
                _ieXDR(rq);
                return;
              }
            }
            var reconnectFExec = function(force) {
              rq.lastIndex = 0;
              _requestCount++;
              if (force || rq.reconnect && _requestCount <= rq.maxReconnectOnClose) {
                var delay = force ? 0 : request.reconnectInterval;
                _response.ffTryingReconnect = true;
                _open("re-connecting", request.transport, request);
                _reconnect(ajaxRequest, rq, delay);
              } else {
                _onError(0, "maxReconnectOnClose reached");
              }
            };
            var reconnectF = function(force) {
              if (atmosphere2._beforeUnloadState) {
                atmosphere2.util.debug(/* @__PURE__ */ new Date() + " Atmosphere: reconnectF: execution delayed due to _beforeUnloadState flag");
                setTimeout(function() {
                  reconnectFExec(force);
                }, 5e3);
              } else {
                reconnectFExec(force);
              }
            };
            var disconnected = function() {
              _response.errorHandled = true;
              _clearState();
              reconnectF(false);
            };
            if (rq.force || rq.reconnect && (rq.maxRequest === -1 || rq.requestCount++ < rq.maxRequest)) {
              rq.force = false;
              var ajaxRequest = atmosphere2.util.xhr();
              ajaxRequest.hasData = false;
              _doRequest(ajaxRequest, rq, true);
              if (rq.suspend) {
                _activeRequest = ajaxRequest;
              }
              if (rq.transport !== "polling") {
                _response.transport = rq.transport;
                ajaxRequest.onabort = function() {
                  _debug("ajaxrequest.onabort");
                  _invokeClose(true);
                };
                ajaxRequest.onerror = function() {
                  _debug("ajaxrequest.onerror");
                  _response.error = true;
                  _response.ffTryingReconnect = true;
                  try {
                    _response.status = XMLHttpRequest.status;
                  } catch (e) {
                    _response.status = 500;
                  }
                  if (!_response.status) {
                    _response.status = 500;
                  }
                  if (!_response.errorHandled) {
                    _clearState();
                    reconnectF(false);
                  }
                };
              }
              ajaxRequest.onreadystatechange = function() {
                _debug("ajaxRequest.onreadystatechange, new state: " + ajaxRequest.readyState);
                if (_abortingConnection) {
                  _debug("onreadystatechange has been ignored due to _abortingConnection flag");
                  return;
                }
                _response.error = false;
                var skipCallbackInvocation = false;
                var update = false;
                if (rq.transport === "streaming" && rq.readyState > 2 && ajaxRequest.readyState === 4) {
                  _clearState();
                  reconnectF(false);
                  return;
                }
                rq.readyState = ajaxRequest.readyState;
                if (rq.transport === "streaming" && ajaxRequest.readyState >= 3) {
                  update = true;
                } else if (rq.transport === "long-polling" && ajaxRequest.readyState === 4) {
                  update = true;
                }
                _timeout(_request);
                if (rq.transport !== "polling") {
                  var status = 200;
                  if (ajaxRequest.readyState === 4) {
                    status = ajaxRequest.status > 1e3 ? 0 : ajaxRequest.status;
                  }
                  if (!rq.reconnectOnServerError && (status >= 300 && status < 600)) {
                    _onError(status, ajaxRequest.statusText);
                    return;
                  }
                  if (status >= 300 || status === 0) {
                    if (!rq.isOpen && _canLog("warn")) {
                      atmosphere2.util.warn(rq.transport + " connection failed with status: " + status + " " + (ajaxRequest.statusText || "Unable to connect"));
                    }
                    disconnected();
                    return;
                  }
                  if ((!rq.enableProtocol || !request.firstMessage) && (ajaxRequest.readyState === 2 || ajaxRequest.readyState > 2 && !rq.isOpen)) {
                    if (atmosphere2.util.browser.mozilla && _response.ffTryingReconnect) {
                      _response.ffTryingReconnect = false;
                      setTimeout(function() {
                        if (!_response.ffTryingReconnect) {
                          _triggerOpen(rq);
                        }
                      }, 500);
                    } else {
                      _triggerOpen(rq);
                    }
                  }
                } else if (ajaxRequest.readyState === 4) {
                  update = true;
                }
                if (update) {
                  var responseText = ajaxRequest.responseText;
                  _response.errorHandled = false;
                  if (rq.transport === "long-polling" && atmosphere2.util.trim(responseText).length === 0) {
                    if (!ajaxRequest.hasData) {
                      reconnectF(true);
                    } else {
                      ajaxRequest.hasData = false;
                    }
                    return;
                  }
                  ajaxRequest.hasData = true;
                  _readHeaders(ajaxRequest, _request);
                  if (rq.transport === "streaming") {
                    if (!atmosphere2.util.browser.opera) {
                      var message = responseText.substring(rq.lastIndex, responseText.length);
                      skipCallbackInvocation = _trackMessageSize(message, rq, _response);
                      rq.lastIndex = responseText.length;
                      if (skipCallbackInvocation) {
                        return;
                      }
                    } else {
                      atmosphere2.util.iterate(function() {
                        if (_response.status !== 500 && ajaxRequest.responseText.length > rq.lastIndex) {
                          try {
                            _response.status = ajaxRequest.status;
                            _response.headers = atmosphere2.util.parseHeaders(ajaxRequest.getAllResponseHeaders());
                            _readHeaders(ajaxRequest, _request);
                          } catch (e) {
                            _response.status = 404;
                          }
                          _timeout(_request);
                          _response.state = "messageReceived";
                          var message2 = ajaxRequest.responseText.substring(rq.lastIndex);
                          rq.lastIndex = ajaxRequest.responseText.length;
                          skipCallbackInvocation = _trackMessageSize(message2, rq, _response);
                          if (!skipCallbackInvocation) {
                            _invokeCallback();
                          }
                          if (_verifyStreamingLength(ajaxRequest, rq)) {
                            _reconnectOnMaxStreamingLength(ajaxRequest, rq);
                            return;
                          }
                        } else if (_response.status > 400) {
                          rq.lastIndex = ajaxRequest.responseText.length;
                          return false;
                        }
                      }, 0);
                    }
                  } else {
                    skipCallbackInvocation = _trackMessageSize(responseText, rq, _response);
                  }
                  var closeStream = _verifyStreamingLength(ajaxRequest, rq);
                  try {
                    _response.status = ajaxRequest.status;
                    _response.headers = atmosphere2.util.parseHeaders(ajaxRequest.getAllResponseHeaders());
                    _readHeaders(ajaxRequest, rq);
                  } catch (e) {
                    _response.status = 404;
                  }
                  if (rq.suspend) {
                    _response.state = _response.status === 0 ? "closed" : "messageReceived";
                  } else {
                    _response.state = "messagePublished";
                  }
                  var isAllowedToReconnect = !closeStream && request.transport !== "streaming" && request.transport !== "polling";
                  if (isAllowedToReconnect && !rq.executeCallbackBeforeReconnect) {
                    _reconnect(ajaxRequest, rq, rq.pollingInterval);
                  }
                  if (_response.responseBody.length !== 0 && !skipCallbackInvocation)
                    _invokeCallback();
                  if (isAllowedToReconnect && rq.executeCallbackBeforeReconnect) {
                    _reconnect(ajaxRequest, rq, rq.pollingInterval);
                  }
                  if (closeStream) {
                    _reconnectOnMaxStreamingLength(ajaxRequest, rq);
                  }
                }
              };
              try {
                ajaxRequest.send(rq.data);
                _subscribed = true;
              } catch (e) {
                atmosphere2.util.log(rq.logLevel, ["Unable to connect to " + rq.url]);
                _onError(0, e);
              }
            } else {
              if (rq.logLevel === "debug") {
                atmosphere2.util.log(rq.logLevel, ["Max re-connection reached."]);
              }
              _onError(0, "maxRequest reached");
            }
          }
          function _reconnectOnMaxStreamingLength(ajaxRequest, rq) {
            _response.messages = [];
            rq.isReopen = true;
            _close();
            _abortingConnection = false;
            _reconnect(ajaxRequest, rq, 500);
          }
          function _doRequest(ajaxRequest, request, create) {
            var url = request.url;
            if (request.dispatchUrl != null && request.method === "POST") {
              url += request.dispatchUrl;
            }
            url = _attachHeaders(request, url);
            url = atmosphere2.util.prepareURL(url);
            if (create) {
              ajaxRequest.open(request.method, url, true);
              if (request.connectTimeout > 0) {
                request.id = setTimeout(function() {
                  if (request.requestCount === 0) {
                    _clearState();
                    _prepareCallback("Connect timeout", "closed", 200, request.transport);
                  }
                }, request.connectTimeout);
              }
            }
            if (_request.withCredentials && _request.transport !== "websocket") {
              if ("withCredentials" in ajaxRequest) {
                ajaxRequest.withCredentials = true;
              }
            }
            if (!_request.dropHeaders) {
              ajaxRequest.setRequestHeader("X-Atmosphere-Framework", atmosphere2.version);
              ajaxRequest.setRequestHeader("X-Atmosphere-Transport", request.transport);
              if (request.heartbeat !== null && request.heartbeat.server !== null) {
                ajaxRequest.setRequestHeader("X-Heartbeat-Server", ajaxRequest.heartbeat.server);
              }
              if (request.trackMessageLength) {
                ajaxRequest.setRequestHeader("X-Atmosphere-TrackMessageSize", "true");
              }
              ajaxRequest.setRequestHeader("X-Atmosphere-tracking-id", request.uuid);
              atmosphere2.util.each(request.headers, function(name, value) {
                var h = atmosphere2.util.isFunction(value) ? value.call(this, ajaxRequest, request, create, _response) : value;
                if (h != null) {
                  ajaxRequest.setRequestHeader(name, h);
                }
              });
            }
            if (request.contentType !== "") {
              ajaxRequest.setRequestHeader("Content-Type", request.contentType);
            }
          }
          function _reconnect(ajaxRequest, request, delay) {
            if (_response.closedByClientTimeout) {
              return;
            }
            if (request.reconnect || request.suspend && _subscribed) {
              var status = 0;
              if (ajaxRequest && ajaxRequest.readyState > 1) {
                status = ajaxRequest.status > 1e3 ? 0 : ajaxRequest.status;
              }
              _response.status = status === 0 ? 204 : status;
              _response.reason = status === 0 ? "Server resumed the connection or down." : "OK";
              clearTimeout(request.id);
              if (request.reconnectId) {
                clearTimeout(request.reconnectId);
                delete request.reconnectId;
              }
              if (delay > 0) {
                var handleOnlineOffline = _request.handleOnlineOffline;
                _request.handleOnlineOffline = false;
                _request.reconnectId = setTimeout(function() {
                  _request.handleOnlineOffline = handleOnlineOffline;
                  _executeRequest(request);
                }, delay);
              } else {
                _executeRequest(request);
              }
            }
          }
          function _tryingToReconnect(response) {
            response.state = "re-connecting";
            _invokeFunction(response);
          }
          function _openAfterResume(response) {
            response.state = "openAfterResume";
            _invokeFunction(response);
            response.state = "messageReceived";
          }
          function _ieXDR(request) {
            if (request.transport !== "polling") {
              _ieStream = _configureXDR(request);
              _ieStream.open();
            } else {
              _configureXDR(request).open();
            }
          }
          function _configureXDR(request) {
            var rq = _request;
            if (request != null && typeof request !== "undefined") {
              rq = request;
            }
            var transport = rq.transport;
            var lastIndex = 0;
            var xdr = new window.XDomainRequest();
            var reconnect = function() {
              if (rq.transport === "long-polling" && (rq.reconnect && (rq.maxRequest === -1 || rq.requestCount++ < rq.maxRequest))) {
                xdr.status = 200;
                _ieXDR(rq);
              }
            };
            var rewriteURL = rq.rewriteURL || function(url) {
              var match = /(?:^|;\s*)(JSESSIONID|PHPSESSID)=([^;]*)/.exec(document.cookie);
              switch (match && match[1]) {
                case "JSESSIONID":
                  return url.replace(/;jsessionid=[^\?]*|(\?)|$/, ";jsessionid=" + match[2] + "$1");
                case "PHPSESSID":
                  return url.replace(/\?PHPSESSID=[^&]*&?|\?|$/, "?PHPSESSID=" + match[2] + "&").replace(/&$/, "");
              }
              return url;
            };
            xdr.onprogress = function() {
              handle(xdr);
            };
            xdr.onerror = function() {
              if (rq.transport !== "polling") {
                _clearState();
                if (_requestCount++ < rq.maxReconnectOnClose) {
                  if (rq.reconnectInterval > 0) {
                    rq.reconnectId = setTimeout(function() {
                      _open("re-connecting", request.transport, request);
                      _ieXDR(rq);
                    }, rq.reconnectInterval);
                  } else {
                    _open("re-connecting", request.transport, request);
                    _ieXDR(rq);
                  }
                } else {
                  _onError(0, "maxReconnectOnClose reached");
                }
              }
            };
            xdr.onload = function() {
            };
            var handle = function(xdr2) {
              clearTimeout(rq.id);
              var message = xdr2.responseText;
              message = message.substring(lastIndex);
              lastIndex += message.length;
              if (transport !== "polling") {
                _timeout(rq);
                var skipCallbackInvocation = _trackMessageSize(message, rq, _response);
                if (transport === "long-polling" && atmosphere2.util.trim(message).length === 0)
                  return;
                if (rq.executeCallbackBeforeReconnect) {
                  reconnect();
                }
                if (!skipCallbackInvocation) {
                  _prepareCallback(_response.responseBody, "messageReceived", 200, transport);
                }
                if (!rq.executeCallbackBeforeReconnect) {
                  reconnect();
                }
              }
            };
            return {
              open: function() {
                var url = rq.url;
                if (rq.dispatchUrl != null) {
                  url += rq.dispatchUrl;
                }
                url = _attachHeaders(rq, url);
                xdr.open(rq.method, rewriteURL(url));
                if (rq.method === "GET") {
                  xdr.send();
                } else {
                  xdr.send(rq.data);
                }
                if (rq.connectTimeout > 0) {
                  rq.id = setTimeout(function() {
                    if (rq.requestCount === 0) {
                      _clearState();
                      _prepareCallback("Connect timeout", "closed", 200, rq.transport);
                    }
                  }, rq.connectTimeout);
                }
              },
              close: function() {
                xdr.abort();
              }
            };
          }
          function _ieStreaming(request) {
            _ieStream = _configureIE(request);
            _ieStream.open();
          }
          function _configureIE(request) {
            var rq = _request;
            if (request != null && typeof request !== "undefined") {
              rq = request;
            }
            var stop;
            var doc = new window.ActiveXObject("htmlfile");
            doc.open();
            doc.close();
            var url = rq.url;
            if (rq.dispatchUrl != null) {
              url += rq.dispatchUrl;
            }
            if (rq.transport !== "polling") {
              _response.transport = rq.transport;
            }
            return {
              open: function() {
                var iframe = doc.createElement("iframe");
                url = _attachHeaders(rq);
                if (rq.data !== "") {
                  url += "&X-Atmosphere-Post-Body=" + encodeURIComponent(rq.data);
                }
                url = atmosphere2.util.prepareURL(url);
                iframe.src = url;
                doc.body.appendChild(iframe);
                var cdoc = iframe.contentDocument || iframe.contentWindow.document;
                stop = atmosphere2.util.iterate(function() {
                  try {
                    if (!cdoc.firstChild) {
                      return;
                    }
                    var res = cdoc.body ? cdoc.body.lastChild : cdoc;
                    if (res.omgThisIsBroken) {
                    }
                    var readResponse = function() {
                      var clone = res.cloneNode(true);
                      clone.appendChild(cdoc.createTextNode("."));
                      var text = clone.innerText;
                      text = text.substring(0, text.length - 1);
                      return text;
                    };
                    if (!cdoc.body || !cdoc.body.firstChild || cdoc.body.firstChild.nodeName.toLowerCase() !== "pre") {
                      var head = cdoc.head || cdoc.getElementsByTagName("head")[0] || cdoc.documentElement || cdoc;
                      var script = cdoc.createElement("script");
                      script.text = "document.write('<plaintext>')";
                      head.insertBefore(script, head.firstChild);
                      head.removeChild(script);
                      res = cdoc.body.lastChild;
                    }
                    if (rq.closed) {
                      rq.isReopen = true;
                    }
                    stop = atmosphere2.util.iterate(function() {
                      var text = readResponse();
                      if (text.length > rq.lastIndex) {
                        _timeout(_request);
                        _response.status = 200;
                        _response.error = false;
                        res.innerText = "";
                        var skipCallbackInvocation = _trackMessageSize(text, rq, _response);
                        if (skipCallbackInvocation) {
                          return "";
                        }
                        _prepareCallback(_response.responseBody, "messageReceived", 200, rq.transport);
                      }
                      rq.lastIndex = 0;
                      if (cdoc.readyState === "complete") {
                        _invokeClose(true);
                        _open("re-connecting", rq.transport, rq);
                        if (rq.reconnectInterval > 0) {
                          rq.reconnectId = setTimeout(function() {
                            _ieStreaming(rq);
                          }, rq.reconnectInterval);
                        } else {
                          _ieStreaming(rq);
                        }
                        return false;
                      }
                    }, null);
                    return false;
                  } catch (err) {
                    _response.error = true;
                    _open("re-connecting", rq.transport, rq);
                    if (_requestCount++ < rq.maxReconnectOnClose) {
                      if (rq.reconnectInterval > 0) {
                        rq.reconnectId = setTimeout(function() {
                          _ieStreaming(rq);
                        }, rq.reconnectInterval);
                      } else {
                        _ieStreaming(rq);
                      }
                    } else {
                      _onError(0, "maxReconnectOnClose reached");
                    }
                    doc.execCommand("Stop");
                    doc.close();
                    return false;
                  }
                });
              },
              close: function() {
                if (stop) {
                  stop();
                }
                doc.execCommand("Stop");
                _invokeClose(true);
              }
            };
          }
          function _push(message) {
            if (_localStorageService != null) {
              _pushLocal(message);
            } else if (_activeRequest != null || _sse != null) {
              _pushAjaxMessage(message);
            } else if (_ieStream != null) {
              _pushIE(message);
            } else if (_jqxhr != null) {
              _pushJsonp(message);
            } else if (_websocket != null) {
              _pushWebSocket(message);
            } else {
              _onError(0, "No suspended connection available");
              atmosphere2.util.error("No suspended connection available. Make sure atmosphere.subscribe has been called and request.onOpen invoked before trying to push data");
            }
          }
          function _pushOnClose(message, rq) {
            if (!rq) {
              rq = _getPushRequest(message);
            }
            rq.transport = "polling";
            rq.method = "GET";
            rq.withCredentials = false;
            rq.reconnect = false;
            rq.force = true;
            rq.suspend = false;
            rq.timeout = 1e3;
            if (_request.unloadBackwardCompat) {
              _executeRequest(rq);
            } else {
              navigator.sendBeacon(rq.url, rq.data);
            }
          }
          function _pushLocal(message) {
            _localStorageService.send(message);
          }
          function _intraPush(message) {
            if (message.length === 0)
              return;
            try {
              if (_localStorageService) {
                _localStorageService.localSend(message);
              } else if (_storageService) {
                _storageService.signal("localMessage", JSON.stringify({
                  id: guid2,
                  event: message
                }));
              }
            } catch (err) {
              atmosphere2.util.error(err);
            }
          }
          function _pushAjaxMessage(message) {
            var rq = _getPushRequest(message);
            _executeRequest(rq);
          }
          function _pushIE(message) {
            if (_request.enableXDR && atmosphere2.util.checkCORSSupport()) {
              var rq = _getPushRequest(message);
              rq.reconnect = false;
              _jsonp(rq);
            } else {
              _pushAjaxMessage(message);
            }
          }
          function _pushJsonp(message) {
            _pushAjaxMessage(message);
          }
          function _getStringMessage(message) {
            var msg = message;
            if (typeof msg === "object") {
              msg = message.data;
            }
            return msg;
          }
          function _getPushRequest(message) {
            var msg = _getStringMessage(message);
            var rq = {
              connected: false,
              timeout: 6e4,
              method: "POST",
              url: _request.url,
              contentType: _request.contentType,
              headers: _request.headers,
              reconnect: true,
              callback: null,
              data: msg,
              suspend: false,
              maxRequest: -1,
              logLevel: "info",
              requestCount: 0,
              withCredentials: _request.withCredentials,
              transport: "polling",
              isOpen: true,
              attachHeadersAsQueryString: true,
              enableXDR: _request.enableXDR,
              uuid: _request.uuid,
              dispatchUrl: _request.dispatchUrl,
              enableProtocol: false,
              messageDelimiter: "|",
              trackMessageLength: _request.trackMessageLength,
              maxReconnectOnClose: _request.maxReconnectOnClose,
              heartbeatTimer: _request.heartbeatTimer,
              heartbeat: _request.heartbeat
            };
            if (typeof message === "object") {
              rq = atmosphere2.util.extend(rq, message);
            }
            return rq;
          }
          function _pushWebSocket(message) {
            var msg = atmosphere2.util.isBinary(message) ? message : _getStringMessage(message);
            var data;
            try {
              if (_request.dispatchUrl != null) {
                data = _request.webSocketPathDelimiter + _request.dispatchUrl + _request.webSocketPathDelimiter + msg;
              } else {
                data = msg;
              }
              if (!_websocket.canSendMessage) {
                atmosphere2.util.error("WebSocket not connected.");
                return;
              }
              _websocket.send(data);
            } catch (e) {
              _websocket.onclose = function() {
              };
              _clearState();
              _reconnectWithFallbackTransport("Websocket failed. Downgrading to " + _request.fallbackTransport + " and resending " + message);
              _pushAjaxMessage(message);
            }
          }
          function _localMessage(message) {
            var m = JSON.parse(message);
            if (m.id !== guid2) {
              if (typeof _request.onLocalMessage !== "undefined") {
                _request.onLocalMessage(m.event);
              } else if (typeof atmosphere2.util.onLocalMessage !== "undefined") {
                atmosphere2.util.onLocalMessage(m.event);
              }
            }
          }
          function _prepareCallback(messageBody, state, errorCode, transport) {
            _response.responseBody = messageBody;
            _response.transport = transport;
            _response.status = errorCode;
            _response.state = state;
            _invokeCallback();
          }
          function _readHeaders(xdr, request) {
            if (!request.readResponsesHeaders) {
              if (!request.enableProtocol) {
                request.uuid = guid2;
              }
            } else {
              try {
                var tempUUID = xdr.getResponseHeader("X-Atmosphere-tracking-id");
                if (tempUUID && tempUUID != null) {
                  request.uuid = tempUUID.split(" ").pop();
                }
              } catch (e) {
              }
            }
          }
          function _invokeFunction(response) {
            _f(response, _request);
            _f(response, atmosphere2.util);
          }
          function _f(response, f) {
            switch (response.state) {
              case "messageReceived":
                _debug("Firing onMessage");
                _requestCount = 0;
                if (typeof f.onMessage !== "undefined")
                  f.onMessage(response);
                if (typeof f.onmessage !== "undefined")
                  f.onmessage(response);
                break;
              case "error":
                var dbgReasonPhrase = typeof response.reasonPhrase != "undefined" ? response.reasonPhrase : "n/a";
                _debug("Firing onError, reasonPhrase: " + dbgReasonPhrase);
                if (typeof f.onError !== "undefined")
                  f.onError(response);
                if (typeof f.onerror !== "undefined")
                  f.onerror(response);
                break;
              case "opening":
                delete _request.closed;
                _debug("Firing onOpen");
                if (typeof f.onOpen !== "undefined")
                  f.onOpen(response);
                if (typeof f.onopen !== "undefined")
                  f.onopen(response);
                break;
              case "messagePublished":
                _debug("Firing messagePublished");
                if (typeof f.onMessagePublished !== "undefined")
                  f.onMessagePublished(response);
                break;
              case "re-connecting":
                _debug("Firing onReconnect");
                if (typeof f.onReconnect !== "undefined")
                  f.onReconnect(_request, response);
                break;
              case "closedByClient":
                _debug("Firing closedByClient");
                if (typeof f.onClientTimeout !== "undefined")
                  f.onClientTimeout(_request);
                break;
              case "re-opening":
                delete _request.closed;
                _debug("Firing onReopen");
                if (typeof f.onReopen !== "undefined")
                  f.onReopen(_request, response);
                break;
              case "fail-to-reconnect":
                _debug("Firing onFailureToReconnect");
                if (typeof f.onFailureToReconnect !== "undefined")
                  f.onFailureToReconnect(_request, response);
                break;
              case "unsubscribe":
              case "closed":
                var closed = typeof _request.closed !== "undefined" ? _request.closed : false;
                if (!closed) {
                  _debug("Firing onClose (" + response.state + " case)");
                  if (typeof f.onClose !== "undefined") {
                    f.onClose(response);
                  }
                  if (typeof f.onclose !== "undefined") {
                    f.onclose(response);
                  }
                } else {
                  _debug("Request already closed, not firing onClose (" + response.state + " case)");
                }
                _request.closed = true;
                break;
              case "openAfterResume":
                if (typeof f.onOpenAfterResume !== "undefined")
                  f.onOpenAfterResume(_request);
                break;
            }
          }
          function _invokeClose(wasOpen) {
            if (_response.state !== "closed") {
              _response.state = "closed";
              _response.responseBody = "";
              _response.messages = [];
              _response.status = !wasOpen ? 501 : 200;
              _invokeCallback();
            }
          }
          function _invokeCallback() {
            var call = function(index, func) {
              func(_response);
            };
            if (_localStorageService == null && _localSocketF != null) {
              _localSocketF(_response.responseBody);
            }
            _request.reconnect = _request.mrequest;
            var isString = typeof _response.responseBody === "string";
            var messages = isString && _request.trackMessageLength ? _response.messages.length > 0 ? _response.messages : [""] : new Array(
              _response.responseBody
            );
            for (var i = 0; i < messages.length; i++) {
              if (messages.length > 1 && messages[i].length === 0) {
                continue;
              }
              _response.responseBody = isString ? atmosphere2.util.trim(messages[i]) : messages[i];
              if (_localStorageService == null && _localSocketF != null) {
                _localSocketF(_response.responseBody);
              }
              if (_response.state === "messageReceived") {
                if (_response.responseBody.length === 0) {
                  continue;
                } else if (isString && _heartbeatPadding === _response.responseBody) {
                  _requestCount = 0;
                  continue;
                }
              }
              _invokeFunction(_response);
              if (callbacks.length > 0) {
                if (_canLog("debug")) {
                  atmosphere2.util.debug("Invoking " + callbacks.length + " global callbacks: " + _response.state);
                }
                try {
                  atmosphere2.util.each(callbacks, call);
                } catch (e) {
                  atmosphere2.util.log(_request.logLevel, ["Callback exception" + e]);
                }
              }
              if (typeof _request.callback === "function") {
                if (_canLog("debug")) {
                  atmosphere2.util.debug("Invoking request callbacks");
                }
                try {
                  _request.callback(_response);
                } catch (e) {
                  atmosphere2.util.log(_request.logLevel, ["Callback exception" + e]);
                }
              }
            }
          }
          this.subscribe = function(options2) {
            _subscribe(options2);
            _execute();
          };
          this.execute = function() {
            _execute();
          };
          this.close = function() {
            _close();
          };
          this.disconnect = function() {
            _disconnect();
          };
          this.getUrl = function() {
            return _request.url;
          };
          this.push = function(message, dispatchUrl) {
            if (dispatchUrl != null) {
              var originalDispatchUrl = _request.dispatchUrl;
              _request.dispatchUrl = dispatchUrl;
              _push(message);
              _request.dispatchUrl = originalDispatchUrl;
            } else {
              _push(message);
            }
          };
          this.getUUID = function() {
            return _request.uuid;
          };
          this.pushLocal = function(message) {
            _intraPush(message);
          };
          this.enableProtocol = function() {
            return _request.enableProtocol;
          };
          this.init = function() {
            _init();
          };
          this.request = _request;
          this.response = _response;
        }
      };
      atmosphere2.subscribe = function(url, callback, request) {
        if (typeof callback === "function") {
          atmosphere2.addCallback(callback);
        }
        if (typeof url !== "string") {
          request = url;
        } else {
          request.url = url;
        }
        uuid = typeof request !== "undefined" && typeof request.uuid !== "undefined" ? request.uuid : 0;
        var rq = new atmosphere2.AtmosphereRequest(request);
        rq.execute();
        requests[requests.length] = rq;
        return rq;
      };
      atmosphere2.unsubscribe = function() {
        if (requests.length > 0) {
          var requestsClone = [].concat(requests);
          for (var i = 0; i < requestsClone.length; i++) {
            var rq = requestsClone[i];
            rq.close();
            clearTimeout(rq.response.request.id);
            if (rq.heartbeatTimer) {
              clearTimeout(rq.heartbeatTimer);
            }
          }
        }
        requests = [];
        callbacks = [];
      };
      atmosphere2.unsubscribeUrl = function(url) {
        var idx = -1;
        if (requests.length > 0) {
          for (var i = 0; i < requests.length; i++) {
            var rq = requests[i];
            if (rq.getUrl() === url) {
              rq.close();
              clearTimeout(rq.response.request.id);
              if (rq.heartbeatTimer) {
                clearTimeout(rq.heartbeatTimer);
              }
              idx = i;
              break;
            }
          }
        }
        if (idx >= 0) {
          requests.splice(idx, 1);
        }
      };
      atmosphere2.addCallback = function(func) {
        if (atmosphere2.util.inArray(func, callbacks) === -1) {
          callbacks.push(func);
        }
      };
      atmosphere2.removeCallback = function(func) {
        var index = atmosphere2.util.inArray(func, callbacks);
        if (index !== -1) {
          callbacks.splice(index, 1);
        }
      };
      atmosphere2.util = {
        browser: {},
        parseHeaders: function(headerString) {
          var match, rheaders = /^(.*?):[ \t]*([^\r\n]*)\r?$/mg, headers = {};
          while (match = rheaders.exec(headerString)) {
            headers[match[1]] = match[2];
          }
          return headers;
        },
        now: function() {
          return (/* @__PURE__ */ new Date()).getTime();
        },
        isArray: function(array) {
          return Object.prototype.toString.call(array) === "[object Array]";
        },
        inArray: function(elem, array) {
          if (!Array.prototype.indexOf) {
            var len = array.length;
            for (var i = 0; i < len; ++i) {
              if (array[i] === elem) {
                return i;
              }
            }
            return -1;
          }
          return array.indexOf(elem);
        },
        isBinary: function(data) {
          return /^\[object\s(?:Blob|ArrayBuffer|.+Array)\]$/.test(Object.prototype.toString.call(data));
        },
        isFunction: function(fn) {
          return Object.prototype.toString.call(fn) === "[object Function]";
        },
        getAbsoluteURL: function(url) {
          if (typeof document.createElement === "undefined") {
            return url;
          }
          var div = document.createElement("div");
          div.innerHTML = '<a href="' + url + '"></a>';
          var ua = window.navigator.userAgent;
          if (ua.indexOf("MSIE ") > 0 || ua.indexOf("Trident/") > 0 || ua.indexOf("Edge/") > 0) {
            return atmosphere2.util.fixedEncodeURI(decodeURI(div.firstChild.href));
          }
          return div.firstChild.href;
        },
        fixedEncodeURI: function(str) {
          return encodeURI(str).replace(/%5B/g, "[").replace(/%5D/g, "]");
        },
        prepareURL: function(url) {
          var ts = atmosphere2.util.now();
          var ret = url.replace(/([?&])_=[^&]*/, "$1_=" + ts);
          return ret + (ret === url ? (/\?/.test(url) ? "&" : "?") + "_=" + ts : "");
        },
        trim: function(str) {
          if (!String.prototype.trim) {
            return str.toString().replace(/(?:(?:^|\n)\s+|\s+(?:$|\n))/g, "").replace(/\s+/g, " ");
          } else {
            return str.toString().trim();
          }
        },
        param: function(params) {
          var prefix, s = [];
          function add(key, value) {
            value = atmosphere2.util.isFunction(value) ? value() : value == null ? "" : value;
            s.push(encodeURIComponent(key) + "=" + encodeURIComponent(value));
          }
          function buildParams(prefix2, obj) {
            var name;
            if (atmosphere2.util.isArray(obj)) {
              atmosphere2.util.each(obj, function(i, v) {
                if (/\[\]$/.test(prefix2)) {
                  add(prefix2, v);
                } else {
                  buildParams(prefix2 + "[" + (typeof v === "object" ? i : "") + "]", v);
                }
              });
            } else if (Object.prototype.toString.call(obj) === "[object Object]") {
              for (name in obj) {
                buildParams(prefix2 + "[" + name + "]", obj[name]);
              }
            } else {
              add(prefix2, obj);
            }
          }
          for (prefix in params) {
            buildParams(prefix, params[prefix]);
          }
          return s.join("&").replace(/%20/g, "+");
        },
        storage: function() {
          try {
            return !!(window.localStorage && window.StorageEvent);
          } catch (e) {
            return false;
          }
        },
        iterate: function(fn, interval) {
          var timeoutId;
          interval = interval || 0;
          (function loop() {
            timeoutId = setTimeout(function() {
              if (fn() === false) {
                return;
              }
              loop();
            }, interval);
          })();
          return function() {
            clearTimeout(timeoutId);
          };
        },
        each: function(obj, callback, args) {
          if (!obj) return;
          var value, i = 0, length = obj.length, isArray = atmosphere2.util.isArray(obj);
          if (args) {
            if (isArray) {
              for (; i < length; i++) {
                value = callback.apply(obj[i], args);
                if (value === false) {
                  break;
                }
              }
            } else {
              for (i in obj) {
                value = callback.apply(obj[i], args);
                if (value === false) {
                  break;
                }
              }
            }
          } else {
            if (isArray) {
              for (; i < length; i++) {
                value = callback.call(obj[i], i, obj[i]);
                if (value === false) {
                  break;
                }
              }
            } else {
              for (i in obj) {
                value = callback.call(obj[i], i, obj[i]);
                if (value === false) {
                  break;
                }
              }
            }
          }
          return obj;
        },
        extend: function(target) {
          var i, options, name;
          for (i = 1; i < arguments.length; i++) {
            if ((options = arguments[i]) != null) {
              for (name in options) {
                target[name] = options[name];
              }
            }
          }
          return target;
        },
        on: function(elem, type, fn) {
          if (elem.addEventListener) {
            elem.addEventListener(type, fn, false);
          } else if (elem.attachEvent) {
            elem.attachEvent("on" + type, fn);
          }
        },
        off: function(elem, type, fn) {
          if (elem.removeEventListener) {
            elem.removeEventListener(type, fn, false);
          } else if (elem.detachEvent) {
            elem.detachEvent("on" + type, fn);
          }
        },
        log: function(level, args) {
          if (window.console) {
            var logger = window.console[level];
            if (typeof logger === "function") {
              logger.apply(window.console, args);
            }
          }
        },
        warn: function() {
          atmosphere2.util.log("warn", arguments);
        },
        info: function() {
          atmosphere2.util.log("info", arguments);
        },
        debug: function() {
          atmosphere2.util.log("debug", arguments);
        },
        error: function() {
          atmosphere2.util.log("error", arguments);
        },
        xhr: function() {
          try {
            return new window.XMLHttpRequest();
          } catch (e1) {
            try {
              return new window.ActiveXObject("Microsoft.XMLHTTP");
            } catch (e2) {
            }
          }
        },
        checkCORSSupport: function() {
          if (atmosphere2.util.browser.msie && !window.XDomainRequest && +atmosphere2.util.browser.version.split(".")[0] < 11) {
            return true;
          } else if (atmosphere2.util.browser.opera && +atmosphere2.util.browser.version.split(".") < 12) {
            return true;
          } else if (atmosphere2.util.trim(navigator.userAgent).slice(0, 16) === "KreaTVWebKit/531") {
            return true;
          } else if (atmosphere2.util.trim(navigator.userAgent).slice(-7).toLowerCase() === "kreatel") {
            return true;
          }
          var ua = navigator.userAgent.toLowerCase();
          var androidVersionMatches = ua.match(/.+android ([0-9]{1,2})/i), majorVersion = parseInt(androidVersionMatches && androidVersionMatches[0] || -1, 10);
          if (!isNaN(majorVersion) && majorVersion > -1 && majorVersion < 3) {
            return true;
          }
          return false;
        }
      };
      guid = atmosphere2.util.now();
      (function() {
        var ua = navigator.userAgent.toLowerCase(), match = /(chrome)[ \/]([\w.]+)/.exec(ua) || /(opera)(?:.*version|)[ \/]([\w.]+)/.exec(ua) || /(msie) ([\w.]+)/.exec(ua) || /(trident)(?:.*? rv:([\w.]+)|)/.exec(ua) || ua.indexOf("android") < 0 && /version\/(.+) (safari)/.exec(ua) || ua.indexOf("compatible") < 0 && /(mozilla)(?:.*? rv:([\w.]+)|)/.exec(ua) || [];
        if (match[2] === "safari") {
          match[2] = match[1];
          match[1] = "safari";
        }
        atmosphere2.util.browser[match[1] || ""] = true;
        atmosphere2.util.browser.version = match[2] || "0";
        atmosphere2.util.browser.vmajor = atmosphere2.util.browser.version.split(".")[0];
        if (atmosphere2.util.browser.trident) {
          atmosphere2.util.browser.msie = true;
        }
        if (atmosphere2.util.browser.msie || atmosphere2.util.browser.mozilla && +atmosphere2.util.browser.version.split(".")[0] === 1) {
          atmosphere2.util.storage = false;
        }
      })();
      atmosphere2.callbacks = {
        unload: function() {
          atmosphere2.util.debug(/* @__PURE__ */ new Date() + " Atmosphere: unload event");
          atmosphere2.unsubscribe();
        },
        beforeUnload: function() {
          atmosphere2.util.debug(/* @__PURE__ */ new Date() + " Atmosphere: beforeunload event");
          atmosphere2._beforeUnloadState = true;
          setTimeout(function() {
            atmosphere2.util.debug(/* @__PURE__ */ new Date() + " Atmosphere: beforeunload event timeout reached. Reset _beforeUnloadState flag");
            atmosphere2._beforeUnloadState = false;
          }, 5e3);
        },
        offline: function() {
          atmosphere2.util.debug(/* @__PURE__ */ new Date() + " Atmosphere: offline event");
          offline = true;
          if (requests.length > 0) {
            var requestsClone = [].concat(requests);
            for (var i = 0; i < requestsClone.length; i++) {
              var rq = requestsClone[i];
              if (rq.request.handleOnlineOffline) {
                rq.close();
                clearTimeout(rq.response.request.id);
                if (rq.heartbeatTimer) {
                  clearTimeout(rq.heartbeatTimer);
                }
              }
            }
          }
        },
        online: function() {
          atmosphere2.util.debug(/* @__PURE__ */ new Date() + " Atmosphere: online event");
          if (requests.length > 0) {
            for (var i = 0; i < requests.length; i++) {
              if (requests[i].request.handleOnlineOffline) {
                requests[i].init();
                requests[i].execute();
              }
            }
          }
          offline = false;
        }
      };
      atmosphere2.bindEvents = function() {
        atmosphere2.util.on(window, "unload", atmosphere2.callbacks.unload);
        atmosphere2.util.on(window, "beforeunload", atmosphere2.callbacks.beforeUnload);
        atmosphere2.util.on(window, "offline", atmosphere2.callbacks.offline);
        atmosphere2.util.on(window, "online", atmosphere2.callbacks.online);
      };
      atmosphere2.unbindEvents = function() {
        atmosphere2.util.off(window, "unload", atmosphere2.callbacks.unload);
        atmosphere2.util.off(window, "beforeunload", atmosphere2.callbacks.beforeUnload);
        atmosphere2.util.off(window, "offline", atmosphere2.callbacks.offline);
        atmosphere2.util.off(window, "online", atmosphere2.callbacks.online);
      };
      atmosphere2.bindEvents();
      return atmosphere2;
    });
  }
});

// node_modules/atmosphere.js/lib/browser.js
var require_browser = __commonJS({
  "node_modules/atmosphere.js/lib/browser.js"(exports, module) {
    module.exports = require_atmosphere();
  }
});

// node_modules/js-cookie/dist/js.cookie.mjs
function assign(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];
    for (var key in source) {
      target[key] = source[key];
    }
  }
  return target;
}
var defaultConverter = {
  read: function(value) {
    if (value[0] === '"') {
      value = value.slice(1, -1);
    }
    return value.replace(/(%[\dA-F]{2})+/gi, decodeURIComponent);
  },
  write: function(value) {
    return encodeURIComponent(value).replace(
      /%(2[346BF]|3[AC-F]|40|5[BDE]|60|7[BCD])/g,
      decodeURIComponent
    );
  }
};
function init(converter, defaultAttributes) {
  function set(name, value, attributes) {
    if (typeof document === "undefined") {
      return;
    }
    attributes = assign({}, defaultAttributes, attributes);
    if (typeof attributes.expires === "number") {
      attributes.expires = new Date(Date.now() + attributes.expires * 864e5);
    }
    if (attributes.expires) {
      attributes.expires = attributes.expires.toUTCString();
    }
    name = encodeURIComponent(name).replace(/%(2[346B]|5E|60|7C)/g, decodeURIComponent).replace(/[()]/g, escape);
    var stringifiedAttributes = "";
    for (var attributeName in attributes) {
      if (!attributes[attributeName]) {
        continue;
      }
      stringifiedAttributes += "; " + attributeName;
      if (attributes[attributeName] === true) {
        continue;
      }
      stringifiedAttributes += "=" + attributes[attributeName].split(";")[0];
    }
    return document.cookie = name + "=" + converter.write(value, name) + stringifiedAttributes;
  }
  function get(name) {
    if (typeof document === "undefined" || arguments.length && !name) {
      return;
    }
    var cookies = document.cookie ? document.cookie.split("; ") : [];
    var jar = {};
    for (var i = 0; i < cookies.length; i++) {
      var parts = cookies[i].split("=");
      var value = parts.slice(1).join("=");
      try {
        var found = decodeURIComponent(parts[0]);
        jar[found] = converter.read(value, found);
        if (name === found) {
          break;
        }
      } catch (e) {
      }
    }
    return name ? jar[name] : jar;
  }
  return Object.create(
    {
      set,
      get,
      remove: function(name, attributes) {
        set(
          name,
          "",
          assign({}, attributes, {
            expires: -1
          })
        );
      },
      withAttributes: function(attributes) {
        return init(this.converter, assign({}, this.attributes, attributes));
      },
      withConverter: function(converter2) {
        return init(assign({}, this.converter, converter2), this.attributes);
      }
    },
    {
      attributes: { value: Object.freeze(defaultAttributes) },
      converter: { value: Object.freeze(converter) }
    }
  );
}
var api = init(defaultConverter, { path: "/" });

// node_modules/@vaadin/hilla-frontend/CookieManager.js
function calculatePath({ pathname }) {
  return pathname.length > 1 && pathname.endsWith("/") ? pathname.slice(0, -1) : pathname;
}
var CookieManager = api.withAttributes({
  path: calculatePath(new URL(document.baseURI))
});
var CookieManager_default = CookieManager;

// node_modules/@vaadin/hilla-frontend/CsrfUtils.js
var VAADIN_CSRF_HEADER = "X-CSRF-Token";
var VAADIN_CSRF_COOKIE_NAME = "csrfToken";
var SPRING_CSRF_COOKIE_NAME = "XSRF-TOKEN";
function extractContentFromMetaTag(element) {
  if (element) {
    const value = element.content;
    if (value && value.toLowerCase() !== "undefined") {
      return value;
    }
  }
  return void 0;
}
function getSpringCsrfHeaderFromMetaTag(doc) {
  const csrfHeader = doc.head.querySelector('meta[name="_csrf_header"]');
  return extractContentFromMetaTag(csrfHeader);
}
function getSpringCsrfTokenFromMetaTag(doc) {
  const csrfToken = doc.head.querySelector('meta[name="_csrf"]');
  return extractContentFromMetaTag(csrfToken);
}
function getSpringCsrfInfo(doc) {
  const csrfHeader = getSpringCsrfHeaderFromMetaTag(doc);
  let csrf = CookieManager_default.get(SPRING_CSRF_COOKIE_NAME);
  if (!csrf || csrf.length === 0) {
    csrf = getSpringCsrfTokenFromMetaTag(doc);
  }
  const headers = {};
  if (csrf && csrfHeader) {
    headers._csrf = csrf;
    headers._csrf_header = csrfHeader;
  }
  return headers;
}
function getSpringCsrfTokenHeadersForAuthRequest(doc) {
  const csrfInfo = getSpringCsrfInfo(doc);
  const headers = {};
  if (csrfInfo._csrf && csrfInfo._csrf_header) {
    headers[csrfInfo._csrf_header] = csrfInfo._csrf;
  }
  return headers;
}
function getCsrfTokenHeadersForEndpointRequest(doc) {
  const headers = {};
  const csrfInfo = getSpringCsrfInfo(doc);
  if (csrfInfo._csrf && csrfInfo._csrf_header) {
    headers[csrfInfo._csrf_header] = csrfInfo._csrf;
  } else {
    headers[VAADIN_CSRF_HEADER] = CookieManager_default.get(VAADIN_CSRF_COOKIE_NAME) ?? "";
  }
  return headers;
}

// node_modules/@vaadin/hilla-frontend/Authentication.js
var JWT_COOKIE_NAME = "jwt.headerAndPayload";
function getSpringCsrfTokenFromResponseBody(body) {
  const doc = new DOMParser().parseFromString(body, "text/html");
  return getSpringCsrfInfo(doc);
}
function clearSpringCsrfMetaTags() {
  Array.from(document.head.querySelectorAll('meta[name="_csrf"], meta[name="_csrf_header"]')).forEach(
    (el) => el.remove()
  );
}
function updateSpringCsrfMetaTags(springCsrfInfo) {
  clearSpringCsrfMetaTags();
  const headerNameMeta = document.createElement("meta");
  headerNameMeta.name = "_csrf_header";
  headerNameMeta.content = springCsrfInfo._csrf_header;
  document.head.appendChild(headerNameMeta);
  const tokenMeta = document.createElement("meta");
  tokenMeta.name = "_csrf";
  tokenMeta.content = springCsrfInfo._csrf;
  document.head.appendChild(tokenMeta);
}
var getVaadinCsrfTokenFromResponseBody = (body) => {
  const match = /window\.Vaadin = \{TypeScript: \{"csrfToken":"([0-9a-zA-Z\\-]{36})"\}\};/iu.exec(body);
  return match ? match[1] : void 0;
};
async function updateCsrfTokensBasedOnResponse(response) {
  const responseText = await response.text();
  const token = getVaadinCsrfTokenFromResponseBody(responseText);
  const springCsrfTokenInfo = getSpringCsrfTokenFromResponseBody(responseText);
  updateSpringCsrfMetaTags(springCsrfTokenInfo);
  return token;
}
async function doLogout(logoutUrl, headers) {
  const response = await fetch(logoutUrl, { headers, method: "POST" });
  if (!response.ok) {
    throw new Error(`failed to logout with response ${response.status}`);
  }
  await updateCsrfTokensBasedOnResponse(response);
  return response;
}
function normalizePath(url) {
  const effectiveBaseURL = new URL(".", document.baseURI);
  const effectiveBaseURI = effectiveBaseURL.toString();
  let normalized = url;
  if (normalized.startsWith(effectiveBaseURL.pathname)) {
    return `/${normalized.slice(effectiveBaseURL.pathname.length)}`;
  }
  normalized = normalized.startsWith(effectiveBaseURI) ? `/${normalized.slice(effectiveBaseURI.length)}` : normalized;
  return normalized;
}
function navigateWithPageReload(to) {
  const url = to.startsWith("/") ? new URL(`.${to}`, document.baseURI) : to;
  window.location.replace(url);
}
async function login(username, password, options) {
  try {
    const data = new FormData();
    data.append("username", username);
    data.append("password", password);
    const loginProcessingUrl = (options == null ? void 0 : options.loginProcessingUrl) ?? "login";
    const headers = getSpringCsrfTokenHeadersForAuthRequest(document);
    headers.source = "typescript";
    const response = await fetch(loginProcessingUrl, {
      body: data,
      headers,
      method: "POST"
    });
    const result = response.headers.get("Result");
    const savedUrl = response.headers.get("Saved-url") ?? void 0;
    const defaultUrl = response.headers.get("Default-url") ?? void 0;
    const loginSuccessful = response.ok && result === "success";
    if (loginSuccessful) {
      const vaadinCsrfToken = response.headers.get("Vaadin-CSRF") ?? void 0;
      const springCsrfHeader = response.headers.get("Spring-CSRF-header") ?? void 0;
      const springCsrfToken = response.headers.get("Spring-CSRF-token") ?? void 0;
      if (springCsrfHeader && springCsrfToken) {
        const springCsrfTokenInfo = {};
        springCsrfTokenInfo._csrf = springCsrfToken;
        springCsrfTokenInfo._csrf_header = springCsrfHeader;
        updateSpringCsrfMetaTags(springCsrfTokenInfo);
      }
      if (options == null ? void 0 : options.onSuccess) {
        await options.onSuccess();
      }
      const url = savedUrl ?? defaultUrl ?? document.baseURI;
      const toPath = normalizePath(url);
      const navigate = (options == null ? void 0 : options.navigate) ?? navigateWithPageReload;
      navigate(toPath);
      return {
        defaultUrl,
        error: false,
        redirectUrl: savedUrl,
        token: vaadinCsrfToken
      };
    }
    return {
      error: true,
      errorMessage: "Check that you have entered the correct username and password and try again.",
      errorTitle: "Incorrect username or password."
    };
  } catch (e) {
    if (e instanceof Error) {
      return {
        error: true,
        errorMessage: e.message,
        errorTitle: e.name
      };
    }
    throw e;
  }
}
async function logout(options) {
  const logoutUrl = (options == null ? void 0 : options.logoutUrl) ?? "logout";
  let response;
  try {
    const headers = getSpringCsrfTokenHeadersForAuthRequest(document);
    response = await doLogout(logoutUrl, headers);
  } catch {
    try {
      const noCacheResponse = await fetch("?nocache");
      const responseText = await noCacheResponse.text();
      const doc = new DOMParser().parseFromString(responseText, "text/html");
      const headers = getSpringCsrfTokenHeadersForAuthRequest(doc);
      response = await doLogout(logoutUrl, headers);
    } catch (error) {
      clearSpringCsrfMetaTags();
      throw error;
    }
  } finally {
    CookieManager_default.remove(JWT_COOKIE_NAME);
    if (response && response.ok && response.redirected) {
      if (options == null ? void 0 : options.onSuccess) {
        await options.onSuccess();
      }
      const toPath = normalizePath(response.url);
      const navigate = (options == null ? void 0 : options.navigate) ?? navigateWithPageReload;
      navigate(toPath);
    }
  }
}
var InvalidSessionMiddleware = class {
  constructor(onInvalidSessionCallback) {
    __publicField(this, "onInvalidSessionCallback");
    this.onInvalidSessionCallback = onInvalidSessionCallback;
  }
  async invoke(context, next) {
    const clonedContext = { ...context };
    clonedContext.request = context.request.clone();
    const response = await next(context);
    if (response.status === 401) {
      const loginResult = await this.onInvalidSessionCallback();
      if (loginResult.token) {
        clonedContext.request.headers.set(VAADIN_CSRF_HEADER, loginResult.token);
        return next(clonedContext);
      }
    }
    return response;
  }
};

// node_modules/@vaadin/hilla-frontend/FluxConnection.js
var import_atmosphere = __toESM(require_browser(), 1);

// node_modules/@vaadin/hilla-frontend/FluxMessages.js
function isClientMessage(value) {
  return value != null && typeof value === "object" && "@type" in value;
}

// node_modules/@vaadin/hilla-frontend/FluxConnection.js
var State = ((State2) => {
  State2["ACTIVE"] = "active";
  State2["INACTIVE"] = "inactive";
  State2["RECONNECTING"] = "reconnecting";
  return State2;
})(State || {});
var ActionOnLostSubscription = ((ActionOnLostSubscription2) => {
  ActionOnLostSubscription2["RESUBSCRIBE"] = "resubscribe";
  ActionOnLostSubscription2["REMOVE"] = "remove";
  return ActionOnLostSubscription2;
})(ActionOnLostSubscription || {});
var _endpointInfos, _nextId, _onCompleteCallbacks, _onErrorCallbacks, _onNextCallbacks, _pendingMessages, _socket, _FluxConnection_instances, connectWebsocket_fn, handleMessage_fn, removeSubscription_fn, send_fn, sendPendingMessages_fn;
var FluxConnection = class extends EventTarget {
  constructor(connectPrefix, atmosphereOptions) {
    super();
    __privateAdd(this, _FluxConnection_instances);
    __publicField(this, "state", "inactive");
    __privateAdd(this, _endpointInfos, /* @__PURE__ */ new Map());
    __privateAdd(this, _nextId, 0);
    __privateAdd(this, _onCompleteCallbacks, /* @__PURE__ */ new Map());
    __privateAdd(this, _onErrorCallbacks, /* @__PURE__ */ new Map());
    __privateAdd(this, _onNextCallbacks, /* @__PURE__ */ new Map());
    __privateAdd(this, _pendingMessages, []);
    __privateAdd(this, _socket);
    __privateMethod(this, _FluxConnection_instances, connectWebsocket_fn).call(this, connectPrefix.replace(/connect$/u, ""), atmosphereOptions ?? {});
  }
  /**
   * Subscribes to the flux returned by the given endpoint name + method name using the given parameters.
   *
   * @param endpointName - the endpoint to connect to
   * @param methodName - the method in the endpoint to connect to
   * @param parameters - the parameters to use
   * @returns a subscription
   */
  subscribe(endpointName, methodName, parameters) {
    const id = __privateGet(this, _nextId).toString();
    __privateSet(this, _nextId, __privateGet(this, _nextId) + 1);
    const params = parameters ?? [];
    const msg = { "@type": "subscribe", endpointName, id, methodName, params };
    __privateMethod(this, _FluxConnection_instances, send_fn).call(this, msg);
    __privateGet(this, _endpointInfos).set(id, { endpointName, methodName, params });
    const hillaSubscription = {
      cancel: () => {
        if (!__privateGet(this, _endpointInfos).has(id)) {
          return;
        }
        const closeMessage = { "@type": "unsubscribe", id };
        __privateMethod(this, _FluxConnection_instances, send_fn).call(this, closeMessage);
        __privateMethod(this, _FluxConnection_instances, removeSubscription_fn).call(this, id);
      },
      context(context) {
        context.addController({
          hostDisconnected() {
            hillaSubscription.cancel();
          }
        });
        return hillaSubscription;
      },
      onComplete: (callback) => {
        __privateGet(this, _onCompleteCallbacks).set(id, callback);
        return hillaSubscription;
      },
      onError: (callback) => {
        __privateGet(this, _onErrorCallbacks).set(id, callback);
        return hillaSubscription;
      },
      onNext: (callback) => {
        __privateGet(this, _onNextCallbacks).set(id, callback);
        return hillaSubscription;
      },
      onSubscriptionLost: (callback) => {
        if (__privateGet(this, _endpointInfos).has(id)) {
          __privateGet(this, _endpointInfos).get(id).reconnect = callback;
        } else {
          console.warn(`"onReconnect" value not set for subscription "${id}" because it was already canceled`);
        }
        return hillaSubscription;
      }
    };
    return hillaSubscription;
  }
};
_endpointInfos = new WeakMap();
_nextId = new WeakMap();
_onCompleteCallbacks = new WeakMap();
_onErrorCallbacks = new WeakMap();
_onNextCallbacks = new WeakMap();
_pendingMessages = new WeakMap();
_socket = new WeakMap();
_FluxConnection_instances = new WeakSet();
connectWebsocket_fn = function(prefix, atmosphereOptions) {
  var _a2, _b;
  const extraHeaders = getCsrfTokenHeadersForEndpointRequest(document);
  const pushUrl = "HILLA/push";
  const url = prefix.length === 0 ? pushUrl : (prefix.endsWith("/") ? prefix : `${prefix}/`) + pushUrl;
  __privateSet(this, _socket, (_b = (_a2 = import_atmosphere.default).subscribe) == null ? void 0 : _b.call(_a2, {
    contentType: "application/json; charset=UTF-8",
    enableProtocol: true,
    transport: "websocket",
    fallbackTransport: "websocket",
    headers: extraHeaders,
    maxReconnectOnClose: 1e7,
    reconnectInterval: 5e3,
    timeout: -1,
    trackMessageLength: true,
    url,
    onClose: () => {
      if (this.state !== "inactive") {
        this.state = "inactive";
        this.dispatchEvent(new CustomEvent("state-changed", { detail: { active: false } }));
      }
    },
    onError: (response) => {
      console.error("error in push communication", response);
    },
    onMessage: (response) => {
      if (response.responseBody) {
        __privateMethod(this, _FluxConnection_instances, handleMessage_fn).call(this, JSON.parse(response.responseBody));
      }
    },
    onMessagePublished: (response) => {
      if (response == null ? void 0 : response.responseBody) {
        __privateMethod(this, _FluxConnection_instances, handleMessage_fn).call(this, JSON.parse(response.responseBody));
      }
    },
    onOpen: () => {
      if (this.state !== "active") {
        this.state = "active";
        this.dispatchEvent(new CustomEvent("state-changed", { detail: { active: true } }));
        __privateMethod(this, _FluxConnection_instances, sendPendingMessages_fn).call(this);
      }
    },
    onReopen: () => {
      if (this.state !== "active") {
        const toBeRemoved = [];
        __privateGet(this, _endpointInfos).forEach((endpointInfo, id) => {
          var _a3;
          if (((_a3 = endpointInfo.reconnect) == null ? void 0 : _a3.call(endpointInfo)) === "resubscribe") {
            __privateMethod(this, _FluxConnection_instances, send_fn).call(this, {
              "@type": "subscribe",
              endpointName: endpointInfo.endpointName,
              id,
              methodName: endpointInfo.methodName,
              params: endpointInfo.params
            });
          } else {
            toBeRemoved.push(id);
          }
        });
        toBeRemoved.forEach((id) => __privateMethod(this, _FluxConnection_instances, removeSubscription_fn).call(this, id));
        this.state = "active";
        this.dispatchEvent(new CustomEvent("state-changed", { detail: { active: true } }));
        __privateMethod(this, _FluxConnection_instances, sendPendingMessages_fn).call(this);
      }
    },
    onReconnect: () => {
      if (this.state !== "reconnecting") {
        this.state = "reconnecting";
      }
    },
    onFailureToReconnect: () => {
      if (this.state !== "inactive") {
        this.state = "inactive";
        this.dispatchEvent(new CustomEvent("state-changed", { detail: { active: false } }));
      }
    },
    ...atmosphereOptions
  }));
};
handleMessage_fn = function(message) {
  var _a2;
  if (isClientMessage(message)) {
    const { id } = message;
    const endpointInfo = __privateGet(this, _endpointInfos).get(id);
    if (message["@type"] === "update") {
      const callback = __privateGet(this, _onNextCallbacks).get(id);
      if (callback) {
        callback(message.item);
      }
    } else if (message["@type"] === "complete") {
      (_a2 = __privateGet(this, _onCompleteCallbacks).get(id)) == null ? void 0 : _a2();
      __privateMethod(this, _FluxConnection_instances, removeSubscription_fn).call(this, id);
    } else {
      const callback = __privateGet(this, _onErrorCallbacks).get(id);
      if (callback) {
        callback();
      }
      __privateMethod(this, _FluxConnection_instances, removeSubscription_fn).call(this, id);
      if (!callback) {
        throw new Error(
          endpointInfo ? `Error in ${endpointInfo.endpointName}.${endpointInfo.methodName}(${JSON.stringify(endpointInfo.params)}): ${message.message}` : `Error in unknown subscription: ${message.message}`
        );
      }
    }
  } else {
    throw new Error(`Unknown message from server: ${String(message)}`);
  }
};
removeSubscription_fn = function(id) {
  __privateGet(this, _onNextCallbacks).delete(id);
  __privateGet(this, _onCompleteCallbacks).delete(id);
  __privateGet(this, _onErrorCallbacks).delete(id);
  __privateGet(this, _endpointInfos).delete(id);
};
send_fn = function(message) {
  var _a2, _b;
  if (this.state === "inactive") {
    __privateGet(this, _pendingMessages).push(message);
  } else {
    (_b = (_a2 = __privateGet(this, _socket)) == null ? void 0 : _a2.push) == null ? void 0 : _b.call(_a2, JSON.stringify(message));
  }
};
sendPendingMessages_fn = function() {
  __privateGet(this, _pendingMessages).forEach((msg) => __privateMethod(this, _FluxConnection_instances, send_fn).call(this, msg));
  __privateSet(this, _pendingMessages, []);
};

// node_modules/@vaadin/hilla-frontend/Connect.js
var $wnd = window;
$wnd.Vaadin ?? ($wnd.Vaadin = {});
var _a;
(_a = $wnd.Vaadin).registrations ?? (_a.registrations = []);
$wnd.Vaadin.registrations.push({
  is: "endpoint"
});
var assertResponseIsOk = async (response) => {
  if (!response.ok) {
    const errorText = await response.text();
    let errorJson;
    try {
      errorJson = JSON.parse(errorText);
    } catch (ignored) {
      errorJson = null;
    }
    const message = (errorJson == null ? void 0 : errorJson.message) ?? (errorText.length > 0 ? errorText : `expected "200 OK" response, but got ${response.status} ${response.statusText}`);
    const type = errorJson == null ? void 0 : errorJson.type;
    if (errorJson == null ? void 0 : errorJson.validationErrorData) {
      throw new EndpointValidationError(message, errorJson.validationErrorData, type);
    }
    if (type) {
      throw new EndpointError(message, type, errorJson == null ? void 0 : errorJson.detail);
    }
    switch (response.status) {
      case 401:
        throw new UnauthorizedResponseError(message, response);
      case 403:
        throw new ForbiddenResponseError(message, response);
      default:
        throw new EndpointResponseError(message, response);
    }
  }
};
function isFlowLoaded() {
  var _a2, _b, _c;
  return ((_c = (_b = (_a2 = $wnd.Vaadin) == null ? void 0 : _a2.Flow) == null ? void 0 : _b.clients) == null ? void 0 : _c.TypeScript) !== void 0;
}
var _fluxConnection;
var ConnectClient = class {
  /**
   * @param options - Constructor options.
   */
  constructor(options = {}) {
    /**
     * The array of middlewares that are invoked during a call.
     */
    __publicField(this, "middlewares", []);
    /**
     * The Hilla endpoint prefix
     */
    __publicField(this, "prefix", "/connect");
    /**
     * The Atmosphere options for the FluxConnection.
     */
    __publicField(this, "atmosphereOptions", {});
    __privateAdd(this, _fluxConnection);
    if (options.prefix) {
      this.prefix = options.prefix;
    }
    if (options.middlewares) {
      this.middlewares = options.middlewares;
    }
    if (options.atmosphereOptions) {
      this.atmosphereOptions = options.atmosphereOptions;
    }
    ConnectionIndicator.create();
    addEventListener("online", () => {
      var _a2;
      if (!isFlowLoaded() && ((_a2 = $wnd.Vaadin) == null ? void 0 : _a2.connectionState)) {
        $wnd.Vaadin.connectionState.state = ConnectionState.CONNECTED;
      }
    });
    addEventListener("offline", () => {
      var _a2;
      if (!isFlowLoaded() && ((_a2 = $wnd.Vaadin) == null ? void 0 : _a2.connectionState)) {
        $wnd.Vaadin.connectionState.state = ConnectionState.CONNECTION_LOST;
      }
    });
  }
  /**
   * Gets a representation of the underlying persistent network connection used for subscribing to Flux type endpoint
   * methods.
   */
  get fluxConnection() {
    if (!__privateGet(this, _fluxConnection)) {
      __privateSet(this, _fluxConnection, new FluxConnection(this.prefix, this.atmosphereOptions));
    }
    return __privateGet(this, _fluxConnection);
  }
  /**
   * Calls the given endpoint method defined using the endpoint and method
   * parameters with the parameters given as params.
   * Asynchronously returns the parsed JSON response data.
   *
   * @param endpoint - Endpoint name.
   * @param method - Method name to call in the endpoint class.
   * @param params - Optional parameters to pass to the method.
   * @param init - Optional parameters for the request
   * @returns Decoded JSON response data.
   */
  async call(endpoint, method, params, init2) {
    if (arguments.length < 2) {
      throw new TypeError(`2 arguments required, but got only ${arguments.length}`);
    }
    const csrfHeaders = getCsrfTokenHeadersForEndpointRequest(document);
    const headers = {
      Accept: "application/json",
      "Content-Type": "application/json",
      ...csrfHeaders
    };
    const request = new Request(`${this.prefix}/${endpoint}/${method}`, {
      body: params !== void 0 ? JSON.stringify(params, (_, value) => value === void 0 ? null : value) : void 0,
      headers,
      method: "POST"
    });
    const initialContext = {
      endpoint,
      method,
      params,
      request
    };
    async function responseHandlerMiddleware(context, next) {
      const response = await next(context);
      await assertResponseIsOk(response);
      const text = await response.text();
      return JSON.parse(text, (_, value) => value === null ? void 0 : value);
    }
    async function fetchNext(context) {
      var _a2, _b, _c, _d, _e, _f, _g, _h;
      (_b = (_a2 = $wnd.Vaadin) == null ? void 0 : _a2.connectionState) == null ? void 0 : _b.loadingStarted();
      try {
        const response = await fetch(context.request, { signal: init2 == null ? void 0 : init2.signal });
        (_d = (_c = $wnd.Vaadin) == null ? void 0 : _c.connectionState) == null ? void 0 : _d.loadingFinished();
        return response;
      } catch (error) {
        if (error instanceof Error && error.name === "AbortError") {
          (_f = (_e = $wnd.Vaadin) == null ? void 0 : _e.connectionState) == null ? void 0 : _f.loadingFinished();
        } else {
          (_h = (_g = $wnd.Vaadin) == null ? void 0 : _g.connectionState) == null ? void 0 : _h.loadingFailed();
        }
        return Promise.reject(error);
      }
    }
    const middlewares = [responseHandlerMiddleware, ...this.middlewares];
    const chain = middlewares.reduceRight(
      (next, middleware) => (
        // Compose and return the new chain step, that takes the context and
        // invokes the current middleware with the context and the further chain
        // as the next argument
        async (context) => {
          if (typeof middleware === "function") {
            return middleware(context, next);
          }
          return middleware.invoke(context, next);
        }
      ),
      // Initialize reduceRight the accumulator with `fetchNext`
      fetchNext
    );
    return chain(initialContext);
  }
  /**
   * Subscribes to the given method defined using the endpoint and method
   * parameters with the parameters given as params. The method must return a
   * compatible type such as a Flux.
   * Returns a subscription that is used to fetch values as they become available.
   *
   * @param endpoint - Endpoint name.
   * @param method - Method name to call in the endpoint class.
   * @param params - Optional parameters to pass to the method.
   * @returns A subscription used to handles values as they become available.
   */
  subscribe(endpoint, method, params) {
    return this.fluxConnection.subscribe(endpoint, method, params ? Object.values(params) : []);
  }
};
_fluxConnection = new WeakMap();

// node_modules/@vaadin/hilla-frontend/index.js
function __REGISTER__(feature, vaadinObj = window.Vaadin ?? (window.Vaadin = {})) {
  vaadinObj.registrations ?? (vaadinObj.registrations = []);
  vaadinObj.registrations.push({
    is: feature ? `${"@vaadin/hilla-frontend"}/${feature}` : "@vaadin/hilla-frontend",
    version: "24.5.5"
  });
}
__REGISTER__();

export {
  login,
  logout,
  InvalidSessionMiddleware,
  State,
  ActionOnLostSubscription,
  FluxConnection,
  ConnectClient
};
/*! Bundled license information:

js-cookie/dist/js.cookie.mjs:
  (*! js-cookie v3.0.5 | MIT *)
*/
//# sourceMappingURL=chunk-DHQHMXN4.js.map
