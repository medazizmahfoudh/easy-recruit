import {
  A,
  Button_exports,
  C2 as C,
  Checkbox_exports,
  ConfirmDialog_exports,
  DatePicker_exports,
  DateTimePicker_exports,
  Dialog_exports,
  FormLayout_exports,
  GridColumnGroup_exports,
  GridColumn_exports,
  GridSorter_exports,
  Grid_exports,
  Icon_exports,
  IntegerField_exports,
  Item_exports,
  ListBox_exports,
  NumberField_exports,
  O,
  Select_exports,
  SplitLayout_exports,
  T,
  TextArea_exports,
  TextField_exports,
  TimePicker_exports,
  VerticalLayout_exports,
  a,
  e,
  f,
  h,
  k,
  k2,
  m,
  m2,
  m3,
  n,
  n3 as n2,
  o2 as o,
  p,
  p2,
  p3,
  p4,
  r,
  r2,
  t,
  v
} from "./chunk-XWCE3DJ6.js";
import {
  BinderRoot,
  BooleanModel,
  CHANGED,
  EnumModel,
  NumberModel,
  ObjectModel,
  StringModel,
  ValidationError,
  _enum,
  _fromString,
  _meta,
  _validity,
  createDetachedModel,
  getBinderNode,
  getDefaultFieldStrategy,
  hasFromString,
  isFieldElement
} from "./chunk-FENHNDAW.js";
import "./chunk-DHQHMXN4.js";
import {
  EndpointError
} from "./chunk-FOJBNPP3.js";
import "./chunk-SV5EQZIV.js";
import "./chunk-5KP7IUG2.js";
import "./chunk-AVWG52NB.js";
import {
  require_jsx_runtime
} from "./chunk-SKCOSPGW.js";
import {
  require_react
} from "./chunk-IF5A3MEL.js";
import {
  __privateAdd,
  __privateGet,
  __privateSet,
  __publicField,
  __toESM
} from "./chunk-547O27LD.js";

// node_modules/@vaadin/hilla-react-crud/autogrid.js
var import_jsx_runtime5 = __toESM(require_jsx_runtime(), 1);
var import_react8 = __toESM(require_react(), 1);

// node_modules/@vaadin/hilla-react-crud/autogrid-column-context.js
var import_react = __toESM(require_react(), 1);
var ColumnContext = (0, import_react.createContext)(null);
var CustomColumnContext = (0, import_react.createContext)(null);

// node_modules/@vaadin/hilla-react-crud/autogrid-renderers.js
var import_jsx_runtime2 = __toESM(require_jsx_runtime(), 1);
var import_react4 = __toESM(require_react(), 1);

// node_modules/@vaadin/hilla-react-crud/locale.js
var import_react2 = __toESM(require_react(), 1);
var LocaleContext = (0, import_react2.createContext)(navigator.language);
function getFormatRegex(format) {
  const sampleDate = new Date(1234, 5 - 1, 6);
  const formattedSample = format.format(sampleDate);
  const pattern = formattedSample.replace("1234", "(?<year>\\d+)").replace("05", "(?<month>\\d+)").replace("5", "(?<month>\\d+)").replace("06", "(?<day>\\d+)").replace("6", "(?<day>\\d+)");
  return new RegExp(pattern, "u");
}
function tryFormatDate(formatter, value) {
  try {
    return value ? formatter.format(new Date(value)) : "";
  } catch (e2) {
    return "";
  }
}
var _date, _localTime, _localDateTime, _integer, _decimal, _parsePattern;
var LocaleFormatter = class {
  constructor(locale) {
    __privateAdd(this, _date);
    __privateAdd(this, _localTime);
    __privateAdd(this, _localDateTime);
    __privateAdd(this, _integer);
    __privateAdd(this, _decimal);
    __privateAdd(this, _parsePattern);
    __privateSet(this, _date, new Intl.DateTimeFormat(locale));
    __privateSet(this, _localTime, new Intl.DateTimeFormat(locale, {
      hour: "numeric",
      minute: "numeric"
    }));
    __privateSet(this, _localDateTime, new Intl.DateTimeFormat(locale, {
      day: "numeric",
      month: "numeric",
      year: "numeric",
      hour: "numeric",
      minute: "numeric"
    }));
    __privateSet(this, _integer, new Intl.NumberFormat(locale, {
      maximumFractionDigits: 0
    }));
    __privateSet(this, _decimal, new Intl.NumberFormat(locale, {
      maximumFractionDigits: 2,
      minimumFractionDigits: 2
    }));
    __privateSet(this, _parsePattern, getFormatRegex(__privateGet(this, _date)));
  }
  formatDate(value) {
    if (typeof value === "object") {
      const { year, month, day } = value;
      const date = /* @__PURE__ */ new Date();
      date.setFullYear(year, month, day);
      return __privateGet(this, _date).format(date);
    }
    return tryFormatDate(__privateGet(this, _date), value);
  }
  formatLocalTime(value) {
    return tryFormatDate(__privateGet(this, _localTime), `2000-01-01T${value}`);
  }
  formatLocalDateTime(value) {
    return tryFormatDate(__privateGet(this, _localDateTime), value);
  }
  formatInteger(value) {
    return value && Number.isFinite(value) ? __privateGet(this, _integer).format(value) : "";
  }
  formatDecimal(value) {
    return value && Number.isFinite(value) ? __privateGet(this, _decimal).format(value) : "";
  }
  parse(dateString) {
    var _a, _b, _c;
    const match = __privateGet(this, _parsePattern).exec(dateString);
    const year = Number((_a = match == null ? void 0 : match.groups) == null ? void 0 : _a.year);
    const month = Number((_b = match == null ? void 0 : match.groups) == null ? void 0 : _b.month) - 1;
    const day = Number((_c = match == null ? void 0 : match.groups) == null ? void 0 : _c.day);
    const dateInstance = /* @__PURE__ */ new Date();
    dateInstance.setFullYear(year, month, day);
    if (dateInstance.getFullYear() !== year || dateInstance.getMonth() !== month || dateInstance.getDate() !== day) {
      return void 0;
    }
    return { year, month, day };
  }
};
_date = new WeakMap();
_localTime = new WeakMap();
_localDateTime = new WeakMap();
_integer = new WeakMap();
_decimal = new WeakMap();
_parsePattern = new WeakMap();
function useLocaleFormatter() {
  const locale = (0, import_react2.useContext)(LocaleContext);
  return (0, import_react2.useMemo)(() => new LocaleFormatter(locale), [locale]);
}
var defaultDatePickerI18n = new e().i18n;
function useDatePickerI18n() {
  const formatter = useLocaleFormatter();
  return (0, import_react2.useMemo)(
    () => ({
      ...defaultDatePickerI18n,
      formatDate(value) {
        return formatter.formatDate(value);
      },
      parseDate(value) {
        return formatter.parse(value);
      }
    }),
    [formatter]
  );
}
var defaultDateTimePickerI18n = new t().i18n;
function useDateTimePickerI18n() {
  const datePickerI18n = useDatePickerI18n();
  return (0, import_react2.useMemo)(
    () => ({
      ...defaultDateTimePickerI18n,
      ...datePickerI18n
    }),
    [datePickerI18n]
  );
}

// node_modules/@vaadin/hilla-react-crud/util.js
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);
var import_react3 = __toESM(require_react(), 1);
function __REGISTER__(feature, vaadinObj = window.Vaadin ?? (window.Vaadin = {})) {
  vaadinObj.registrations ?? (vaadinObj.registrations = []);
  vaadinObj.registrations.push({
    is: feature ? `${"@vaadin/hilla-react-crud"}/${feature}` : "@vaadin/hilla-react-crud",
    version: "24.5.5"
  });
}
function convertToTitleCase(inputString) {
  const stringWithSpaces = inputString.replace(/_/gu, " ");
  const words = stringWithSpaces.split(" ");
  const titleCaseWords = words.map((word) => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase());
  return titleCaseWords.join(" ");
}
function registerStylesheet(stylesheet) {
  const css4 = Array.from(stylesheet.cssRules).map((rule) => rule.cssText).join("\n");
  const styleTag = document.createElement("style");
  styleTag.textContent = css4;
  document.head.prepend(styleTag);
}
var registeredFeatures = /* @__PURE__ */ new Set();
function useFeatureRegistration(feature) {
  if (registeredFeatures.has(feature)) {
    return;
  }
  registeredFeatures.add(feature);
  __REGISTER__(feature);
}
function featureRegistration(Component, feature) {
  return (0, import_react3.forwardRef)((props, ref) => {
    useFeatureRegistration(feature);
    return (0, import_jsx_runtime.jsx)(Component, { ...props, ref });
  });
}
function isFilterEmpty(filter) {
  if (filter["@type"] === "and" || filter["@type"] === "or") {
    if (filter.children.length === 0) {
      return true;
    }
    return filter.children.every((child) => isFilterEmpty(child));
  }
  if ("filterValue" in filter) {
    return filter.filterValue === "";
  }
  throw new Error(`Unknown filter type: ${"@type" in filter ? filter["@type"] : JSON.stringify(filter)} `);
}

// node_modules/@vaadin/hilla-react-crud/autogrid-renderers.js
import "@vaadin/vaadin-lumo-styles/vaadin-iconset.js";
function getColumnValue(context, item) {
  const path = context.propertyInfo.name;
  return path.split(".").reduce((obj, property) => obj ? obj[property] : void 0, item);
}
var fontVariantStyle = { fontVariantNumeric: "tabular-nums" };
function AutoGridIntegerRenderer({ item }) {
  const formatter = useLocaleFormatter();
  const context = (0, import_react4.useContext)(ColumnContext);
  return (0, import_jsx_runtime2.jsx)("span", { style: fontVariantStyle, children: formatter.formatInteger(getColumnValue(context, item)) });
}
function AutoGridDecimalRenderer({ item }) {
  const formatter = useLocaleFormatter();
  const context = (0, import_react4.useContext)(ColumnContext);
  return (0, import_jsx_runtime2.jsx)("span", { style: fontVariantStyle, children: formatter.formatDecimal(getColumnValue(context, item)) });
}
function AutoGridEnumRenderer({ item }) {
  const context = (0, import_react4.useContext)(ColumnContext);
  const value = getColumnValue(context, item) || "";
  return (0, import_jsx_runtime2.jsx)("span", { children: convertToTitleCase(value) });
}
function AutoGridBooleanRenderer({ item }) {
  const context = (0, import_react4.useContext)(ColumnContext);
  const value = getColumnValue(context, item);
  if (value) {
    return (0, import_jsx_runtime2.jsx)(m, { "aria-label": "false", icon: "lumo:checkmark" });
  }
  return (0, import_jsx_runtime2.jsx)(m, { "aria-label": "true", style: { color: "var(--lumo-secondary-text-color)" }, icon: "lumo:minus" });
}
function AutoGridDateRenderer({ item }) {
  const formatter = useLocaleFormatter();
  const context = (0, import_react4.useContext)(ColumnContext);
  return (0, import_jsx_runtime2.jsx)("span", { style: fontVariantStyle, children: formatter.formatDate(getColumnValue(context, item)) });
}
function AutoGridTimeRenderer({ item }) {
  const formatter = useLocaleFormatter();
  const context = (0, import_react4.useContext)(ColumnContext);
  return (0, import_jsx_runtime2.jsx)("span", { style: fontVariantStyle, children: formatter.formatLocalTime(getColumnValue(context, item)) });
}
function AutoGridDateTimeRenderer({ item }) {
  const formatter = useLocaleFormatter();
  const context = (0, import_react4.useContext)(ColumnContext);
  return (0, import_jsx_runtime2.jsx)("span", { style: fontVariantStyle, children: formatter.formatLocalDateTime(getColumnValue(context, item)) });
}
function AutoGridJsonRenderer({ item }) {
  const context = (0, import_react4.useContext)(ColumnContext);
  const value = getColumnValue(context, item);
  const jsonString = value ? JSON.stringify(value) : "";
  const jsonPreview = jsonString.length > 50 ? `${jsonString.substring(0, 50)}...` : jsonString;
  return (0, import_jsx_runtime2.jsx)("span", { children: jsonPreview });
}
function AutoGridRowNumberRenderer({ model }) {
  return (0, import_jsx_runtime2.jsx)(import_jsx_runtime2.Fragment, { children: model.index + 1 });
}
var FooterContext = (0, import_react4.createContext)(void 0);
function AutoGridFooterItemCountRenderer() {
  const footerContext = (0, import_react4.useContext)(FooterContext);
  const { totalCount, filteredCount, itemCounts, footerCountRenderer: FooterRenderer } = footerContext;
  if (FooterRenderer) {
    return (0, import_jsx_runtime2.jsx)(FooterRenderer, { ...itemCounts });
  }
  let filterCountText;
  if (filteredCount && (itemCounts == null ? void 0 : itemCounts.filteredCount) !== void 0) {
    filterCountText = totalCount && itemCounts.totalCount !== void 0 ? `Showing: ${itemCounts.filteredCount} out of ${itemCounts.totalCount}` : `Showing: ${itemCounts.filteredCount}`;
  } else if (totalCount && (itemCounts == null ? void 0 : itemCounts.totalCount) !== void 0) {
    filterCountText = `Total: ${itemCounts.totalCount}`;
  }
  if (filterCountText) {
    return (0, import_jsx_runtime2.jsx)("p", { children: filterCountText });
  }
  return (0, import_jsx_runtime2.jsx)(import_jsx_runtime2.Fragment, {});
}

// node_modules/@vaadin/hilla-react-crud/header-filter.js
var import_jsx_runtime3 = __toESM(require_jsx_runtime(), 1);
var import_react5 = __toESM(require_react(), 1);

// node_modules/@vaadin/hilla-react-crud/types/com/vaadin/hilla/crud/filter/PropertyStringFilter/Matcher.js
var Matcher = ((Matcher2) => {
  Matcher2["EQUALS"] = "EQUALS";
  Matcher2["CONTAINS"] = "CONTAINS";
  Matcher2["LESS_THAN"] = "LESS_THAN";
  Matcher2["GREATER_THAN"] = "GREATER_THAN";
  return Matcher2;
})(Matcher || {});
var Matcher_default = Matcher;

// node_modules/@vaadin/hilla-react-crud/header-filter.js
function useFilterState(initialMatcher) {
  const context = (0, import_react5.useContext)(ColumnContext);
  const [matcher, setMatcher] = (0, import_react5.useState)(initialMatcher);
  const [filterValue, setFilterValue] = (0, import_react5.useState)("");
  function updateFilter(newMatcher, newFilterValue) {
    setFilterValue(newFilterValue);
    setMatcher(newMatcher);
    const filter = {
      propertyId: context.propertyInfo.name,
      filterValue: newFilterValue,
      matcher: newMatcher,
      "@type": "propertyString"
    };
    context.setColumnFilter(filter, context.filterKey);
  }
  return { matcher, filterValue, updateFilter };
}
function useSelectInitWorkaround(selectRef) {
  (0, import_react5.useEffect)(() => {
    setTimeout(() => {
      if (selectRef.current) {
        selectRef.current.requestContentUpdate();
      }
    }, 1);
  }, []);
}
function ComparationSelection({ onMatcherChanged, value, isDateTimeType }) {
  const select = (0, import_react5.useRef)(null);
  useSelectInitWorkaround(select);
  return (0, import_jsx_runtime3.jsx)(
    O,
    {
      theme: "small",
      className: "auto-grid-comparation-selection",
      ref: select,
      value,
      onValueChanged: ({ detail }) => {
        onMatcherChanged(detail.value);
      },
      renderer: () => (0, import_jsx_runtime3.jsxs)(p, { children: [
        (0, import_jsx_runtime3.jsx)(n, { value: Matcher_default.GREATER_THAN, ...{ label: ">" }, children: isDateTimeType ? "> After" : "> Greater than" }),
        (0, import_jsx_runtime3.jsx)(n, { value: Matcher_default.LESS_THAN, ...{ label: "<" }, children: isDateTimeType ? "< Before" : "< Less than" }),
        (0, import_jsx_runtime3.jsx)(n, { value: Matcher_default.EQUALS, ...{ label: "=" }, children: "= Equals" })
      ] })
    }
  );
}
function StringHeaderFilter() {
  const context = (0, import_react5.useContext)(ColumnContext);
  const { filterPlaceholder, filterDebounceTime, filterMinLength } = context.customColumnOptions ?? {};
  const { updateFilter } = useFilterState(Matcher_default.CONTAINS);
  const [inputValue, setInputValue] = (0, import_react5.useState)("");
  (0, import_react5.useEffect)(() => {
    if (filterMinLength && inputValue && inputValue.length < filterMinLength) {
      updateFilter(Matcher_default.CONTAINS, "");
      return () => {
      };
    }
    const delayInputTimeoutId = setTimeout(() => {
      updateFilter(Matcher_default.CONTAINS, inputValue);
    }, filterDebounceTime ?? 200);
    return () => clearTimeout(delayInputTimeoutId);
  }, [inputValue]);
  return (0, import_jsx_runtime3.jsx)("div", { className: "auto-grid-string-filter", children: (0, import_jsx_runtime3.jsx)(
    p2,
    {
      theme: "small",
      placeholder: filterPlaceholder ?? "Filter...",
      onInput: (e2) => {
        const fieldValue = e2.target.value;
        setInputValue(fieldValue);
      }
    }
  ) });
}
function NumberHeaderFilter() {
  const context = (0, import_react5.useContext)(ColumnContext);
  const { filterPlaceholder, filterDebounceTime } = context.customColumnOptions ?? {};
  const [inputValue, setInputValue] = (0, import_react5.useState)("");
  const { matcher, filterValue, updateFilter } = useFilterState(Matcher_default.GREATER_THAN);
  const select = (0, import_react5.useRef)(null);
  useSelectInitWorkaround(select);
  (0, import_react5.useEffect)(() => {
    const delayInputTimeoutId = setTimeout(() => {
      updateFilter(matcher, inputValue);
    }, filterDebounceTime ?? 200);
    return () => clearTimeout(delayInputTimeoutId);
  }, [inputValue]);
  return (0, import_jsx_runtime3.jsxs)("div", { className: "auto-grid-number-filter", children: [
    (0, import_jsx_runtime3.jsx)(ComparationSelection, { value: matcher, onMatcherChanged: (m4) => updateFilter(m4, filterValue) }),
    (0, import_jsx_runtime3.jsx)(
      o,
      {
        theme: "small",
        placeholder: filterPlaceholder ?? "Filter...",
        onInput: (e2) => {
          const fieldValue = e2.target.value;
          setInputValue(fieldValue);
        }
      }
    )
  ] });
}
function EnumHeaderFilter() {
  const { filterValue, updateFilter } = useFilterState(Matcher_default.EQUALS);
  const context = (0, import_react5.useContext)(ColumnContext);
  const model = context.propertyInfo.model;
  const options = [
    {
      value: "",
      label: ""
    },
    ...Object.keys(model[_enum]).map((value) => ({
      label: convertToTitleCase(value),
      value
    }))
  ];
  return (0, import_jsx_runtime3.jsx)("div", { className: "auto-grid-enum-filter", children: (0, import_jsx_runtime3.jsx)(
    O,
    {
      theme: "small",
      items: options,
      value: filterValue,
      onValueChanged: (e2) => {
        const newFilterValue = e2.detail.value;
        updateFilter(Matcher_default.EQUALS, newFilterValue);
      }
    }
  ) });
}
function BooleanHeaderFilter() {
  const { filterValue, updateFilter } = useFilterState(Matcher_default.EQUALS);
  const select = (0, import_react5.useRef)(null);
  useSelectInitWorkaround(select);
  return (0, import_jsx_runtime3.jsx)("div", { className: "auto-grid-boolean-filter", children: (0, import_jsx_runtime3.jsx)(
    O,
    {
      theme: "small",
      ref: select,
      onValueChanged: (e2) => {
        const newFilterValue = e2.detail.value;
        updateFilter(Matcher_default.EQUALS, newFilterValue);
      },
      renderer: () => (0, import_jsx_runtime3.jsxs)(p, { children: [
        (0, import_jsx_runtime3.jsx)(n, { value: "", ...{ label: "" } }),
        (0, import_jsx_runtime3.jsx)(n, { value: "True", ...{ label: "Yes" }, children: "Yes" }),
        (0, import_jsx_runtime3.jsx)(n, { value: "False", ...{ label: "No" }, children: "No" })
      ] }),
      value: filterValue
    }
  ) });
}
function DateHeaderFilter() {
  var _a;
  const context = (0, import_react5.useContext)(ColumnContext);
  const i18n = useDatePickerI18n();
  const { matcher, filterValue, updateFilter } = useFilterState(Matcher_default.GREATER_THAN);
  const [invalid, setInvalid] = (0, import_react5.useState)(false);
  return (0, import_jsx_runtime3.jsxs)("div", { className: "auto-grid-date-filter", children: [
    (0, import_jsx_runtime3.jsx)(
      ComparationSelection,
      {
        value: matcher,
        onMatcherChanged: (m4) => updateFilter(m4, filterValue),
        isDateTimeType: true
      }
    ),
    (0, import_jsx_runtime3.jsx)(
      r,
      {
        theme: "small",
        value: filterValue,
        placeholder: ((_a = context.customColumnOptions) == null ? void 0 : _a.filterPlaceholder) ?? "Filter...",
        i18n,
        onInvalidChanged: ({ detail: { value } }) => {
          setInvalid(value);
        },
        onValueChanged: ({ detail: { value } }) => {
          if (!(invalid || value === filterValue)) {
            updateFilter(matcher, value);
          }
        }
      }
    )
  ] });
}
function TimeHeaderFilter() {
  var _a;
  const context = (0, import_react5.useContext)(ColumnContext);
  const { matcher, filterValue, updateFilter } = useFilterState(Matcher_default.GREATER_THAN);
  const [invalid, setInvalid] = (0, import_react5.useState)(false);
  return (0, import_jsx_runtime3.jsxs)("div", { className: "auto-grid-time-filter", children: [
    (0, import_jsx_runtime3.jsx)(
      ComparationSelection,
      {
        value: matcher,
        onMatcherChanged: (m4) => updateFilter(m4, filterValue),
        isDateTimeType: true
      }
    ),
    (0, import_jsx_runtime3.jsx)(
      k2,
      {
        theme: "small",
        value: filterValue,
        placeholder: ((_a = context.customColumnOptions) == null ? void 0 : _a.filterPlaceholder) ?? "Filter...",
        onInvalidChanged: ({ detail: { value } }) => {
          setInvalid(value);
        },
        onValueChanged: ({ detail: { value } }) => {
          if (!(invalid || value === filterValue)) {
            updateFilter(matcher, value);
          }
        }
      }
    )
  ] });
}
function NoHeaderFilter() {
  return (0, import_jsx_runtime3.jsx)(import_jsx_runtime3.Fragment, {});
}
function HeaderFilterWrapper({ original }) {
  const context = (0, import_react5.useContext)(ColumnContext);
  const customContext = (0, import_react5.useContext)(CustomColumnContext);
  const { setColumnFilter, headerFilterRenderer: HeaderFilterRenderer, filterKey } = context ?? customContext;
  function setFilter(filter) {
    setColumnFilter(filter, filterKey);
  }
  return (0, import_jsx_runtime3.jsx)(HeaderFilterRenderer, { original, setFilter });
}

// node_modules/@vaadin/hilla-react-crud/autogrid-columns.js
function getTypeColumnOptions(propertyInfo, customColumnOptions) {
  switch (propertyInfo.type) {
    case "integer":
      return {
        autoWidth: true,
        textAlign: "end",
        flexGrow: 0,
        renderer: AutoGridIntegerRenderer,
        headerFilterRenderer: NumberHeaderFilter
      };
    case "decimal":
      return {
        autoWidth: true,
        textAlign: "end",
        flexGrow: 0,
        renderer: AutoGridDecimalRenderer,
        headerFilterRenderer: NumberHeaderFilter
      };
    case "boolean":
      return {
        autoWidth: true,
        textAlign: "end",
        flexGrow: 0,
        renderer: AutoGridBooleanRenderer,
        headerFilterRenderer: BooleanHeaderFilter
      };
    case "date":
      return {
        autoWidth: true,
        textAlign: "end",
        flexGrow: 0,
        renderer: AutoGridDateRenderer,
        headerFilterRenderer: DateHeaderFilter
      };
    case "time":
      return {
        autoWidth: true,
        textAlign: "end",
        flexGrow: 0,
        renderer: AutoGridTimeRenderer,
        headerFilterRenderer: TimeHeaderFilter
      };
    case "datetime":
      return {
        autoWidth: true,
        textAlign: "end",
        flexGrow: 0,
        renderer: AutoGridDateTimeRenderer,
        headerFilterRenderer: DateHeaderFilter
      };
    case "enum":
      return {
        autoWidth: true,
        renderer: AutoGridEnumRenderer,
        headerFilterRenderer: EnumHeaderFilter
      };
    case "string":
      return {
        autoWidth: true,
        headerFilterRenderer: StringHeaderFilter
      };
    case "object":
      return {
        autoWidth: true,
        renderer: (customColumnOptions == null ? void 0 : customColumnOptions.path) !== void 0 && customColumnOptions.renderer == null ? null : AutoGridJsonRenderer,
        headerFilterRenderer: NoHeaderFilter
      };
    default:
      return {
        autoWidth: true,
        headerFilterRenderer: NoHeaderFilter
      };
  }
}
function getColumnOptions(propertyInfo, customColumnOptions) {
  const typeColumnOptions = getTypeColumnOptions(propertyInfo, customColumnOptions);
  const headerFilterRenderer = (customColumnOptions == null ? void 0 : customColumnOptions.filterable) === false ? NoHeaderFilter : typeColumnOptions.headerFilterRenderer ?? NoHeaderFilter;
  return customColumnOptions ? { ...typeColumnOptions, headerFilterRenderer, ...customColumnOptions } : typeColumnOptions;
}

// node_modules/@vaadin/hilla-react-crud/autogrid.obj.js
var css = new CSSStyleSheet();
css.replaceSync(`.auto-grid-comparation-selection{--vaadin-field-default-width:2em}.auto-grid-comparation-selection>vaadin-select-value-button{--_lumo-text-field-overflow-mask-image:none!important;color:var(--lumo-secondary-text-color)}.auto-grid-comparation-selection::part(toggle-button){display:none}.auto-grid-string-filter{display:flex}.auto-grid-string-filter vaadin-text-field{flex:1 1 0;width:100px}.auto-grid-boolean-filter{display:flex}.auto-grid-boolean-filter vaadin-select{flex:1 1 0;width:80px}.auto-grid-boolean-filter vaadin-select-item{font-size:14px}.auto-grid-number-filter{display:flex}.auto-grid-number-filter vaadin-number-field{flex:1 1 0;width:100px}.auto-grid-number-filter vaadin-select::part(input-field){border-bottom-right-radius:0;border-top-right-radius:0}.auto-grid-number-filter vaadin-number-field::part(input-field){border-bottom-left-radius:0;border-top-left-radius:0}.auto-grid-enum-filter{display:flex}.auto-grid-enum-filter vaadin-select{flex:1 1 0;width:120px}.auto-grid-enum-filter vaadin-select-item{font-size:14px}.auto-grid-date-filter{display:flex}.auto-grid-date-filter vaadin-date-picker{flex:1 1 0;width:120px}.auto-grid-date-filter vaadin-select::part(input-field){border-bottom-right-radius:0;border-top-right-radius:0}.auto-grid-date-filter vaadin-date-picker::part(input-field){border-bottom-left-radius:0;border-top-left-radius:0}.auto-grid-time-filter{display:flex}.auto-grid-time-filter vaadin-time-picker{flex:1 1 0;width:100px}.auto-grid-time-filter vaadin-select::part(input-field){border-bottom-right-radius:0;border-top-right-radius:0}.auto-grid-time-filter vaadin-time-picker::part(input-field){border-bottom-left-radius:0;border-top-left-radius:0}`);

// node_modules/@vaadin/hilla-react-crud/data-provider.js
var import_react6 = __toESM(require_react(), 1);

// node_modules/@vaadin/hilla-react-crud/types/org/springframework/data/domain/Sort/Direction.js
var Direction = ((Direction2) => {
  Direction2["ASC"] = "ASC";
  Direction2["DESC"] = "DESC";
  return Direction2;
})(Direction || {});
var Direction_default = Direction;

// node_modules/@vaadin/hilla-react-crud/data-provider.js
function createSort(params) {
  return {
    orders: params.sortOrders.filter((order) => order.direction != null).map((order) => ({
      property: order.path,
      direction: order.direction === "asc" ? Direction_default.ASC : Direction_default.DESC,
      ignoreCase: false
    }))
  };
}
function isCountService(service) {
  return !!service.count;
}
var DataProvider = class {
  constructor(service, options = {}) {
    __publicField(this, "service");
    __publicField(this, "loadTotalCount");
    __publicField(this, "afterLoadCallback");
    __publicField(this, "filter");
    __publicField(this, "totalCount");
    __publicField(this, "filteredCount");
    this.service = service;
    this.filter = options.initialFilter;
    this.loadTotalCount = options.loadTotalCount;
    this.afterLoadCallback = options.afterLoad;
    this.load = this.load.bind(this);
  }
  reset() {
    this.totalCount = void 0;
    this.filteredCount = void 0;
  }
  setFilter(filter) {
    this.reset();
    this.filter = filter;
  }
  async load(params, callback) {
    const page = await this.fetchPage(params);
    this.filteredCount = await this.fetchFilteredCount(page);
    if (this.loadTotalCount) {
      this.totalCount = await this.fetchTotalCount(page);
    }
    callback(page.items, this.filteredCount);
    if (this.afterLoadCallback) {
      this.afterLoadCallback({
        totalCount: this.totalCount,
        filteredCount: this.filteredCount
      });
    }
  }
  async fetchPage(params) {
    const sort = createSort(params);
    const pageNumber = params.page;
    const { pageSize } = params;
    const pageRequest = {
      pageNumber,
      pageSize,
      sort
    };
    const items = await this.service.list(pageRequest, this.filter);
    return { items, pageRequest };
  }
};
var InfiniteDataProvider = class extends DataProvider {
  // cannot be static, otherwise it does not implement superclass
  // eslint-disable-next-line @typescript-eslint/class-methods-use-this
  fetchTotalCount() {
    return void 0;
  }
  fetchFilteredCount(page) {
    const { items, pageRequest } = page;
    const { pageNumber, pageSize } = pageRequest;
    let infiniteScrollingSize;
    if (items.length === pageSize) {
      infiniteScrollingSize = (pageNumber + 1) * pageSize + 1;
      if (this.filteredCount !== void 0 && infiniteScrollingSize < this.filteredCount) {
        infiniteScrollingSize = this.filteredCount;
      }
    } else {
      infiniteScrollingSize = pageNumber * pageSize + items.length;
    }
    return infiniteScrollingSize;
  }
};
var FixedSizeDataProvider = class extends DataProvider {
  constructor(service, options = {}) {
    if (!isCountService(service)) {
      throw new Error("The provided service does not implement the CountService interface.");
    }
    super(service, options);
  }
  async fetchTotalCount() {
    if (this.totalCount !== void 0) {
      return this.totalCount;
    }
    return this.service.count(void 0);
  }
  async fetchFilteredCount() {
    if (this.filteredCount !== void 0) {
      return this.filteredCount;
    }
    return this.service.count(this.filter);
  }
};
function createDataProvider(service, options = {}) {
  if (isCountService(service)) {
    return new FixedSizeDataProvider(service, options);
  }
  return new InfiniteDataProvider(service, options);
}
function useDataProvider(service, filter) {
  const [refreshCounter, setRefreshCounter] = (0, import_react6.useState)(0);
  const dataProvider = (0, import_react6.useMemo)(() => createDataProvider(service, { initialFilter: filter }), [service]);
  dataProvider.setFilter(filter);
  const dataProviderFn = (0, import_react6.useMemo)(() => dataProvider.load.bind(dataProvider), [dataProvider, filter, refreshCounter]);
  return {
    // eslint-disable-next-line @typescript-eslint/no-misused-promises
    dataProvider: dataProviderFn,
    refresh: () => {
      dataProvider.reset();
      setRefreshCounter(refreshCounter + 1);
    }
  };
}

// node_modules/@vaadin/hilla-react-crud/header-sorter.js
var import_jsx_runtime4 = __toESM(require_jsx_runtime(), 1);
var import_react7 = __toESM(require_react(), 1);
function HeaderSorter() {
  var _a, _b;
  const context = (0, import_react7.useContext)(ColumnContext);
  const sorterState = context.sortState[context.propertyInfo.name];
  const direction = (sorterState == null ? void 0 : sorterState.direction) ?? null;
  const headerLabel = ((_a = context.customColumnOptions) == null ? void 0 : _a.header) ?? context.propertyInfo.humanReadableName;
  return ((_b = context.customColumnOptions) == null ? void 0 : _b.sortable) === false ? (0, import_jsx_runtime4.jsx)(import_jsx_runtime4.Fragment, { children: headerLabel }) : (0, import_jsx_runtime4.jsx)(
    a,
    {
      path: context.propertyInfo.name,
      direction,
      onDirectionChanged: (e2) => {
        context.setSortState((prevState) => {
          const newSorterState = e2.detail.value ? { direction: e2.detail.value } : void 0;
          return { ...prevState, [context.propertyInfo.name]: newSorterState };
        });
      },
      children: headerLabel
    }
  );
}

// node_modules/@vaadin/hilla-react-crud/model-info.js
var javaTypeMap = {
  byte: "integer",
  "java.lang.Byte": "integer",
  short: "integer",
  "java.lang.Short": "integer",
  int: "integer",
  "java.lang.Integer": "integer",
  long: "integer",
  "java.lang.Long": "integer",
  float: "decimal",
  "java.lang.Float": "decimal",
  double: "decimal",
  "java.lang.Double": "decimal",
  "java.time.LocalDate": "date",
  "java.time.LocalTime": "time",
  "java.time.OffsetTime": "time",
  "java.time.LocalDateTime": "datetime",
  "java.time.OffsetDateTime": "datetime",
  "java.time.ZonedDateTime": "datetime",
  "java.util.Date": "datetime",
  "java.sql.Date": "datetime"
};
function determinePropertyType(model) {
  const { javaType } = model[_meta];
  const propertyType = javaType ? javaTypeMap[javaType] : void 0;
  if (propertyType) {
    return propertyType;
  }
  if (model instanceof StringModel) {
    return "string";
  } else if (model instanceof NumberModel) {
    return "decimal";
  } else if (model instanceof BooleanModel) {
    return "boolean";
  } else if (model instanceof EnumModel) {
    return "enum";
  } else if (model instanceof ObjectModel) {
    return "object";
  }
  return void 0;
}
function hasAnnotation(meta, annotationName) {
  var _a;
  return ((_a = meta.annotations) == null ? void 0 : _a.some((annotation) => annotation.name === annotationName)) ?? false;
}
function _generateHeader(path) {
  return path.substring(path.lastIndexOf(".") + 1).replace(/([A-Z])/gu, "-$1").toLowerCase().replace(/-/gu, " ").replace(/^./u, (match) => match.toUpperCase());
}
var getPropertyNames = (model) => {
  const propertyNames = [];
  for (let proto = model; proto !== ObjectModel; proto = Object.getPrototypeOf(proto)) {
    propertyNames.unshift(...Object.keys(Object.getOwnPropertyDescriptors(proto.prototype)).filter((p5) => p5 !== "new"));
  }
  return propertyNames;
};
var ModelInfo = class _ModelInfo {
  constructor(model, idPropertyName) {
    __publicField(this, "modelInstance");
    __publicField(this, "idProperty");
    this.modelInstance = createDetachedModel(model);
    this.idProperty = _ModelInfo.resolveIdProperty(this, idPropertyName);
  }
  static resolveIdProperty(modelInfo, idPropertyName) {
    if (idPropertyName) {
      return modelInfo.getProperty(idPropertyName);
    }
    const rootProperties = modelInfo.getRootProperties();
    let idProperty = rootProperties.find((propertyInfo) => hasAnnotation(propertyInfo.meta, "jakarta.persistence.Id"));
    if (!idProperty) {
      idProperty = rootProperties.find((propertyInfo) => propertyInfo.name === "id");
    }
    return idProperty;
  }
  static resolvePropertyModel(modelInstance, path) {
    const parts = path.split(".");
    let currentModel = modelInstance;
    for (const part of parts) {
      if (!currentModel || !(currentModel instanceof ObjectModel)) {
        return void 0;
      }
      currentModel = currentModel[part];
    }
    return currentModel;
  }
  getRootProperties(path) {
    const model = path ? _ModelInfo.resolvePropertyModel(this.modelInstance, path) : this.modelInstance;
    if (!model) {
      return [];
    }
    return getPropertyNames(model.constructor).map((name) => {
      const effectivePath = path ? `${path}.${name}` : name;
      return this.getProperty(effectivePath);
    }).filter(Boolean);
  }
  getProperty(path) {
    const propertyModel = _ModelInfo.resolvePropertyModel(this.modelInstance, path);
    if (!(propertyModel == null ? void 0 : propertyModel[_meta])) {
      return void 0;
    }
    const pathParts = path.split(".");
    const name = pathParts[pathParts.length - 1];
    const meta = propertyModel[_meta];
    const humanReadableName = _generateHeader(name);
    const type = determinePropertyType(propertyModel);
    return {
      name: path,
      humanReadableName,
      type,
      meta,
      model: propertyModel
    };
  }
  getProperties(paths) {
    return paths.map((path) => this.getProperty(path)).filter(Boolean);
  }
};
function getDefaultProperties(modelInfo) {
  const properties = modelInfo.getRootProperties();
  return properties.flatMap((prop) => {
    if (hasAnnotation(prop.meta, "jakarta.persistence.OneToOne")) {
      return modelInfo.getRootProperties(prop.name);
    }
    return prop;
  }).filter(
    (prop) => !!prop.type && !(hasAnnotation(prop.meta, "jakarta.persistence.Id") || hasAnnotation(prop.meta, "jakarta.persistence.Version"))
  );
}

// node_modules/@vaadin/hilla-react-crud/autogrid.js
registerStylesheet(css);
function wrapCustomColumn(column, setColumnFilter, options) {
  var _a;
  const key = column.key ?? "no-key";
  const { header, headerRenderer } = column.props;
  const customOptions = (_a = options.columnOptions) == null ? void 0 : _a[key];
  const { header: customHeader, headerRenderer: customHeaderRenderer, headerFilterRenderer } = customOptions ?? {};
  const columnWithoutHeader = (0, import_react8.cloneElement)(column, {
    header: null,
    headerRenderer: HeaderFilterWrapper
  });
  return (0, import_jsx_runtime5.jsx)(
    CustomColumnContext.Provider,
    {
      value: {
        setColumnFilter,
        headerFilterRenderer: headerFilterRenderer ?? NoHeaderFilter,
        filterKey: key
      },
      children: (0, import_jsx_runtime5.jsx)(
        v,
        {
          header: customHeader ?? header,
          headerRenderer: customHeaderRenderer ?? headerRenderer,
          children: columnWithoutHeader
        },
        key
      )
    },
    key
  );
}
function addCustomColumns(columns, options, setColumnFilter) {
  if (!options.customColumns) {
    return columns;
  }
  const customColumns = options.noHeaderFilters ? options.customColumns : options.customColumns.map((column) => wrapCustomColumn(column, setColumnFilter, options));
  if (options.visibleColumns) {
    const columnMap = [...columns, ...customColumns].reduce((map, column) => {
      const { key } = column;
      if (key) {
        map.set(key, column);
      }
      return map;
    }, /* @__PURE__ */ new Map());
    return options.visibleColumns.map((path) => columnMap.get(path)).filter(Boolean);
  }
  return [...columns, ...customColumns];
}
function useColumns(properties, setColumnFilter, options) {
  const sortableProperties = properties.filter(
    (propertyInfo) => {
      var _a, _b;
      return ((_b = (_a = options.columnOptions) == null ? void 0 : _a[propertyInfo.name]) == null ? void 0 : _b.sortable) !== false;
    }
  );
  const [sortState, setSortState] = (0, import_react8.useState)(
    sortableProperties.length > 0 ? { [sortableProperties[0].name]: { direction: "asc" } } : {}
  );
  let columns = properties.map((propertyInfo) => {
    var _a;
    let column;
    const customColumnOptions = (_a = options.columnOptions) == null ? void 0 : _a[propertyInfo.name];
    const { headerFilterRenderer, ...columnProps } = getColumnOptions(propertyInfo, customColumnOptions);
    if (!options.noHeaderFilters) {
      column = (0, import_jsx_runtime5.jsx)(v, { headerRenderer: HeaderSorter, children: (0, import_jsx_runtime5.jsx)(A, { path: propertyInfo.name, headerRenderer: HeaderFilterWrapper, ...columnProps }) });
    } else {
      column = (0, import_jsx_runtime5.jsx)(A, { path: propertyInfo.name, headerRenderer: HeaderSorter, ...columnProps });
    }
    return (0, import_jsx_runtime5.jsx)(
      ColumnContext.Provider,
      {
        value: {
          propertyInfo,
          setColumnFilter,
          sortState,
          setSortState,
          customColumnOptions,
          headerFilterRenderer: headerFilterRenderer ?? NoHeaderFilter,
          filterKey: propertyInfo.name
        },
        children: column
      },
      propertyInfo.name
    );
  });
  columns = addCustomColumns(columns, options, setColumnFilter);
  if (options.hiddenColumns) {
    columns = columns.filter(({ key }) => {
      var _a;
      return !(key && ((_a = options.hiddenColumns) == null ? void 0 : _a.includes(key)));
    });
  }
  if (options.rowNumbers) {
    columns = [
      (0, import_jsx_runtime5.jsx)(A, { width: "4em", flexGrow: 0, renderer: AutoGridRowNumberRenderer }, "rownumbers"),
      ...columns
    ];
  }
  const { totalCount, filteredCount, itemCounts, footerCountRenderer } = options;
  if (totalCount ?? filteredCount) {
    const col = (0, import_jsx_runtime5.jsx)(
      FooterContext.Provider,
      {
        value: {
          totalCount,
          filteredCount,
          footerCountRenderer,
          itemCounts
        },
        children: (0, import_jsx_runtime5.jsx)(v, { footerRenderer: AutoGridFooterItemCountRenderer, children: columns })
      },
      "grid-footer"
    );
    columns = [col];
  }
  return columns;
}
function AutoGridInner({
  service,
  model,
  itemIdProperty,
  experimentalFilter,
  visibleColumns,
  hiddenColumns,
  noHeaderFilters,
  customColumns,
  columnOptions,
  rowNumbers,
  totalCount,
  filteredCount,
  footerCountRenderer,
  ...gridProps
}, ref) {
  var _a;
  const [internalFilter, setInternalFilter] = (0, import_react8.useState)({ "@type": "and", children: [] });
  const [itemCounts, setItemCounts] = (0, import_react8.useState)();
  const gridRef = (0, import_react8.useRef)(null);
  const dataProviderRef = (0, import_react8.useRef)();
  (0, import_react8.useImperativeHandle)(
    ref,
    () => ({
      get grid() {
        return gridRef.current;
      },
      refresh() {
        var _a2, _b;
        (_a2 = dataProviderRef.current) == null ? void 0 : _a2.reset();
        (_b = gridRef.current) == null ? void 0 : _b.clearCache();
      }
    }),
    []
  );
  const setHeaderFilter = (filter, filterKey) => {
    let changed = false;
    filter.key = filterKey;
    const indexOfFilter = filterKey ? internalFilter.children.findIndex((f2) => f2.key === filterKey) : -1;
    const isEmptyFilter = isFilterEmpty(filter);
    if (indexOfFilter >= 0 && isEmptyFilter) {
      internalFilter.children.splice(indexOfFilter, 1);
      changed = true;
    } else if (!isEmptyFilter) {
      if (indexOfFilter >= 0) {
        internalFilter.children[indexOfFilter] = filter;
        changed = true;
      } else {
        internalFilter.children.push(filter);
        changed = true;
      }
    }
    if (changed) {
      setInternalFilter({ ...internalFilter });
    }
  };
  const modelInfo = (0, import_react8.useMemo)(() => new ModelInfo(model, itemIdProperty), [model]);
  const properties = visibleColumns ? modelInfo.getProperties(visibleColumns) : getDefaultProperties(modelInfo);
  const children = useColumns(properties, setHeaderFilter, {
    visibleColumns,
    hiddenColumns,
    noHeaderFilters,
    customColumns,
    columnOptions,
    rowNumbers,
    totalCount,
    filteredCount,
    footerCountRenderer,
    itemCounts
  });
  (0, import_react8.useEffect)(() => {
    if (noHeaderFilters) {
      setInternalFilter({ "@type": "and", children: [] });
    }
  }, [noHeaderFilters]);
  (0, import_react8.useEffect)(() => {
    if ((!isCountService(service) && totalCount) ?? filteredCount) {
      console.error(
        '"totalCount" and "filteredCount" props require the provided service to implement the CountService interface.'
      );
    }
    const grid = gridRef.current;
    const timeoutId = setTimeout(() => {
      let firstUpdate = true;
      const dataProvider = createDataProvider(service, {
        initialFilter: experimentalFilter ?? internalFilter,
        loadTotalCount: totalCount,
        afterLoad(newItemCounts) {
          setItemCounts(newItemCounts);
          if (firstUpdate) {
            firstUpdate = false;
            setTimeout(() => grid.recalculateColumnWidths(), 0);
          }
        }
      });
      dataProviderRef.current = dataProvider;
      gridRef.current.dataProvider = dataProvider.load.bind(dataProvider);
    }, 1);
    return () => clearTimeout(timeoutId);
  }, [model, service]);
  (0, import_react8.useEffect)(() => {
    const dataProvider = dataProviderRef.current;
    const grid = gridRef.current;
    if (grid && dataProvider) {
      dataProvider.setFilter(experimentalFilter ?? internalFilter);
      grid.clearCache();
    }
  }, [experimentalFilter, internalFilter]);
  return (0, import_jsx_runtime5.jsx)(C, { itemIdPath: (_a = modelInfo.idProperty) == null ? void 0 : _a.name, ...gridProps, ref: gridRef, children });
}
var AutoGrid = (0, import_react8.forwardRef)(AutoGridInner);

// node_modules/@vaadin/hilla-react-crud/autogrid-feature.js
var AutoGrid2 = featureRegistration(AutoGrid, "AutoGrid");

// node_modules/@vaadin/hilla-react-crud/autoform.js
var import_jsx_runtime7 = __toESM(require_jsx_runtime(), 1);

// node_modules/@vaadin/hilla-react-form/index.js
var import_react9 = __toESM(require_react());
function __REGISTER__2(feature, vaadinObj = window.Vaadin ?? (window.Vaadin = {})) {
  vaadinObj.registrations ?? (vaadinObj.registrations = []);
  vaadinObj.registrations.push({
    is: feature ? `${"@vaadin/hilla-react-form"}/${feature}` : "@vaadin/hilla-react-form",
    version: "24.5.5"
  });
}
__REGISTER__2();
var isRendering = false;
function useUpdate() {
  const [_, count] = (0, import_react9.useReducer)((x) => x + 1, 0);
  return () => {
    if (isRendering) {
      return;
    }
    count();
  };
}
function convertFieldValue(model, fieldValue) {
  return typeof fieldValue === "string" && hasFromString(model) ? model[_fromString](fieldValue) : fieldValue;
}
function getFormPart(node) {
  return {
    addValidator: node.addValidator.bind(node),
    get defaultValue() {
      return node.defaultValue;
    },
    dirty: node.dirty,
    errors: node.errors,
    invalid: node.invalid,
    model: node.model,
    name: node.name,
    ownErrors: node.ownErrors,
    required: node.required,
    setValidators(validators) {
      node.validators = validators;
    },
    setValue(value) {
      node.value = value;
    },
    setVisited(visited) {
      node.visited = visited;
    },
    validate: node.validate.bind(node),
    validators: node.validators,
    get value() {
      return node.value;
    },
    visited: node.visited
  };
}
function useFields(node) {
  const update = useUpdate();
  return (0, import_react9.useMemo)(() => {
    const registry = /* @__PURE__ */ new WeakMap();
    return (model) => {
      isRendering = true;
      const n3 = getBinderNode(model);
      let fieldState = registry.get(model);
      if (!fieldState) {
        fieldState = {
          element: void 0,
          errorMessage: "",
          invalid: false,
          changeBlurHandler() {
            fieldState.updateValue();
            fieldState.markVisited();
          },
          markVisited() {
            n3.visited = true;
          },
          ref(element) {
            var _a, _b, _c, _d;
            if (!element) {
              (_a = fieldState.element) == null ? void 0 : _a.removeEventListener("change", fieldState.changeBlurHandler);
              (_b = fieldState.element) == null ? void 0 : _b.removeEventListener("input", fieldState.updateValue);
              (_c = fieldState.element) == null ? void 0 : _c.removeEventListener("blur", fieldState.changeBlurHandler);
              (_d = fieldState.strategy) == null ? void 0 : _d.removeEventListeners();
              fieldState.element = void 0;
              fieldState.strategy = void 0;
              update();
              return;
            }
            if (!isFieldElement(element)) {
              throw new TypeError(`Element '${element.localName}' is not a form element`);
            }
            if (fieldState.element !== element) {
              fieldState.element = element;
              fieldState.element.addEventListener("change", fieldState.changeBlurHandler);
              fieldState.element.addEventListener("input", fieldState.updateValue);
              fieldState.element.addEventListener("blur", fieldState.changeBlurHandler);
              fieldState.strategy = getDefaultFieldStrategy(element, model);
              update();
            }
          },
          required: false,
          strategy: void 0,
          updateValue() {
            if (fieldState.strategy) {
              fieldState.strategy.invalid = false;
              fieldState.strategy.checkValidity();
              n3[_validity] = fieldState.strategy.validity;
              n3.value = convertFieldValue(model, fieldState.strategy.value);
            }
          }
        };
        registry.set(model, fieldState);
      }
      if (fieldState.strategy) {
        const valueFromField = convertFieldValue(model, fieldState.strategy.value);
        if (valueFromField !== n3.value && !(Number.isNaN(n3.value) && Number.isNaN(valueFromField))) {
          fieldState.strategy.value = Number.isNaN(n3.value) ? "" : n3.value;
        }
        if (fieldState.required !== n3.required) {
          fieldState.required = n3.required;
          fieldState.strategy.required = n3.required;
        }
        const firstError = n3.ownErrors.at(0);
        const errorMessage = (firstError == null ? void 0 : firstError.message) ?? "";
        if (fieldState.errorMessage !== errorMessage) {
          fieldState.errorMessage = errorMessage;
          fieldState.strategy.errorMessage = errorMessage;
        }
        fieldState.invalid = n3.invalid;
        fieldState.strategy.invalid = n3.invalid;
      }
      isRendering = false;
      return {
        name: n3.name,
        ref: fieldState.ref
      };
    };
  }, [node]);
}
function useForm(Model, config) {
  const configRef = (0, import_react9.useRef)({});
  configRef.current.onSubmit = config == null ? void 0 : config.onSubmit;
  configRef.current.onChange = config == null ? void 0 : config.onChange;
  const update = useUpdate();
  const binder = (0, import_react9.useMemo)(() => new BinderRoot(Model, configRef.current), [Model]);
  const field = useFields(binder);
  const clear = binder.clear.bind(binder);
  (0, import_react9.useEffect)(() => {
    binder.addEventListener(CHANGED.type, update);
    clear();
    return () => binder.removeEventListener(CHANGED.type, update);
  }, [binder]);
  return {
    ...getFormPart(binder),
    clear,
    field,
    read: binder.read.bind(binder),
    reset: binder.reset.bind(binder),
    setDefaultValue(defaultValue) {
      binder.defaultValue = defaultValue;
    },
    setValue(value) {
      binder.value = value;
    },
    submit: binder.submit.bind(binder),
    value: binder.value,
    submitting: binder.submitting,
    update
  };
}
function useFormPart(model) {
  isRendering = true;
  const binderNode = getBinderNode(model);
  const field = useFields(binderNode);
  isRendering = false;
  return {
    ...getFormPart(binderNode),
    field
  };
}

// node_modules/@vaadin/hilla-react-crud/autoform.js
var import_react11 = __toESM(require_react(), 1);

// node_modules/@vaadin/hilla-react-crud/autoform-field.js
var import_jsx_runtime6 = __toESM(require_jsx_runtime(), 1);
var import_react10 = __toESM(require_react(), 1);
function getPropertyModel(form, propertyInfo) {
  const pathParts = propertyInfo.name.split(".");
  return pathParts.reduce((model, property) => model ? model[property] : void 0, form.model);
}
function renderFieldElement(defaultComponentType, { element, field, fieldProps }, additionalProps = {}) {
  const fieldElement = element ?? (0, import_react10.createElement)(defaultComponentType);
  return (0, import_react10.cloneElement)(fieldElement, { ...fieldProps, ...additionalProps, ...fieldElement.props, ...field });
}
function AutoFormTextField(props) {
  return renderFieldElement(p2, props);
}
function AutoFormIntegerField(props) {
  return renderFieldElement(r2, props);
}
function AutoFormDecimalField(props) {
  return renderFieldElement(o, props);
}
function AutoFormDateField(props) {
  const i18n = useDatePickerI18n();
  return renderFieldElement(r, props, { i18n });
}
function AutoFormTimeField(props) {
  return renderFieldElement(k2, props);
}
function AutoFormDateTimeField(props) {
  const i18n = useDateTimePickerI18n();
  return renderFieldElement(k, props, { i18n });
}
function AutoFormEnumField(props) {
  const enumModel = props.model;
  const items = Object.keys(enumModel[_enum]).map((value) => ({
    label: convertToTitleCase(value),
    value
  }));
  return renderFieldElement(O, props, { items });
}
function AutoFormBooleanField(props) {
  return renderFieldElement(h, props);
}
function AutoFormObjectField({ model, fieldProps }) {
  const part = useFormPart(model);
  const jsonString = part.value ? JSON.stringify(part.value) : "";
  return (0, import_jsx_runtime6.jsx)(p4, { ...fieldProps, value: jsonString, readonly: true });
}
function AutoFormField(props) {
  const { form, propertyInfo, options } = props;
  const label = options.label ?? propertyInfo.humanReadableName;
  const model = getPropertyModel(form, propertyInfo);
  const field = form.field(model);
  const formPart = useFormPart(model);
  const defaultValidators = (0, import_react10.useMemo)(() => formPart.validators, []);
  const { validators } = options;
  (0, import_react10.useEffect)(() => {
    formPart.setValidators([...defaultValidators, ...validators ?? []]);
  }, [validators]);
  if (options.renderer) {
    const customFieldProps = { ...field, disabled: props.disabled, label };
    return options.renderer({ field: customFieldProps });
  }
  const fieldProps = {
    id: options.id,
    className: options.className,
    style: options.style,
    label,
    placeholder: options.placeholder,
    helperText: options.helperText,
    colspan: options.colspan,
    disabled: options.disabled ?? props.disabled,
    readonly: options.readonly
  };
  const rendererProps = { model, field, element: options.element, fieldProps };
  switch (props.propertyInfo.type) {
    case "string":
      return (0, import_jsx_runtime6.jsx)(AutoFormTextField, { ...rendererProps });
    case "integer":
      return (0, import_jsx_runtime6.jsx)(AutoFormIntegerField, { ...rendererProps });
    case "decimal":
      return (0, import_jsx_runtime6.jsx)(AutoFormDecimalField, { ...rendererProps });
    case "date":
      return (0, import_jsx_runtime6.jsx)(AutoFormDateField, { ...rendererProps });
    case "time":
      return (0, import_jsx_runtime6.jsx)(AutoFormTimeField, { ...rendererProps });
    case "datetime":
      return (0, import_jsx_runtime6.jsx)(AutoFormDateTimeField, { ...rendererProps });
    case "enum":
      return (0, import_jsx_runtime6.jsx)(AutoFormEnumField, { ...rendererProps });
    case "boolean":
      return (0, import_jsx_runtime6.jsx)(AutoFormBooleanField, { ...rendererProps });
    case "object":
      return (0, import_jsx_runtime6.jsx)(AutoFormObjectField, { ...rendererProps });
    default:
      return null;
  }
}

// node_modules/@vaadin/hilla-react-crud/autoform.obj.js
var css2 = new CSSStyleSheet();
css2.replaceSync(`.auto-form{display:flex;flex-direction:column;gap:var(--lumo-space-m)}.auto-form-toolbar{align-items:center;display:flex;flex-direction:row-reverse;gap:var(--lumo-space-xs) var(--lumo-space-s);justify-content:flex-start}.auto-form-delete-button{margin-right:auto}`);

// node_modules/@vaadin/hilla-react-crud/autoform.js
registerStylesheet(css2);
var emptyItem = Symbol();
function AutoForm({
  service,
  model,
  itemIdProperty,
  item = emptyItem,
  onSubmitError,
  onSubmitSuccess,
  disabled,
  layoutRenderer: LayoutRenderer,
  visibleFields,
  hiddenFields,
  formLayoutProps,
  fieldOptions,
  style,
  id,
  className,
  deleteButtonVisible,
  onDeleteSuccess,
  onDeleteError
}) {
  const form = useForm(model, {
    onSubmit: async (formItem) => service.save(formItem)
  });
  const [formError, setFormError] = (0, import_react11.useState)("");
  const [showDeleteDialog, setShowDeleteDialog] = (0, import_react11.useState)(false);
  const modelInfo = (0, import_react11.useMemo)(() => new ModelInfo(model, itemIdProperty), [model]);
  const isEditMode = item !== void 0 && item !== null && item !== emptyItem;
  const showDeleteButton = deleteButtonVisible && isEditMode && modelInfo.idProperty;
  const isSubmitDisabled = !!disabled || isEditMode && !form.dirty;
  (0, import_react11.useEffect)(() => {
    if (item !== emptyItem) {
      form.read(item);
    } else {
      form.clear();
    }
  }, [item]);
  function handleSubmitError(error) {
    if (error instanceof ValidationError) {
      const nonPropertyErrorMessages = error.errors.filter((validationError) => !validationError.property).map((validationError) => validationError.validatorMessage ?? validationError.message);
      if (nonPropertyErrorMessages.length > 0) {
        setFormError(
          (0, import_jsx_runtime7.jsxs)(import_jsx_runtime7.Fragment, { children: [
            "Validation errors:",
            (0, import_jsx_runtime7.jsx)("ul", { children: nonPropertyErrorMessages.map((message, index) => (0, import_jsx_runtime7.jsx)("li", { children: message }, index)) })
          ] })
        );
      }
    } else if (error instanceof EndpointError) {
      if (onSubmitError) {
        onSubmitError({ error, setMessage: setFormError });
      } else {
        setFormError(error.message);
      }
    } else {
      throw error;
    }
  }
  async function handleSubmit() {
    try {
      setFormError("");
      const newItem = await form.submit();
      if (newItem === void 0) {
        throw new EndpointError("No update performed");
      } else if (onSubmitSuccess) {
        onSubmitSuccess({ item: newItem });
      }
      if (!item || item === emptyItem) {
        form.clear();
      }
    } catch (error) {
      handleSubmitError(error);
    }
  }
  function deleteItem() {
    setShowDeleteDialog(true);
  }
  async function confirmDelete() {
    const deletedItem = item;
    try {
      const idProperty = modelInfo.idProperty;
      const id2 = item[idProperty.name];
      await service.delete(id2);
      if (onDeleteSuccess) {
        onDeleteSuccess({ item: deletedItem });
      }
    } catch (error) {
      if (error instanceof EndpointError) {
        if (onDeleteError) {
          onDeleteError({ error, setMessage: setFormError });
        } else {
          setFormError(error.message);
        }
      } else {
        throw error;
      }
    } finally {
      setShowDeleteDialog(false);
    }
  }
  function cancelDelete() {
    setShowDeleteDialog(false);
  }
  const handleKeyDown = (event) => {
    if (event.target instanceof HTMLTextAreaElement) {
      return;
    }
    if (event.key === "Enter" && !isSubmitDisabled) {
      void handleSubmit();
    }
  };
  function createAutoFormField(propertyInfo) {
    const fieldOptionsForProperty = (fieldOptions == null ? void 0 : fieldOptions[propertyInfo.name]) ?? {};
    return (0, import_jsx_runtime7.jsx)(
      AutoFormField,
      {
        propertyInfo,
        form,
        disabled,
        options: fieldOptionsForProperty
      },
      propertyInfo.name
    );
  }
  let visibleProperties = visibleFields ? modelInfo.getProperties(visibleFields) : getDefaultProperties(modelInfo);
  if (hiddenFields) {
    visibleProperties = visibleProperties.filter(({ name }) => !hiddenFields.includes(name));
  }
  const fields = visibleProperties.map(createAutoFormField);
  const layout = LayoutRenderer ? (0, import_jsx_runtime7.jsx)(LayoutRenderer, { form, children: fields }) : (0, import_jsx_runtime7.jsx)(p3, { ...formLayoutProps, children: fields });
  return (0, import_jsx_runtime7.jsxs)("div", { className: `auto-form ${className ?? ""}`, id, style, "data-testid": "auto-form", children: [
    (0, import_jsx_runtime7.jsxs)(m3, { className: "auto-form-fields", onKeyDown: handleKeyDown, children: [
      layout,
      formError ? (0, import_jsx_runtime7.jsx)("div", { style: { color: "var(--lumo-error-color)" }, children: formError }) : (0, import_jsx_runtime7.jsx)(import_jsx_runtime7.Fragment, {})
    ] }),
    (0, import_jsx_runtime7.jsxs)("div", { className: "auto-form-toolbar", children: [
      (0, import_jsx_runtime7.jsx)(
        m2,
        {
          theme: "primary",
          disabled: isSubmitDisabled,
          onClick: handleSubmit,
          children: "Submit"
        }
      ),
      form.dirty ? (0, import_jsx_runtime7.jsx)(m2, { theme: "tertiary", onClick: () => form.reset(), children: "Discard" }) : null,
      showDeleteButton && (0, import_jsx_runtime7.jsx)(m2, { className: "auto-form-delete-button", theme: "tertiary error", onClick: deleteItem, children: "Delete..." })
    ] }),
    showDeleteDialog && (0, import_jsx_runtime7.jsx)(
      f,
      {
        opened: true,
        header: "Delete item",
        confirmTheme: "error",
        cancelButtonVisible: true,
        onConfirm: confirmDelete,
        onCancel: cancelDelete,
        children: "Are you sure you want to delete the selected item?"
      }
    )
  ] });
}

// node_modules/@vaadin/hilla-react-crud/autoform-feature.js
var AutoForm2 = featureRegistration(AutoForm, "AutoForm");

// node_modules/@vaadin/hilla-react-crud/autocrud.js
var import_jsx_runtime9 = __toESM(require_jsx_runtime(), 1);
var import_react13 = __toESM(require_react(), 1);

// node_modules/@vaadin/hilla-react-crud/autocrud-dialog.js
var import_jsx_runtime8 = __toESM(require_jsx_runtime(), 1);
import "@vaadin/vaadin-lumo-styles/vaadin-iconset.js";
function AutoCrudDialog(props) {
  const { header, children, opened, onClose } = props;
  return (0, import_jsx_runtime8.jsx)(
    T,
    {
      overlayClass: "auto-crud-dialog",
      opened,
      headerRenderer: () => (0, import_jsx_runtime8.jsxs)("div", { className: "auto-crud-dialog-header", children: [
        header,
        (0, import_jsx_runtime8.jsx)(m2, { theme: "tertiary", onClick: onClose, "aria-label": "Close", children: (0, import_jsx_runtime8.jsx)(m, { icon: "lumo:cross", style: { height: "var(--lumo-icon-size-l)", width: "var(--lumo-icon-size-l)" } }) })
      ] }),
      children
    }
  );
}

// node_modules/@vaadin/hilla-react-crud/autocrud.obj.js
var css3 = new CSSStyleSheet();
css3.replaceSync(`.auto-crud{border:1px solid var(--lumo-contrast-20pct);display:flex;overflow:hidden}.auto-crud vaadin-split-layout{flex:1 1 100%}.auto-crud vaadin-split-layout::part(splitter){border-left:1px solid var(--lumo-contrast-20pct);border-top:1px solid var(--lumo-contrast-20pct)}.auto-crud-main{display:flex;flex:1 1 100%;flex-direction:column;min-width:200px}.auto-crud-main vaadin-grid{border:none}.auto-crud-toolbar{align-items:baseline;background-color:var(--lumo-contrast-5pct);border-top:1px solid var(--lumo-contrast-10pct);display:flex;flex-shrink:0;justify-content:flex-end;padding:var(--lumo-space-s) var(--lumo-space-m)}.auto-crud-form{align-items:stretch;display:flex;flex-direction:column;min-width:300px;width:40%}.auto-crud .auto-crud-form:before{box-shadow:var(--lumo-box-shadow-s);content:"";height:100%;pointer-events:none;position:absolute;width:100%;z-index:1}.auto-crud-form-header{padding:var(--lumo-space-m) var(--lumo-space-m) var(--lumo-space-s) var(--lumo-space-m)}.auto-crud .auto-form,.auto-crud-dialog .auto-form{align-items:stretch;display:flex;flex:1 1 0;flex-direction:column}.auto-crud .auto-form-fields,.auto-crud-dialog .auto-form-fields{flex:1 1 0;min-height:0;overflow-y:auto;padding:0 var(--lumo-space-m)}.auto-crud .auto-form-toolbar,.auto-crud-dialog .auto-form-toolbar{background-color:var(--lumo-contrast-5pct);border-top:1px solid var(--lumo-contrast-10pct);flex:0 0 auto;padding:var(--lumo-space-s) var(--lumo-space-m)}.auto-crud-dialog{bottom:0;left:0;right:0;top:0}.auto-crud-dialog::part(overlay){border-radius:0;height:100%;width:100%}.auto-crud-dialog::part(content){padding:0}.auto-crud-dialog .auto-crud-dialog-header{align-items:center;display:flex;justify-content:space-between;width:100%}.auto-crud-dialog .auto-form{height:100%;width:100%}`);

// node_modules/@vaadin/hilla-react-crud/media-query.js
var import_react12 = __toESM(require_react(), 1);
function useMediaQuery(query) {
  const [matches, setMatches] = (0, import_react12.useState)(() => window.matchMedia(query).matches);
  (0, import_react12.useEffect)(() => {
    const listener = (e2) => setMatches(e2.matches);
    const mediaQuery = window.matchMedia(query);
    setMatches(mediaQuery.matches);
    mediaQuery.addEventListener("change", listener);
    return () => mediaQuery.removeEventListener("change", listener);
  }, [query]);
  return matches;
}

// node_modules/@vaadin/hilla-react-crud/autocrud.js
registerStylesheet(css3);
function defaultFormHeaderRenderer(editedItem, disabled) {
  const style = { color: disabled ? "var(--lumo-disabled-text-color)" : "var(--lumo-text-color)" };
  return editedItem ? (0, import_jsx_runtime9.jsx)("h3", { style, children: "Edit item" }) : (0, import_jsx_runtime9.jsx)("h3", { style, children: "New item" });
}
function AutoCrud({
  service,
  model,
  itemIdProperty,
  formProps,
  gridProps,
  style,
  id,
  className
}) {
  const [item, setItem] = (0, import_react13.useState)(void 0);
  const fullScreen = useMediaQuery("(max-width: 600px), (max-height: 600px)");
  const autoGridRef = (0, import_react13.useRef)(null);
  const { headerRenderer: customFormHeaderRenderer, ...autoFormProps } = formProps ?? {};
  const formHeaderRenderer = customFormHeaderRenderer ?? defaultFormHeaderRenderer;
  const autoCrudId = (0, import_react13.useId)();
  function refreshGrid() {
    var _a;
    (_a = autoGridRef.current) == null ? void 0 : _a.refresh();
  }
  function handleCancel() {
    setItem(void 0);
  }
  const formHeader = item && item !== emptyItem ? formHeaderRenderer(item, !item) : formHeaderRenderer(null, !item);
  const mainSection = (0, import_jsx_runtime9.jsxs)("div", { className: "auto-crud-main", children: [
    (0, import_jsx_runtime9.jsx)(
      AutoGrid,
      {
        ...gridProps,
        service,
        model,
        itemIdProperty,
        selectedItems: item && item !== emptyItem ? [item] : [],
        onActiveItemChanged: (e2) => {
          const activeItem = e2.detail.value;
          setItem(activeItem ?? void 0);
        },
        ref: autoGridRef,
        "aria-controls": autoFormProps.id ?? `auto-form-${id ?? autoCrudId}`
      }
    ),
    (0, import_jsx_runtime9.jsx)("div", { className: "auto-crud-toolbar", children: (0, import_jsx_runtime9.jsx)(m2, { theme: "primary", onClick: () => setItem(emptyItem), children: "+ New" }) })
  ] });
  const autoForm = (0, import_jsx_runtime9.jsx)(
    AutoForm,
    {
      id: autoFormProps.id ?? `auto-form-${id ?? autoCrudId}`,
      deleteButtonVisible: true,
      ...autoFormProps,
      disabled: !item,
      service,
      model,
      itemIdProperty,
      item,
      onSubmitSuccess: ({ item: submittedItem }) => {
        if (fullScreen) {
          setItem(void 0);
        } else {
          setItem(submittedItem);
        }
        refreshGrid();
      },
      onDeleteSuccess: () => {
        setItem(void 0);
        refreshGrid();
      }
    }
  );
  return (0, import_jsx_runtime9.jsx)("div", { className: `auto-crud ${className ?? ""}`, id, style, children: fullScreen ? (0, import_jsx_runtime9.jsxs)(import_jsx_runtime9.Fragment, { children: [
    mainSection,
    (0, import_jsx_runtime9.jsx)(AutoCrudDialog, { opened: !!item, header: formHeader, onClose: handleCancel, children: autoForm })
  ] }) : (0, import_jsx_runtime9.jsxs)(n2, { theme: "small", children: [
    mainSection,
    (0, import_jsx_runtime9.jsxs)("div", { className: "auto-crud-form", children: [
      (0, import_jsx_runtime9.jsx)("div", { className: "auto-crud-form-header", children: formHeader }),
      autoForm
    ] })
  ] }) });
}

// node_modules/@vaadin/hilla-react-crud/autocrud-feature.js
var AutoCrud2 = featureRegistration(AutoCrud, "AutoCrud");

// node_modules/@vaadin/hilla-react-crud/index.js
function __REGISTER__3(feature, vaadinObj = window.Vaadin ?? (window.Vaadin = {})) {
  vaadinObj.registrations ?? (vaadinObj.registrations = []);
  vaadinObj.registrations.push({
    is: feature ? `${"@vaadin/hilla-react-crud"}/${feature}` : "@vaadin/hilla-react-crud",
    version: "24.5.5"
  });
}
__REGISTER__3();
export {
  AutoCrud2 as AutoCrud,
  AutoForm2 as AutoForm,
  AutoGrid2 as AutoGrid,
  emptyItem,
  useDataProvider
};
//# sourceMappingURL=@vaadin_hilla-react-crud.js.map
