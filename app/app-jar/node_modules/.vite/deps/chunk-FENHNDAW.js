import {
  EndpointValidationError
} from "./chunk-FOJBNPP3.js";
import {
  __privateAdd,
  __privateGet,
  __privateMethod,
  __privateSet,
  __publicField
} from "./chunk-547O27LD.js";

// node_modules/validator/es/lib/util/assertString.js
function _typeof(o) {
  "@babel/helpers - typeof";
  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof(o);
}
function assertString(input) {
  var isString = typeof input === "string" || input instanceof String;
  if (!isString) {
    var invalidType = _typeof(input);
    if (input === null) invalidType = "null";
    else if (invalidType === "object") invalidType = input.constructor.name;
    throw new TypeError("Expected a string but received a ".concat(invalidType));
  }
}

// node_modules/validator/es/lib/alpha.js
var alpha = {
  "en-US": /^[A-Z]+$/i,
  "az-AZ": /^[A-VXYZÇƏĞİıÖŞÜ]+$/i,
  "bg-BG": /^[А-Я]+$/i,
  "cs-CZ": /^[A-ZÁČĎÉĚÍŇÓŘŠŤÚŮÝŽ]+$/i,
  "da-DK": /^[A-ZÆØÅ]+$/i,
  "de-DE": /^[A-ZÄÖÜß]+$/i,
  "el-GR": /^[Α-ώ]+$/i,
  "es-ES": /^[A-ZÁÉÍÑÓÚÜ]+$/i,
  "fa-IR": /^[ابپتثجچحخدذرزژسشصضطظعغفقکگلمنوهی]+$/i,
  "fi-FI": /^[A-ZÅÄÖ]+$/i,
  "fr-FR": /^[A-ZÀÂÆÇÉÈÊËÏÎÔŒÙÛÜŸ]+$/i,
  "it-IT": /^[A-ZÀÉÈÌÎÓÒÙ]+$/i,
  "ja-JP": /^[ぁ-んァ-ヶｦ-ﾟ一-龠ー・。、]+$/i,
  "nb-NO": /^[A-ZÆØÅ]+$/i,
  "nl-NL": /^[A-ZÁÉËÏÓÖÜÚ]+$/i,
  "nn-NO": /^[A-ZÆØÅ]+$/i,
  "hu-HU": /^[A-ZÁÉÍÓÖŐÚÜŰ]+$/i,
  "pl-PL": /^[A-ZĄĆĘŚŁŃÓŻŹ]+$/i,
  "pt-PT": /^[A-ZÃÁÀÂÄÇÉÊËÍÏÕÓÔÖÚÜ]+$/i,
  "ru-RU": /^[А-ЯЁ]+$/i,
  "kk-KZ": /^[А-ЯЁ\u04D8\u04B0\u0406\u04A2\u0492\u04AE\u049A\u04E8\u04BA]+$/i,
  "sl-SI": /^[A-ZČĆĐŠŽ]+$/i,
  "sk-SK": /^[A-ZÁČĎÉÍŇÓŠŤÚÝŽĹŔĽÄÔ]+$/i,
  "sr-RS@latin": /^[A-ZČĆŽŠĐ]+$/i,
  "sr-RS": /^[А-ЯЂЈЉЊЋЏ]+$/i,
  "sv-SE": /^[A-ZÅÄÖ]+$/i,
  "th-TH": /^[ก-๐\s]+$/i,
  "tr-TR": /^[A-ZÇĞİıÖŞÜ]+$/i,
  "uk-UA": /^[А-ЩЬЮЯЄIЇҐі]+$/i,
  "vi-VN": /^[A-ZÀÁẠẢÃÂẦẤẬẨẪĂẰẮẶẲẴĐÈÉẸẺẼÊỀẾỆỂỄÌÍỊỈĨÒÓỌỎÕÔỒỐỘỔỖƠỜỚỢỞỠÙÚỤỦŨƯỪỨỰỬỮỲÝỴỶỸ]+$/i,
  "ko-KR": /^[ㄱ-ㅎㅏ-ㅣ가-힣]*$/,
  "ku-IQ": /^[ئابپتجچحخدرڕزژسشعغفڤقکگلڵمنوۆھەیێيطؤثآإأكضصةظذ]+$/i,
  ar: /^[ءآأؤإئابةتثجحخدذرزسشصضطظعغفقكلمنهوىيًٌٍَُِّْٰ]+$/,
  he: /^[א-ת]+$/,
  fa: /^['آاءأؤئبپتثجچحخدذرزژسشصضطظعغفقکگلمنوهةی']+$/i,
  bn: /^['ঀঁংঃঅআইঈউঊঋঌএঐওঔকখগঘঙচছজঝঞটঠডঢণতথদধনপফবভমযরলশষসহ়ঽািীুূৃৄেৈোৌ্ৎৗড়ঢ়য়ৠৡৢৣৰৱ৲৳৴৵৶৷৸৹৺৻']+$/,
  eo: /^[ABCĈD-GĜHĤIJĴK-PRSŜTUŬVZ]+$/i,
  "hi-IN": /^[\u0900-\u0961]+[\u0972-\u097F]*$/i,
  "si-LK": /^[\u0D80-\u0DFF]+$/
};
var alphanumeric = {
  "en-US": /^[0-9A-Z]+$/i,
  "az-AZ": /^[0-9A-VXYZÇƏĞİıÖŞÜ]+$/i,
  "bg-BG": /^[0-9А-Я]+$/i,
  "cs-CZ": /^[0-9A-ZÁČĎÉĚÍŇÓŘŠŤÚŮÝŽ]+$/i,
  "da-DK": /^[0-9A-ZÆØÅ]+$/i,
  "de-DE": /^[0-9A-ZÄÖÜß]+$/i,
  "el-GR": /^[0-9Α-ω]+$/i,
  "es-ES": /^[0-9A-ZÁÉÍÑÓÚÜ]+$/i,
  "fi-FI": /^[0-9A-ZÅÄÖ]+$/i,
  "fr-FR": /^[0-9A-ZÀÂÆÇÉÈÊËÏÎÔŒÙÛÜŸ]+$/i,
  "it-IT": /^[0-9A-ZÀÉÈÌÎÓÒÙ]+$/i,
  "ja-JP": /^[0-9０-９ぁ-んァ-ヶｦ-ﾟ一-龠ー・。、]+$/i,
  "hu-HU": /^[0-9A-ZÁÉÍÓÖŐÚÜŰ]+$/i,
  "nb-NO": /^[0-9A-ZÆØÅ]+$/i,
  "nl-NL": /^[0-9A-ZÁÉËÏÓÖÜÚ]+$/i,
  "nn-NO": /^[0-9A-ZÆØÅ]+$/i,
  "pl-PL": /^[0-9A-ZĄĆĘŚŁŃÓŻŹ]+$/i,
  "pt-PT": /^[0-9A-ZÃÁÀÂÄÇÉÊËÍÏÕÓÔÖÚÜ]+$/i,
  "ru-RU": /^[0-9А-ЯЁ]+$/i,
  "kk-KZ": /^[0-9А-ЯЁ\u04D8\u04B0\u0406\u04A2\u0492\u04AE\u049A\u04E8\u04BA]+$/i,
  "sl-SI": /^[0-9A-ZČĆĐŠŽ]+$/i,
  "sk-SK": /^[0-9A-ZÁČĎÉÍŇÓŠŤÚÝŽĹŔĽÄÔ]+$/i,
  "sr-RS@latin": /^[0-9A-ZČĆŽŠĐ]+$/i,
  "sr-RS": /^[0-9А-ЯЂЈЉЊЋЏ]+$/i,
  "sv-SE": /^[0-9A-ZÅÄÖ]+$/i,
  "th-TH": /^[ก-๙\s]+$/i,
  "tr-TR": /^[0-9A-ZÇĞİıÖŞÜ]+$/i,
  "uk-UA": /^[0-9А-ЩЬЮЯЄIЇҐі]+$/i,
  "ko-KR": /^[0-9ㄱ-ㅎㅏ-ㅣ가-힣]*$/,
  "ku-IQ": /^[٠١٢٣٤٥٦٧٨٩0-9ئابپتجچحخدرڕزژسشعغفڤقکگلڵمنوۆھەیێيطؤثآإأكضصةظذ]+$/i,
  "vi-VN": /^[0-9A-ZÀÁẠẢÃÂẦẤẬẨẪĂẰẮẶẲẴĐÈÉẸẺẼÊỀẾỆỂỄÌÍỊỈĨÒÓỌỎÕÔỒỐỘỔỖƠỜỚỢỞỠÙÚỤỦŨƯỪỨỰỬỮỲÝỴỶỸ]+$/i,
  ar: /^[٠١٢٣٤٥٦٧٨٩0-9ءآأؤإئابةتثجحخدذرزسشصضطظعغفقكلمنهوىيًٌٍَُِّْٰ]+$/,
  he: /^[0-9א-ת]+$/,
  fa: /^['0-9آاءأؤئبپتثجچحخدذرزژسشصضطظعغفقکگلمنوهةی۱۲۳۴۵۶۷۸۹۰']+$/i,
  bn: /^['ঀঁংঃঅআইঈউঊঋঌএঐওঔকখগঘঙচছজঝঞটঠডঢণতথদধনপফবভমযরলশষসহ়ঽািীুূৃৄেৈোৌ্ৎৗড়ঢ়য়ৠৡৢৣ০১২৩৪৫৬৭৮৯ৰৱ৲৳৴৵৶৷৸৹৺৻']+$/,
  eo: /^[0-9ABCĈD-GĜHĤIJĴK-PRSŜTUŬVZ]+$/i,
  "hi-IN": /^[\u0900-\u0963]+[\u0966-\u097F]*$/i,
  "si-LK": /^[0-9\u0D80-\u0DFF]+$/
};
var decimal = {
  "en-US": ".",
  ar: "٫"
};
var englishLocales = ["AU", "GB", "HK", "IN", "NZ", "ZA", "ZM"];
for (i = 0; i < englishLocales.length; i++) {
  locale = "en-".concat(englishLocales[i]);
  alpha[locale] = alpha["en-US"];
  alphanumeric[locale] = alphanumeric["en-US"];
  decimal[locale] = decimal["en-US"];
}
var locale;
var i;
var arabicLocales = ["AE", "BH", "DZ", "EG", "IQ", "JO", "KW", "LB", "LY", "MA", "QM", "QA", "SA", "SD", "SY", "TN", "YE"];
for (_i = 0; _i < arabicLocales.length; _i++) {
  _locale = "ar-".concat(arabicLocales[_i]);
  alpha[_locale] = alpha.ar;
  alphanumeric[_locale] = alphanumeric.ar;
  decimal[_locale] = decimal.ar;
}
var _locale;
var _i;
var farsiLocales = ["IR", "AF"];
for (_i2 = 0; _i2 < farsiLocales.length; _i2++) {
  _locale2 = "fa-".concat(farsiLocales[_i2]);
  alphanumeric[_locale2] = alphanumeric.fa;
  decimal[_locale2] = decimal.ar;
}
var _locale2;
var _i2;
var bengaliLocales = ["BD", "IN"];
for (_i3 = 0; _i3 < bengaliLocales.length; _i3++) {
  _locale3 = "bn-".concat(bengaliLocales[_i3]);
  alpha[_locale3] = alpha.bn;
  alphanumeric[_locale3] = alphanumeric.bn;
  decimal[_locale3] = decimal["en-US"];
}
var _locale3;
var _i3;
var dotDecimal = ["ar-EG", "ar-LB", "ar-LY"];
var commaDecimal = ["bg-BG", "cs-CZ", "da-DK", "de-DE", "el-GR", "en-ZM", "eo", "es-ES", "fr-CA", "fr-FR", "id-ID", "it-IT", "ku-IQ", "hi-IN", "hu-HU", "nb-NO", "nn-NO", "nl-NL", "pl-PL", "pt-PT", "ru-RU", "kk-KZ", "si-LK", "sl-SI", "sr-RS@latin", "sr-RS", "sv-SE", "tr-TR", "uk-UA", "vi-VN"];
for (_i4 = 0; _i4 < dotDecimal.length; _i4++) {
  decimal[dotDecimal[_i4]] = decimal["en-US"];
}
var _i4;
for (_i5 = 0; _i5 < commaDecimal.length; _i5++) {
  decimal[commaDecimal[_i5]] = ",";
}
var _i5;
alpha["fr-CA"] = alpha["fr-FR"];
alphanumeric["fr-CA"] = alphanumeric["fr-FR"];
alpha["pt-BR"] = alpha["pt-PT"];
alphanumeric["pt-BR"] = alphanumeric["pt-PT"];
decimal["pt-BR"] = decimal["pt-PT"];
alpha["pl-Pl"] = alpha["pl-PL"];
alphanumeric["pl-Pl"] = alphanumeric["pl-PL"];
decimal["pl-Pl"] = decimal["pl-PL"];
alpha["fa-AF"] = alpha.fa;

// node_modules/validator/es/lib/isNumeric.js
var numericNoSymbols = /^[0-9]+$/;
function isNumeric(str, options) {
  assertString(str);
  if (options && options.no_symbols) {
    return numericNoSymbols.test(str);
  }
  return new RegExp("^[+-]?([0-9]*[".concat((options || {}).locale ? decimal[options.locale] : ".", "])?[0-9]+$")).test(str);
}

// node_modules/validator/es/lib/toDate.js
function toDate(date) {
  assertString(date);
  date = Date.parse(date);
  return !isNaN(date) ? new Date(date) : null;
}

// node_modules/validator/es/lib/isAfter.js
function isAfter(date, options) {
  var comparisonDate = (options === null || options === void 0 ? void 0 : options.comparisonDate) || options || Date().toString();
  var comparison = toDate(comparisonDate);
  var original = toDate(date);
  return !!(original && comparison && original > comparison);
}

// node_modules/validator/es/lib/isBefore.js
function isBefore(str) {
  var date = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : String(/* @__PURE__ */ new Date());
  assertString(str);
  var comparison = toDate(date);
  var original = toDate(str);
  return !!(original && comparison && original < comparison);
}

// node_modules/validator/es/lib/isBoolean.js
var defaultOptions = {
  loose: false
};
var strictBooleans = ["true", "false", "1", "0"];
var looseBooleans = [].concat(strictBooleans, ["yes", "no"]);
function isBoolean(str) {
  var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : defaultOptions;
  assertString(str);
  if (options.loose) {
    return looseBooleans.includes(str.toLowerCase());
  }
  return strictBooleans.includes(str);
}

// node_modules/validator/es/lib/util/merge.js
function merge() {
  var obj = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  var defaults = arguments.length > 1 ? arguments[1] : void 0;
  for (var key in defaults) {
    if (typeof obj[key] === "undefined") {
      obj[key] = defaults[key];
    }
  }
  return obj;
}

// node_modules/validator/es/lib/util/includes.js
var includes = function includes2(arr, val) {
  return arr.some(function(arrVal) {
    return val === arrVal;
  });
};
var includes_default = includes;

// node_modules/validator/es/lib/isDecimal.js
function decimalRegExp(options) {
  var regExp = new RegExp("^[-+]?([0-9]+)?(\\".concat(decimal[options.locale], "[0-9]{").concat(options.decimal_digits, "})").concat(options.force_decimal ? "" : "?", "$"));
  return regExp;
}
var default_decimal_options = {
  force_decimal: false,
  decimal_digits: "1,",
  locale: "en-US"
};
var blacklist = ["", "-", "+"];
function isDecimal(str, options) {
  assertString(str);
  options = merge(options, default_decimal_options);
  if (options.locale in decimal) {
    return !includes_default(blacklist, str.replace(/ /g, "")) && decimalRegExp(options).test(str);
  }
  throw new Error("Invalid locale '".concat(options.locale, "'"));
}

// node_modules/validator/es/lib/isByteLength.js
function _typeof2(o) {
  "@babel/helpers - typeof";
  return _typeof2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof2(o);
}
function isByteLength(str, options) {
  assertString(str);
  var min;
  var max;
  if (_typeof2(options) === "object") {
    min = options.min || 0;
    max = options.max;
  } else {
    min = arguments[1];
    max = arguments[2];
  }
  var len = encodeURI(str).split(/%..|./).length - 1;
  return len >= min && (typeof max === "undefined" || len <= max);
}

// node_modules/validator/es/lib/isFQDN.js
var default_fqdn_options = {
  require_tld: true,
  allow_underscores: false,
  allow_trailing_dot: false,
  allow_numeric_tld: false,
  allow_wildcard: false,
  ignore_max_length: false
};
function isFQDN(str, options) {
  assertString(str);
  options = merge(options, default_fqdn_options);
  if (options.allow_trailing_dot && str[str.length - 1] === ".") {
    str = str.substring(0, str.length - 1);
  }
  if (options.allow_wildcard === true && str.indexOf("*.") === 0) {
    str = str.substring(2);
  }
  var parts = str.split(".");
  var tld = parts[parts.length - 1];
  if (options.require_tld) {
    if (parts.length < 2) {
      return false;
    }
    if (!options.allow_numeric_tld && !/^([a-z\u00A1-\u00A8\u00AA-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]{2,}|xn[a-z0-9-]{2,})$/i.test(tld)) {
      return false;
    }
    if (/\s/.test(tld)) {
      return false;
    }
  }
  if (!options.allow_numeric_tld && /^\d+$/.test(tld)) {
    return false;
  }
  return parts.every(function(part) {
    if (part.length > 63 && !options.ignore_max_length) {
      return false;
    }
    if (!/^[a-z_\u00a1-\uffff0-9-]+$/i.test(part)) {
      return false;
    }
    if (/[\uff01-\uff5e]/.test(part)) {
      return false;
    }
    if (/^-|-$/.test(part)) {
      return false;
    }
    if (!options.allow_underscores && /_/.test(part)) {
      return false;
    }
    return true;
  });
}

// node_modules/validator/es/lib/isIP.js
var IPv4SegmentFormat = "(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])";
var IPv4AddressFormat = "(".concat(IPv4SegmentFormat, "[.]){3}").concat(IPv4SegmentFormat);
var IPv4AddressRegExp = new RegExp("^".concat(IPv4AddressFormat, "$"));
var IPv6SegmentFormat = "(?:[0-9a-fA-F]{1,4})";
var IPv6AddressRegExp = new RegExp("^(" + "(?:".concat(IPv6SegmentFormat, ":){7}(?:").concat(IPv6SegmentFormat, "|:)|") + "(?:".concat(IPv6SegmentFormat, ":){6}(?:").concat(IPv4AddressFormat, "|:").concat(IPv6SegmentFormat, "|:)|") + "(?:".concat(IPv6SegmentFormat, ":){5}(?::").concat(IPv4AddressFormat, "|(:").concat(IPv6SegmentFormat, "){1,2}|:)|") + "(?:".concat(IPv6SegmentFormat, ":){4}(?:(:").concat(IPv6SegmentFormat, "){0,1}:").concat(IPv4AddressFormat, "|(:").concat(IPv6SegmentFormat, "){1,3}|:)|") + "(?:".concat(IPv6SegmentFormat, ":){3}(?:(:").concat(IPv6SegmentFormat, "){0,2}:").concat(IPv4AddressFormat, "|(:").concat(IPv6SegmentFormat, "){1,4}|:)|") + "(?:".concat(IPv6SegmentFormat, ":){2}(?:(:").concat(IPv6SegmentFormat, "){0,3}:").concat(IPv4AddressFormat, "|(:").concat(IPv6SegmentFormat, "){1,5}|:)|") + "(?:".concat(IPv6SegmentFormat, ":){1}(?:(:").concat(IPv6SegmentFormat, "){0,4}:").concat(IPv4AddressFormat, "|(:").concat(IPv6SegmentFormat, "){1,6}|:)|") + "(?::((?::".concat(IPv6SegmentFormat, "){0,5}:").concat(IPv4AddressFormat, "|(?::").concat(IPv6SegmentFormat, "){1,7}|:))") + ")(%[0-9a-zA-Z-.:]{1,})?$");
function isIP(str) {
  var version = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
  assertString(str);
  version = String(version);
  if (!version) {
    return isIP(str, 4) || isIP(str, 6);
  }
  if (version === "4") {
    return IPv4AddressRegExp.test(str);
  }
  if (version === "6") {
    return IPv6AddressRegExp.test(str);
  }
  return false;
}

// node_modules/validator/es/lib/isEmail.js
var default_email_options = {
  allow_display_name: false,
  allow_underscores: false,
  require_display_name: false,
  allow_utf8_local_part: true,
  require_tld: true,
  blacklisted_chars: "",
  ignore_max_length: false,
  host_blacklist: [],
  host_whitelist: []
};
var splitNameAddress = /^([^\x00-\x1F\x7F-\x9F\cX]+)</i;
var emailUserPart = /^[a-z\d!#\$%&'\*\+\-\/=\?\^_`{\|}~]+$/i;
var gmailUserPart = /^[a-z\d]+$/;
var quotedEmailUser = /^([\s\x01-\x08\x0b\x0c\x0e-\x1f\x7f\x21\x23-\x5b\x5d-\x7e]|(\\[\x01-\x09\x0b\x0c\x0d-\x7f]))*$/i;
var emailUserUtf8Part = /^[a-z\d!#\$%&'\*\+\-\/=\?\^_`{\|}~\u00A1-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+$/i;
var quotedEmailUserUtf8 = /^([\s\x01-\x08\x0b\x0c\x0e-\x1f\x7f\x21\x23-\x5b\x5d-\x7e\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]|(\\[\x01-\x09\x0b\x0c\x0d-\x7f\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]))*$/i;
var defaultMaxEmailLength = 254;
function validateDisplayName(display_name) {
  var display_name_without_quotes = display_name.replace(/^"(.+)"$/, "$1");
  if (!display_name_without_quotes.trim()) {
    return false;
  }
  var contains_illegal = /[\.";<>]/.test(display_name_without_quotes);
  if (contains_illegal) {
    if (display_name_without_quotes === display_name) {
      return false;
    }
    var all_start_with_back_slash = display_name_without_quotes.split('"').length === display_name_without_quotes.split('\\"').length;
    if (!all_start_with_back_slash) {
      return false;
    }
  }
  return true;
}
function isEmail(str, options) {
  assertString(str);
  options = merge(options, default_email_options);
  if (options.require_display_name || options.allow_display_name) {
    var display_email = str.match(splitNameAddress);
    if (display_email) {
      var display_name = display_email[1];
      str = str.replace(display_name, "").replace(/(^<|>$)/g, "");
      if (display_name.endsWith(" ")) {
        display_name = display_name.slice(0, -1);
      }
      if (!validateDisplayName(display_name)) {
        return false;
      }
    } else if (options.require_display_name) {
      return false;
    }
  }
  if (!options.ignore_max_length && str.length > defaultMaxEmailLength) {
    return false;
  }
  var parts = str.split("@");
  var domain = parts.pop();
  var lower_domain = domain.toLowerCase();
  if (options.host_blacklist.includes(lower_domain)) {
    return false;
  }
  if (options.host_whitelist.length > 0 && !options.host_whitelist.includes(lower_domain)) {
    return false;
  }
  var user = parts.join("@");
  if (options.domain_specific_validation && (lower_domain === "gmail.com" || lower_domain === "googlemail.com")) {
    user = user.toLowerCase();
    var username = user.split("+")[0];
    if (!isByteLength(username.replace(/\./g, ""), {
      min: 6,
      max: 30
    })) {
      return false;
    }
    var _user_parts = username.split(".");
    for (var i = 0; i < _user_parts.length; i++) {
      if (!gmailUserPart.test(_user_parts[i])) {
        return false;
      }
    }
  }
  if (options.ignore_max_length === false && (!isByteLength(user, {
    max: 64
  }) || !isByteLength(domain, {
    max: 254
  }))) {
    return false;
  }
  if (!isFQDN(domain, {
    require_tld: options.require_tld,
    ignore_max_length: options.ignore_max_length,
    allow_underscores: options.allow_underscores
  })) {
    if (!options.allow_ip_domain) {
      return false;
    }
    if (!isIP(domain)) {
      if (!domain.startsWith("[") || !domain.endsWith("]")) {
        return false;
      }
      var noBracketdomain = domain.slice(1, -1);
      if (noBracketdomain.length === 0 || !isIP(noBracketdomain)) {
        return false;
      }
    }
  }
  if (user[0] === '"') {
    user = user.slice(1, user.length - 1);
    return options.allow_utf8_local_part ? quotedEmailUserUtf8.test(user) : quotedEmailUser.test(user);
  }
  var pattern = options.allow_utf8_local_part ? emailUserUtf8Part : emailUserPart;
  var user_parts = user.split(".");
  for (var _i = 0; _i < user_parts.length; _i++) {
    if (!pattern.test(user_parts[_i])) {
      return false;
    }
  }
  if (options.blacklisted_chars) {
    if (user.search(new RegExp("[".concat(options.blacklisted_chars, "]+"), "g")) !== -1) return false;
  }
  return true;
}

// node_modules/validator/es/lib/isFloat.js
function isFloat(str, options) {
  assertString(str);
  options = options || {};
  var _float = new RegExp("^(?:[-+])?(?:[0-9]+)?(?:\\".concat(options.locale ? decimal[options.locale] : ".", "[0-9]*)?(?:[eE][\\+\\-]?(?:[0-9]+))?$"));
  if (str === "" || str === "." || str === "," || str === "-" || str === "+") {
    return false;
  }
  var value = parseFloat(str.replace(",", "."));
  return _float.test(str) && (!options.hasOwnProperty("min") || value >= options.min) && (!options.hasOwnProperty("max") || value <= options.max) && (!options.hasOwnProperty("lt") || value < options.lt) && (!options.hasOwnProperty("gt") || value > options.gt);
}
var locales = Object.keys(decimal);

// node_modules/validator/es/lib/isLength.js
function _typeof3(o) {
  "@babel/helpers - typeof";
  return _typeof3 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof3(o);
}
function isLength(str, options) {
  assertString(str);
  var min;
  var max;
  if (_typeof3(options) === "object") {
    min = options.min || 0;
    max = options.max;
  } else {
    min = arguments[1] || 0;
    max = arguments[2];
  }
  var presentationSequences = str.match(/(\uFE0F|\uFE0E)/g) || [];
  var surrogatePairs = str.match(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g) || [];
  var len = str.length - presentationSequences.length - surrogatePairs.length;
  return len >= min && (typeof max === "undefined" || len <= max);
}

// node_modules/validator/es/lib/matches.js
function matches(str, pattern, modifiers) {
  assertString(str);
  if (Object.prototype.toString.call(pattern) !== "[object RegExp]") {
    pattern = new RegExp(pattern, modifiers);
  }
  return !!str.match(pattern);
}

// node_modules/validator/es/lib/toFloat.js
function toFloat(str) {
  if (!isFloat(str)) return NaN;
  return parseFloat(str);
}

// node_modules/@vaadin/hilla-lit-form/Validators.js
var AbstractValidator = class {
  constructor(attrs) {
    __publicField(this, "message", "invalid");
    __publicField(this, "impliesRequired", false);
    if (attrs == null ? void 0 : attrs.message) {
      this.message = attrs.message;
    }
  }
};
var Required = class extends AbstractValidator {
  constructor() {
    super(...arguments);
    __publicField(this, "impliesRequired", true);
    __publicField(this, "name", "Required");
  }
  validate(value) {
    if (typeof value === "string" || Array.isArray(value)) {
      return value.length > 0;
    }
    if (typeof value === "number") {
      return Number.isFinite(value);
    }
    return value !== void 0;
  }
};
function _asValidatorAttributes(attrs) {
  return typeof attrs === "object" ? attrs : {};
}
function _value(attrs) {
  return typeof attrs === "object" ? attrs.value : attrs;
}
var NumberValidator = class extends AbstractValidator {
  validate(value) {
    const num = Number(value);
    return !isNaN(num) && isFinite(num);
  }
};
var IsNumber = class extends NumberValidator {
  constructor(optional, attrs) {
    super({ message: "must be a number", ...attrs });
    __publicField(this, "optional");
    __publicField(this, "name", "IsNumber");
    this.optional = optional;
  }
  validate(value) {
    return this.optional && value == null || super.validate(value);
  }
};
var ValueNumberValidator = class extends NumberValidator {
  constructor(attrs) {
    super(_asValidatorAttributes(attrs));
    __publicField(this, "value");
    const val = _value(attrs);
    this.value = typeof val === "string" ? parseFloat(val) : val;
  }
};
var Email = class extends AbstractValidator {
  constructor(attrs) {
    super({ message: "must be a well-formed email address", ...attrs });
    __publicField(this, "name", "Email");
  }
  validate(value) {
    return !value || isEmail(value);
  }
};
var Null = class extends AbstractValidator {
  constructor(attrs) {
    super({ message: "must be null", ...attrs });
    __publicField(this, "name", "Null");
  }
  validate(value) {
    return value == null;
  }
};
var NotNull = class extends Required {
  constructor(attrs) {
    super({ message: "must not be null", ...attrs });
    __publicField(this, "name", "NotNull");
  }
  validate(value) {
    return !new Null().validate(value);
  }
};
var NotEmpty = class extends Required {
  constructor(attrs) {
    super({ message: "must not be empty", ...attrs });
    __publicField(this, "name", "NotEmpty");
  }
  validate(value) {
    return super.validate(value) && new NotNull().validate(value) && (value.length ?? 0) > 0;
  }
};
var NotBlank = class extends Required {
  constructor(attrs) {
    super({ message: "must not be blank", ...attrs });
    __publicField(this, "name", "NotBlank");
  }
  validate(value) {
    return super.validate(value) && new NotNull().validate(value) && String(value).trim().length > 0;
  }
};
var AssertTrue = class extends AbstractValidator {
  constructor(attrs) {
    super({ message: "must be true", ...attrs });
    __publicField(this, "name", "AssertTrue");
  }
  validate(value) {
    return isBoolean(String(value)) && String(value) === "true";
  }
};
var AssertFalse = class extends AbstractValidator {
  constructor(attrs) {
    super({ message: "must be false", ...attrs });
    __publicField(this, "name", "AssertFalse");
  }
  validate(value) {
    return !new AssertTrue().validate(value);
  }
};
function _asValueNumberAttributes(attrs) {
  return typeof attrs === "object" ? attrs : { value: attrs };
}
var Min = class extends ValueNumberValidator {
  constructor(attrs) {
    super({
      message: `must be greater than or equal to ${_value(attrs)}`,
      ..._asValueNumberAttributes(attrs)
    });
    __publicField(this, "name", "Min");
  }
  validate(value) {
    return super.validate(value) && isFloat(String(value), { min: this.value });
  }
};
var Max = class extends ValueNumberValidator {
  constructor(attrs) {
    super({
      message: `must be less than or equal to ${_value(attrs)}`,
      ..._asValueNumberAttributes(attrs)
    });
    __publicField(this, "name", "Max");
  }
  validate(value) {
    return super.validate(value) && isFloat(String(value), { max: this.value });
  }
};
function _inclusive(attrs) {
  return typeof attrs !== "object" || attrs.inclusive !== false;
}
var DecimalMin = class extends ValueNumberValidator {
  constructor(attrs) {
    super({
      message: `must be greater than ${_inclusive(attrs) ? "or equal to " : ""}${_value(attrs)}`,
      ..._asValueNumberAttributes(attrs)
    });
    __publicField(this, "inclusive");
    __publicField(this, "name", "DecimalMin");
    this.inclusive = _inclusive(attrs);
  }
  validate(value) {
    return super.validate(value) && isFloat(String(value), { [this.inclusive ? "min" : "gt"]: this.value });
  }
};
var DecimalMax = class extends ValueNumberValidator {
  constructor(attrs) {
    super({
      message: `must be less than ${_inclusive(attrs) ? "or equal to " : ""}${_value(attrs)}`,
      ..._asValueNumberAttributes(attrs)
    });
    __publicField(this, "inclusive");
    __publicField(this, "name", "DecimalMax");
    this.inclusive = _inclusive(attrs);
  }
  validate(value) {
    return super.validate(value) && isFloat(String(value), { [this.inclusive ? "max" : "lt"]: this.value });
  }
};
var Negative = class extends AbstractValidator {
  constructor(attrs) {
    super({ message: "must be less than 0", ...attrs });
    __publicField(this, "name", "Negative");
  }
  validate(value) {
    return toFloat(String(value)) < 0;
  }
};
var NegativeOrZero = class extends AbstractValidator {
  constructor(attrs) {
    super({ message: "must be less than or equal to 0", ...attrs });
    __publicField(this, "name", "NegativeOrZero");
  }
  validate(value) {
    return toFloat(String(value)) <= 0;
  }
};
var Positive = class extends AbstractValidator {
  constructor(attrs) {
    super({ message: "must be greater than 0", ...attrs });
    __publicField(this, "name", "Positive");
  }
  validate(value) {
    return toFloat(String(value)) > 0;
  }
};
var PositiveOrZero = class extends AbstractValidator {
  constructor(attrs) {
    super({ message: "must be greater than or equal to 0", ...attrs });
    __publicField(this, "name", "PositiveOrZero");
  }
  validate(value) {
    return toFloat(String(value)) >= 0;
  }
};
function _min(attrs) {
  return attrs.min ?? 0;
}
function _max(attrs) {
  return attrs.max ?? Number.MAX_SAFE_INTEGER;
}
var Size = class extends AbstractValidator {
  constructor(attrs = {}) {
    super({ message: `size must be between ${_min(attrs)} and ${_max(attrs)}`, ...attrs });
    __publicField(this, "min");
    __publicField(this, "max");
    __publicField(this, "name", "Size");
    this.min = _min(attrs);
    this.max = _max(attrs);
    if (this.min > 0) {
      this.impliesRequired = true;
    }
  }
  validate(value) {
    if (this.min && this.min > 0 && !new Required().validate(value)) {
      return false;
    }
    return isLength(value, { min: this.min, max: this.max });
  }
};
var Digits = class extends AbstractValidator {
  constructor(attrs) {
    super({
      message: `numeric value out of bounds (<${attrs.integer} digits>.<${attrs.fraction} digits> expected)`,
      ...attrs
    });
    __publicField(this, "integer");
    __publicField(this, "fraction");
    __publicField(this, "name", "Digits");
    this.integer = attrs.integer;
    this.fraction = attrs.fraction;
  }
  validate(value) {
    return String(Math.floor(Math.abs(toFloat(String(value))))).length <= this.integer && // eslint-disable-next-line camelcase
    isDecimal(String(value), { decimal_digits: `0,${this.fraction}` });
  }
};
var Past = class extends AbstractValidator {
  constructor(attrs) {
    super({ message: "must be a past date", ...attrs });
    __publicField(this, "name", "Past");
  }
  validate(value) {
    return isBefore(String(value));
  }
};
var Future = class extends AbstractValidator {
  constructor(attrs) {
    super({ message: "must be a future date", ...attrs });
    __publicField(this, "name", "Future");
  }
  validate(value) {
    return isAfter(String(value));
  }
};
function _regexp(attrs) {
  if (typeof attrs === "string") {
    return new RegExp(attrs, "u");
  }
  if (attrs instanceof RegExp) {
    return attrs;
  }
  if (typeof attrs.regexp === "string") {
    return new RegExp(attrs.regexp, "u");
  }
  return attrs.regexp;
}
var Pattern = class extends AbstractValidator {
  constructor(attrs) {
    super({
      message: `must match the following regular expression: ${_regexp(attrs).toString()}`,
      ..._asValidatorAttributes(attrs)
    });
    __publicField(this, "regexp");
    __publicField(this, "name", "Pattern");
    this.regexp = _regexp(attrs);
  }
  validate(value) {
    return matches(value, this.regexp);
  }
};
var ValidityStateValidator = class extends AbstractValidator {
  // eslint-disable-next-line no-useless-constructor,@typescript-eslint/no-useless-constructor
  constructor() {
    super();
    __publicField(this, "message", "");
    __publicField(this, "name", "ValidityStateValidator");
  }
  validate() {
    return false;
  }
};

// node_modules/@vaadin/hilla-lit-form/Models.js
var _createEmptyItemValue = Symbol("createEmptyItemValue");
var _parent = Symbol("parent");
var _key = Symbol("key");
var _fromString = Symbol("fromString");
var _validators = Symbol("validators");
var _meta = Symbol("meta");
var _getPropertyModel = Symbol("getPropertyModel");
var _enum = Symbol("enum");
var _items = Symbol("items");
var _optional = Symbol("optional");
function hasFromString(model) {
  return _fromString in model;
}
var modelDetachedParent = { $value$: void 0 };
function createDetachedModel(type) {
  return new type(modelDetachedParent, "$value$", false);
}
var _a, _b, _c, _d, _e;
_e = _parent, _d = _validators, _c = _meta, _b = _optional, _a = _key;
var AbstractModel = class {
  constructor(parent, key, optional, options) {
    __publicField(this, _e);
    __publicField(this, _d);
    __publicField(this, _c);
    __publicField(this, _b);
    __publicField(this, _a);
    this[_parent] = parent;
    this[_key] = key;
    this[_optional] = optional;
    this[_validators] = (options == null ? void 0 : options.validators) ?? [];
    this[_meta] = (options == null ? void 0 : options.meta) ?? {};
  }
  static createEmptyValue() {
    return void 0;
  }
  /**
   * @deprecated Use {@link BinderNode.value} with string conversion instead
   *
   * @example
   * ```ts
   * const result = String(binder.for(model).value);
   * ```
   */
  toString() {
    return String(this.valueOf());
  }
  /**
   * @deprecated Use {@link BinderNode.value} instead
   *
   * @example
   * ```ts
   * const result = binder.for(model).value;
   * ```
   */
  valueOf() {
    const { value } = getBinderNode(this);
    if (value === void 0) {
      throw new TypeError("Value is undefined");
    }
    return value;
  }
};
var PrimitiveModel = class extends AbstractModel {
};
var BooleanModel = class extends PrimitiveModel {
  [_fromString](str) {
    return ["true", "1", "yes"].includes(str.toLowerCase());
  }
};
__publicField(BooleanModel, "createEmptyValue", Boolean);
var NumberModel = class extends PrimitiveModel {
  static createEmptyValue() {
    return NaN;
  }
  constructor(parent, key, optional, options) {
    const validators = [new IsNumber(optional), ...(options == null ? void 0 : options.validators) ?? []];
    super(parent, key, optional, { ...options, validators });
  }
  [_fromString](str) {
    if (str === "")
      return void 0;
    return isNumeric(str) ? Number.parseFloat(str) : NaN;
  }
};
var _a2, _b2;
var StringModel = class extends (_b2 = PrimitiveModel, _a2 = _fromString, _b2) {
  constructor() {
    super(...arguments);
    __publicField(this, _a2, String);
  }
};
__publicField(StringModel, "createEmptyValue", String);
function makeEnumEmptyValueCreator(type) {
  const { [_enum]: enumObject } = createDetachedModel(type);
  const defaultValue = Object.values(enumObject)[0];
  return () => defaultValue;
}
var EnumModel = class extends AbstractModel {
  [_fromString](value) {
    return value in this[_enum] ? value : void 0;
  }
};
function* getObjectModelOwnAndParentGetters(model) {
  for (let proto = Object.getPrototypeOf(model); proto !== ObjectModel.prototype; proto = Object.getPrototypeOf(proto)) {
    const descriptors = Object.getOwnPropertyDescriptors(proto);
    for (const [name, { get }] of Object.entries(descriptors)) {
      if (get) {
        yield [name, get];
      }
    }
  }
}
function makeObjectEmptyValueCreator(type) {
  const model = createDetachedModel(type);
  return () => {
    const obj = {};
    for (const [key, getter] of getObjectModelOwnAndParentGetters(model)) {
      const propertyModel = getter.call(model);
      obj[key] = propertyModel[_optional] ? void 0 : propertyModel.constructor.createEmptyValue();
    }
    return obj;
  };
}
var _properties;
var _ObjectModel = class _ObjectModel extends AbstractModel {
  constructor() {
    super(...arguments);
    __privateAdd(this, _properties, {});
  }
  [_getPropertyModel](key, init) {
    if (!__privateGet(this, _properties)[key]) {
      __privateGet(this, _properties)[key] = init(this, key);
    }
    return __privateGet(this, _properties)[key];
  }
};
_properties = new WeakMap();
__publicField(_ObjectModel, "createEmptyValue", makeObjectEmptyValueCreator(_ObjectModel));
var ObjectModel = _ObjectModel;
var _a3, _createItem, _items2;
var ArrayModel = class extends AbstractModel {
  constructor(parent, key, optional, createItem, options) {
    super(parent, key, optional, options);
    __publicField(this, _a3);
    // The `parent` parameter is AbstractModel here for purpose; for some reason, setting it to `ArrayModel<MItem>` or
    // `this` breaks the type inference in TS (v5.3.2).
    __privateAdd(this, _createItem);
    __privateAdd(this, _items2, []);
    __privateSet(this, _createItem, createItem);
    this[_createEmptyItemValue] = createItem(this, 0).constructor.createEmptyValue;
  }
  static createEmptyValue() {
    return [];
  }
  *[(_a3 = _createEmptyItemValue, _items)]() {
    const values = getBinderNode(this).value ?? [];
    if (values.length !== __privateGet(this, _items2).length) {
      __privateGet(this, _items2).length = values.length;
    }
    for (let i = 0; i < values.length; i++) {
      let item = __privateGet(this, _items2)[i];
      if (!item) {
        item = __privateGet(this, _createItem).call(this, this, i);
        __privateGet(this, _items2)[i] = item;
      }
      yield item;
    }
  }
  /**
   * Iterates over the current model and yields a binder node for every item
   * model.
   *
   * @deprecated Use the {@link m.items} function instead. For example, in React:
   * ```tsx
   * const {model, field} = useForm(GroupModel);
   * return Array.from(m.items(model.people), (personModel) =>
   *   <TextField label="Full name" {...field(personModel.fullName)} />
   * );
   * ```
   * In Lit:
   * ```ts
   * return html`${repeat(
   *   m.items(this.binder.model.people),
   *   (personModel) => html`<vaadin-text-field label="Full name" ${field(personModel.fullName)}></vaadin-text-field>`,
   * )}`;
   * ```
   */
  *[Symbol.iterator]() {
    for (const item of this[_items]()) {
      yield getBinderNode(item);
    }
  }
};
_createItem = new WeakMap();
_items2 = new WeakMap();
var m = {
  /**
   * Returns an iterator over item models in the array model.
   *
   * @param model - The array model to iterate over.
   * @returns An iterator over item models.
   */
  items(model) {
    return model[_items]();
  }
};

// node_modules/@vaadin/hilla-lit-form/Validity.js
var _validity = Symbol("validity");
var defaultValidity = {
  badInput: false,
  customError: false,
  patternMismatch: false,
  rangeOverflow: false,
  rangeUnderflow: false,
  stepMismatch: false,
  tooLong: false,
  tooShort: false,
  typeMismatch: false,
  valueMissing: false,
  valid: true
};

// node_modules/@vaadin/hilla-lit-form/BinderNode.js
var _updateValidation = Symbol("updateValidation");
var _update = Symbol("update");
var _setErrorsWithDescendants = Symbol("setErrorsWithDescendants");
var _clearValidation = Symbol("clearValidation");
var nodes = /* @__PURE__ */ new WeakMap();
function getBinderNode(model) {
  let node = nodes.get(model);
  if (!node) {
    node = new BinderNode(model);
    nodes.set(model, node);
  }
  return node;
}
function getErrorPropertyName(valueError) {
  return typeof valueError.property === "string" ? valueError.property : getBinderNode(valueError.property).name;
}
function updateObjectOrArrayKey(model, value, key, keyValue) {
  if (model instanceof ObjectModel) {
    return {
      ...value,
      [key]: keyValue
    };
  }
  if (keyValue === void 0) {
    throw new TypeError("Unexpected undefined value");
  }
  if (model instanceof ArrayModel) {
    const array = value.slice();
    array[key] = keyValue;
    return array;
  }
  throw new TypeError(`Unknown model type ${model.constructor.name}`);
}
var CHANGED = new Event("binder-node-changed");
var NotArrayModelError = class extends Error {
  constructor() {
    super("The model does not represent array");
  }
};
var NotArrayItemModelError = class extends Error {
  constructor() {
    super("The model does not represent array item");
  }
};
var defaultArrayItemCache = /* @__PURE__ */ new WeakMap();
var _a4, _ownErrors, _validators2, _validityStateValidator, _visited, _BinderNode_instances, getChildBinderNodes_fn, isArray_fn, isArrayItem_fn, isObject_fn, requestValidationOfDescendants_fn, requestValidationWithAncestors_fn, runOwnValidators_fn, setValueState_fn;
var _BinderNode = class _BinderNode extends EventTarget {
  constructor(model) {
    super();
    __privateAdd(this, _BinderNode_instances);
    __publicField(this, "model");
    /**
     * The validity state read from the bound element, if any. Represents the
     * HTML element internal validation.
     *
     * For elements with `validity.valid === false`, the value in the
     * bound element is considered as invalid.
     */
    __publicField(this, _a4);
    __privateAdd(this, _ownErrors);
    __privateAdd(this, _validators2);
    __privateAdd(this, _validityStateValidator);
    __privateAdd(this, _visited, false);
    this.model = model;
    nodes.set(model, this);
    __privateSet(this, _validityStateValidator, new ValidityStateValidator());
    __privateSet(this, _validators2, model[_validators]);
    if (this.constructor === _BinderNode) {
      this.initializeValue();
    }
  }
  /**
   * The binder for the top-level model.
   */
  get binder() {
    var _a5;
    const binder = (_a5 = this.parent) == null ? void 0 : _a5.binder;
    if (!binder) {
      throw new TypeError("BinderNode is detached");
    }
    return binder;
  }
  /**
   * The default value related to the model
   */
  get defaultValue() {
    const key = this.model[_key];
    const parentDefaultValue = this.parent.defaultValue;
    if (__privateMethod(this, _BinderNode_instances, isArrayItem_fn).call(this) && !(key in parentDefaultValue)) {
      if (defaultArrayItemCache.has(this.parent)) {
        return defaultArrayItemCache.get(this.parent);
      }
      const value = this.model.constructor.createEmptyValue();
      defaultArrayItemCache.set(this.parent, value);
      return value;
    }
    return parentDefaultValue[key];
  }
  /**
   * True if the current value is different from the defaultValue.
   */
  get dirty() {
    return this.value !== this.defaultValue;
  }
  /**
   * The combined array of all errors for this node’s model and all its nested
   * models
   */
  get errors() {
    return [...Array.from(__privateMethod(this, _BinderNode_instances, getChildBinderNodes_fn).call(this), (node) => node.errors).flat(), ...this.ownErrors];
  }
  /**
   * Indicates if there is any error for the node's model.
   */
  get invalid() {
    return this.errors.length > 0;
  }
  /**
   * The name generated from the model structure, used to set the name
   * attribute on the field components.
   */
  get name() {
    let { model } = this;
    let name = "";
    while (model[_parent] instanceof AbstractModel) {
      name = `${String(model[_key])}${name ? `.${name}` : ""}`;
      model = model[_parent];
    }
    return name;
  }
  /**
   * The array of validation errors directly related with the model.
   */
  get ownErrors() {
    return __privateGet(this, _ownErrors) ? __privateGet(this, _ownErrors) : [];
  }
  /**
   * The parent node, if this binder node corresponds to a nested model,
   * otherwise undefined for the top-level binder.
   */
  get parent() {
    const modelParent = this.model[_parent];
    return modelParent instanceof AbstractModel ? getBinderNode(modelParent) : void 0;
  }
  /**
   * True if the value is required to be non-empty.
   */
  get required() {
    return __privateGet(this, _validators2).some((validator) => validator.impliesRequired);
  }
  /**
   * The array of validators for the model. The default value is defined in the
   * model.
   */
  get validators() {
    return __privateGet(this, _validators2);
  }
  set validators(validators) {
    __privateSet(this, _validators2, validators);
    this.dispatchEvent(CHANGED);
  }
  /**
   * The current value related to the model
   */
  get value() {
    if (!this.parent) {
      return void 0;
    }
    this.initializeValue();
    const key = this.model[_key];
    return this.parent.value[key];
  }
  set value(value) {
    this.initializeValue();
    __privateMethod(this, _BinderNode_instances, setValueState_fn).call(this, value, void 0);
  }
  /**
   * True if the bound field was ever focused and blurred by the user.
   */
  get visited() {
    return __privateGet(this, _visited);
  }
  set visited(v) {
    if (__privateGet(this, _visited) !== v) {
      __privateSet(this, _visited, v);
      this[_updateValidation]().catch(() => {
      });
      this.dispatchEvent(CHANGED);
    }
  }
  /**
   * A helper method to add a validator
   *
   * @param validator - a validator
   */
  addValidator(validator) {
    this.validators = [...__privateGet(this, _validators2), validator];
    this.dispatchEvent(CHANGED);
  }
  /**
   * Append an item to the array value.
   *
   * Requires the context model to be an array reference.
   *
   * @param item - optional new item value, an empty item is
   * appended if the argument is omitted
   */
  appendItem(item) {
    if (__privateMethod(this, _BinderNode_instances, isArray_fn).call(this)) {
      const itemValueOrEmptyValue = item ?? this.model[_createEmptyItemValue]();
      const newValue = [...this.value ?? [], itemValueOrEmptyValue];
      const newDefaultValue = [...this.defaultValue ?? [], itemValueOrEmptyValue];
      __privateMethod(this, _BinderNode_instances, setValueState_fn).call(this, newValue, newDefaultValue);
    } else {
      throw new NotArrayModelError();
    }
  }
  /**
   * Returns a binder node for the nested model instance.
   *
   * @param model - The nested model instance
   */
  for(model) {
    const binderNode = getBinderNode(model);
    if (binderNode.binder !== this.binder) {
      throw new Error("Unknown binder");
    }
    return binderNode;
  }
  prependItem(item) {
    if (__privateMethod(this, _BinderNode_instances, isArray_fn).call(this)) {
      const itemValueOrEmptyValue = item ?? this.model[_createEmptyItemValue]();
      const newValue = [itemValueOrEmptyValue, ...this.value ?? []];
      const newDefaultValue = [itemValueOrEmptyValue, ...this.defaultValue ?? []];
      __privateMethod(this, _BinderNode_instances, setValueState_fn).call(this, newValue, newDefaultValue);
    } else {
      throw new NotArrayModelError();
    }
  }
  removeSelf() {
    var _a5;
    if (__privateMethod(this, _BinderNode_instances, isArrayItem_fn).call(this)) {
      const newValue = (this.parent.value ?? []).filter((_, i) => i !== this.model[_key]);
      const newDefaultValue = (this.parent.defaultValue ?? []).filter((_, i) => i !== this.model[_key]);
      __privateMethod(_a5 = this.parent, _BinderNode_instances, setValueState_fn).call(_a5, newValue, newDefaultValue);
    } else {
      throw new NotArrayItemModelError();
    }
  }
  /**
   * Runs all validation callbacks potentially affecting this
   * or any nested model. Returns the combined array of all
   * errors as in the errors property.
   */
  async validate() {
    const errors = await Promise.all([
      ...__privateMethod(this, _BinderNode_instances, requestValidationOfDescendants_fn).call(this),
      ...__privateMethod(this, _BinderNode_instances, requestValidationWithAncestors_fn).call(this)
    ]).then((arr) => arr.flat());
    this[_setErrorsWithDescendants](errors.length ? errors : void 0);
    this[_update]();
    return errors;
  }
  [(_a4 = _validity, _clearValidation)]() {
    if (__privateGet(this, _visited)) {
      __privateSet(this, _visited, false);
      this.dispatchEvent(CHANGED);
    }
    let needsUpdate = false;
    if (__privateGet(this, _ownErrors)) {
      __privateSet(this, _ownErrors, void 0);
      needsUpdate = true;
      this.dispatchEvent(CHANGED);
    }
    if ([...__privateMethod(this, _BinderNode_instances, getChildBinderNodes_fn).call(this)].filter((childBinderNode) => childBinderNode[_clearValidation]()).length > 0) {
      needsUpdate = true;
    }
    return needsUpdate;
  }
  [_setErrorsWithDescendants](errors) {
    const { name } = this;
    const ownErrors = errors ? errors.filter((valueError) => getErrorPropertyName(valueError) === name) : void 0;
    const relatedErrors = errors ? errors.filter((valueError) => getErrorPropertyName(valueError).startsWith(name)) : void 0;
    __privateSet(this, _ownErrors, ownErrors);
    for (const childBinderNode of __privateMethod(this, _BinderNode_instances, getChildBinderNodes_fn).call(this)) {
      childBinderNode[_setErrorsWithDescendants](relatedErrors);
    }
    this.dispatchEvent(CHANGED);
  }
  [_update](_) {
    if (this.parent) {
      this.parent[_update]();
    }
  }
  async [_updateValidation]() {
    if (__privateGet(this, _visited)) {
      await this.validate();
    } else if (this.dirty || this.invalid) {
      await Promise.all(
        [...__privateMethod(this, _BinderNode_instances, getChildBinderNodes_fn).call(this)].map(async (childBinderNode) => childBinderNode[_updateValidation]())
      );
    }
  }
  initializeValue(forceInitialize = false) {
    if (this.parent && (this.parent.value === void 0 || this.parent.defaultValue === void 0)) {
      this.parent.initializeValue(true);
    }
    const key = this.model[_key];
    let value = this.parent ? this.parent.value[this.model[_key]] : void 0;
    const defaultValue = this.parent ? this.parent.defaultValue[this.model[_key]] : void 0;
    if (value === void 0) {
      if (forceInitialize || !this.parent) {
        value = this.model.constructor.createEmptyValue();
        __privateMethod(this, _BinderNode_instances, setValueState_fn).call(this, value, defaultValue === void 0 ? value : defaultValue);
      } else if (this.parent.model instanceof ObjectModel && !(key in (this.parent.value || {}))) {
        __privateMethod(this, _BinderNode_instances, setValueState_fn).call(this, void 0, defaultValue === void 0 ? value : defaultValue);
      }
    }
  }
};
_ownErrors = new WeakMap();
_validators2 = new WeakMap();
_validityStateValidator = new WeakMap();
_visited = new WeakMap();
_BinderNode_instances = new WeakSet();
getChildBinderNodes_fn = function* () {
  if (this.value === void 0 || this.defaultValue === void 0) {
    return;
  }
  if (__privateMethod(this, _BinderNode_instances, isObject_fn).call(this)) {
    for (const [, getter] of getObjectModelOwnAndParentGetters(this.model)) {
      const childModel = getter.call(this.model);
      if (childModel[_key] in this.defaultValue) {
        yield getBinderNode(childModel);
      }
    }
  } else if (__privateMethod(this, _BinderNode_instances, isArray_fn).call(this)) {
    for (const childBinderNode of this.model) {
      yield childBinderNode;
    }
  }
};
isArray_fn = function() {
  return this.model instanceof ArrayModel;
};
isArrayItem_fn = function() {
  return this.model[_parent] instanceof ArrayModel;
};
isObject_fn = function() {
  return this.model instanceof ObjectModel;
};
requestValidationOfDescendants_fn = function* () {
  var _a5, _b3;
  for (const node of __privateMethod(this, _BinderNode_instances, getChildBinderNodes_fn).call(this)) {
    yield* __privateMethod(_a5 = node, _BinderNode_instances, runOwnValidators_fn).call(_a5);
    yield* __privateMethod(_b3 = node, _BinderNode_instances, requestValidationOfDescendants_fn).call(_b3);
  }
};
requestValidationWithAncestors_fn = function* () {
  var _a5;
  yield* __privateMethod(this, _BinderNode_instances, runOwnValidators_fn).call(this);
  if (this.parent) {
    yield* __privateMethod(_a5 = this.parent, _BinderNode_instances, requestValidationWithAncestors_fn).call(_a5);
  }
};
runOwnValidators_fn = function* () {
  var _a5;
  const hasInvalidState = this[_validity] && !this[_validity].valid;
  const hasBadInput = !!((_a5 = this[_validity]) == null ? void 0 : _a5.badInput);
  if (hasInvalidState && !hasBadInput || !hasInvalidState) {
    for (const validator of __privateGet(this, _validators2)) {
      yield this.binder.requestValidation(this.model, validator);
    }
  }
  if (hasInvalidState) {
    yield this.binder.requestValidation(this.model, __privateGet(this, _validityStateValidator));
  }
};
setValueState_fn = function(value, defaultValue) {
  var _a5, _b3, _c2;
  const { parent } = this;
  if (parent) {
    const key = this.model[_key];
    const parentValue = updateObjectOrArrayKey(parent.model, parent.value, key, value);
    const keepPristine = value === defaultValue && parent.value === parent.defaultValue;
    if (keepPristine) {
      __privateMethod(_a5 = parent, _BinderNode_instances, setValueState_fn).call(_a5, parentValue, parentValue);
    } else if (defaultValue !== void 0) {
      const parentDefaultValue = updateObjectOrArrayKey(parent.model, parent.defaultValue, key, defaultValue);
      __privateMethod(_b3 = parent, _BinderNode_instances, setValueState_fn).call(_b3, parentValue, parentDefaultValue);
    } else {
      __privateMethod(_c2 = parent, _BinderNode_instances, setValueState_fn).call(_c2, parentValue, void 0);
    }
  } else {
    const binder = this;
    if (defaultValue !== void 0) {
      binder.defaultValue = defaultValue;
    }
    binder.value = value;
  }
};
var BinderNode = _BinderNode;

// node_modules/@vaadin/hilla-lit-form/Field.js
import { noChange, nothing } from "lit";
import { directive, Directive, PartType } from "lit/directive.js";
var props = ["required", "invalid", "errorMessage", "value", "validity", "checkValidity"];
function isFieldElement(element) {
  return props.some((prop) => prop in element);
}
var _element, _validityFallback, _AbstractFieldStrategy_instances, detectValidityError_fn;
var AbstractFieldStrategy = class {
  constructor(element, model) {
    __privateAdd(this, _AbstractFieldStrategy_instances);
    __publicField(this, "model");
    __privateAdd(this, _element);
    /**
     * @privateRemarks
     * Fallback for missing .validity property API in Vaadin components.
     */
    __privateAdd(this, _validityFallback, defaultValidity);
    __privateSet(this, _element, element);
    this.model = model;
  }
  get element() {
    return __privateGet(this, _element);
  }
  /**
   * @param element - the new element value
   * @deprecated will be read-only in future
   */
  set element(element) {
    __privateSet(this, _element, element);
  }
  get value() {
    return __privateGet(this, _element).value;
  }
  set value(value) {
    if (this.model instanceof StringModel || this.model instanceof NumberModel) {
      __privateGet(this, _element).value = value ?? "";
      return;
    }
    __privateGet(this, _element).value = value;
  }
  set errorMessage(_) {
  }
  get validity() {
    return __privateGet(this, _element).validity ?? __privateGet(this, _validityFallback);
  }
  checkValidity() {
    if (!__privateGet(this, _element).checkValidity) {
      return true;
    }
    const valid = __privateGet(this, _element).checkValidity();
    __privateSet(this, _validityFallback, {
      ...defaultValidity,
      valid,
      ...valid ? {} : __privateMethod(this, _AbstractFieldStrategy_instances, detectValidityError_fn).call(this)
    });
    return valid;
  }
  setAttribute(key, val) {
    if (val) {
      __privateGet(this, _element).setAttribute(key, "");
    } else {
      __privateGet(this, _element).removeAttribute(key);
    }
  }
  removeEventListeners() {
  }
};
_element = new WeakMap();
_validityFallback = new WeakMap();
_AbstractFieldStrategy_instances = new WeakSet();
detectValidityError_fn = function() {
  if (!("inputElement" in __privateGet(this, _element))) {
    return { customError: true };
  }
  const inputElement = __privateGet(this, _element).inputElement;
  if (__privateGet(this, _element).value === "") {
    if (inputElement.value === "") {
      return { valueMissing: true };
    }
    return { badInput: true };
  }
  return { customError: true };
};
var _invalid, _boundOnValidated, _VaadinFieldStrategy_instances, onValidated_fn;
var VaadinFieldStrategy = class extends AbstractFieldStrategy {
  constructor(element, model) {
    super(element, model);
    __privateAdd(this, _VaadinFieldStrategy_instances);
    __privateAdd(this, _invalid, false);
    __privateAdd(this, _boundOnValidated, __privateMethod(this, _VaadinFieldStrategy_instances, onValidated_fn).bind(this));
    element.addEventListener("validated", __privateGet(this, _boundOnValidated));
  }
  set required(value) {
    this.element.required = value;
  }
  set invalid(value) {
    __privateSet(this, _invalid, value);
    this.element.invalid = value;
  }
  set errorMessage(value) {
    this.element.errorMessage = value;
  }
  removeEventListeners() {
    this.element.removeEventListener("validated", __privateGet(this, _boundOnValidated));
  }
  checkValidity() {
    const isElementInvalid = this.element.invalid;
    this.element.invalid = false;
    const valid = super.checkValidity();
    this.element.invalid = isElementInvalid;
    return valid;
  }
};
_invalid = new WeakMap();
_boundOnValidated = new WeakMap();
_VaadinFieldStrategy_instances = new WeakSet();
onValidated_fn = function(e) {
  if (!(e instanceof CustomEvent) || typeof e.detail !== "object") {
    return;
  }
  const invalid = !e.detail.valid;
  if (__privateGet(this, _invalid) !== invalid) {
    this.element.invalid = __privateGet(this, _invalid);
  }
};
var GenericFieldStrategy = class extends AbstractFieldStrategy {
  set required(value) {
    this.setAttribute("required", value);
  }
  set invalid(value) {
    this.setAttribute("invalid", value);
  }
};
var CheckedFieldStrategy = class extends GenericFieldStrategy {
  get value() {
    if (this.model instanceof BooleanModel) {
      return this.element.checked;
    }
    return this.element.checked ? this.element.value : void 0;
  }
  set value(val) {
    this.element.checked = /^(true|on)$/iu.test(String(val));
  }
};
var CheckedGroupFieldStrategy = class extends GenericFieldStrategy {
  get value() {
    return super.value;
  }
  set value(val) {
    super.value = val ?? [];
  }
};
var ComboBoxFieldStrategy = class extends VaadinFieldStrategy {
  get value() {
    if (this.model && (this.model instanceof ObjectModel || this.model instanceof ArrayModel)) {
      const { selectedItem } = this.element;
      return selectedItem ?? void 0;
    }
    return super.value;
  }
  set value(val) {
    if (this.model instanceof ObjectModel || this.model instanceof ArrayModel) {
      this.element.selectedItem = val ?? null;
    } else {
      super.value = val;
    }
  }
};
var VaadinStringFieldStrategy = class extends VaadinFieldStrategy {
  get value() {
    return super.value;
  }
  set value(val) {
    super.value = val ?? "";
  }
};
function isEmptyObject(val) {
  return val && typeof val === "object" && !Array.isArray(val) && Object.keys(val).length === 0;
}
var VaadinDateTimeFieldStrategy = class extends VaadinFieldStrategy {
  get value() {
    return super.value;
  }
  set value(val) {
    const timestamp = Date.parse(val);
    if (!val || isEmptyObject(val) || Number.isNaN(timestamp)) {
      super.value = "";
      return;
    }
    const date = new Date(timestamp);
    const tzOffsetMs = 60 * 1e3 * date.getTimezoneOffset();
    super.value = new Date(timestamp - tzOffsetMs).toISOString().slice(0, 19);
  }
};
var MultiSelectComboBoxFieldStrategy = class extends VaadinFieldStrategy {
  get value() {
    return this.element.selectedItems;
  }
  set value(val) {
    this.element.selectedItems = val;
  }
};
var SelectedFieldStrategy = class extends GenericFieldStrategy {
  get value() {
    return this.element.selected;
  }
  set value(val) {
    this.element.selected = val;
  }
};
function getDefaultFieldStrategy(elm, model) {
  switch (elm.localName) {
    case "vaadin-checkbox":
    case "vaadin-radio-button":
      return new CheckedFieldStrategy(elm, model);
    case "vaadin-checkbox-group":
      return new CheckedGroupFieldStrategy(elm, model);
    case "vaadin-combo-box":
      return new ComboBoxFieldStrategy(elm, model);
    case "vaadin-list-box":
      return new SelectedFieldStrategy(elm, model);
    case "vaadin-multi-select-combo-box":
      return new MultiSelectComboBoxFieldStrategy(elm, model);
    case "vaadin-rich-text-editor":
      return new GenericFieldStrategy(elm, model);
    case "vaadin-time-picker":
      return new VaadinStringFieldStrategy(
        elm,
        model
      );
    case "vaadin-date-time-picker":
      return new VaadinDateTimeFieldStrategy(elm, model);
    default:
      if (elm.localName === "input" && /^(checkbox|radio)$/u.test(elm.type)) {
        return new CheckedFieldStrategy(elm, model);
      }
      if (elm.constructor.version) {
        return new VaadinFieldStrategy(elm, model);
      }
      return new GenericFieldStrategy(elm, model);
  }
}
function convertFieldValue(model, fieldValue) {
  return typeof fieldValue === "string" && hasFromString(model) ? model[_fromString](fieldValue) : fieldValue;
}
var field = directive(
  class extends Directive {
    constructor(partInfo) {
      super(partInfo);
      __publicField(this, "fieldState");
      if (partInfo.type !== PartType.PROPERTY && partInfo.type !== PartType.ELEMENT) {
        throw new Error('Use as "<element {field(...)}" or <element ...={field(...)}"');
      }
    }
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    render(_model, _effect) {
      return nothing;
    }
    update(part, [model, effect]) {
      const element = part.element;
      const binderNode = getBinderNode(model);
      if (!this.fieldState) {
        const fieldState2 = {
          errorMessage: "",
          name: "",
          value: "",
          required: false,
          invalid: false,
          model,
          validity: defaultValidity,
          element,
          strategy: binderNode.binder.getFieldStrategy(element, model)
        };
        this.fieldState = fieldState2;
        const updateValueFromElement = () => {
          fieldState2.strategy.checkValidity();
          if (!fieldState2.strategy.validity.badInput) {
            fieldState2.value = fieldState2.strategy.value;
          }
          fieldState2.validity = fieldState2.strategy.validity;
          binderNode[_validity] = fieldState2.validity;
          binderNode.value = convertFieldValue(model, fieldState2.value);
          if (effect !== void 0) {
            effect.call(element, element);
          }
        };
        element.addEventListener("input", updateValueFromElement);
        const changeBlurHandler = () => {
          updateValueFromElement();
          binderNode.visited = true;
        };
        element.addEventListener("blur", changeBlurHandler);
        element.addEventListener("change", changeBlurHandler);
      }
      const { fieldState } = this;
      if (fieldState.element !== element || fieldState.model !== model) {
        fieldState.strategy = binderNode.binder.getFieldStrategy(element, model);
      }
      const { name } = binderNode;
      if (name !== fieldState.name) {
        fieldState.name = name;
        element.setAttribute("name", name);
      }
      const { value } = binderNode;
      const valueFromField = convertFieldValue(model, fieldState.value);
      if (value !== valueFromField && !(Number.isNaN(value) && Number.isNaN(valueFromField))) {
        const nonNanValue = Number.isNaN(value) ? "" : value;
        fieldState.value = nonNanValue;
        fieldState.strategy.value = nonNanValue;
      }
      const { required } = binderNode;
      if (required !== fieldState.required) {
        fieldState.required = required;
        fieldState.strategy.required = required;
      }
      const firstError = binderNode.ownErrors[0];
      const errorMessage = (firstError == null ? void 0 : firstError.message) || "";
      if (errorMessage !== fieldState.errorMessage) {
        fieldState.errorMessage = errorMessage;
        fieldState.strategy.errorMessage = errorMessage;
      }
      const { invalid } = binderNode;
      if (invalid !== fieldState.invalid) {
        fieldState.invalid = invalid;
        fieldState.strategy.invalid = invalid;
      }
      return noChange;
    }
  }
);

// node_modules/@vaadin/hilla-lit-form/Validation.js
var ValidationError = class extends Error {
  constructor(errors) {
    super(
      [
        "There are validation errors in the form.",
        ...errors.map((e) => {
          const property = e.property instanceof AbstractModel ? String(getBinderNode(e.property).value) : e.property;
          return `${property} - ${e.validator.constructor.name}${e.message ? `: ${e.message}` : ""}`;
        })
      ].join("\n - ")
    );
    __publicField(this, "errors");
    this.errors = errors;
    this.name = this.constructor.name;
  }
};
var ServerValidator = class {
  constructor(message) {
    __publicField(this, "name", "ServerValidator");
    __publicField(this, "message");
    __publicField(this, "validate", () => false);
    this.message = message;
  }
};
function setPropertyAbsolutePath(binderNodeName, result) {
  if (typeof result.property === "string" && binderNodeName.length > 0) {
    result.property = `${binderNodeName}.${result.property}`;
  }
  return result;
}
async function runValidator(model, validator, interpolateMessageCallback) {
  const binderNode = getBinderNode(model);
  const value = binderNode.value;
  const interpolateMessage = (message) => {
    if (!interpolateMessageCallback) {
      return message;
    }
    return interpolateMessageCallback(message, validator, binderNode);
  };
  if (!binderNode.required && !new Required().validate(value) && !(validator instanceof IsNumber) && !(validator instanceof ValidityStateValidator)) {
    return [];
  }
  try {
    const result = await validator.validate(value, binderNode.binder);
    if (result === false) {
      return [
        {
          message: interpolateMessage(validator.message),
          property: binderNode.name,
          validator,
          value
        }
      ];
    }
    if (result === true || Array.isArray(result) && result.length === 0) {
      return [];
    }
    if (Array.isArray(result)) {
      return result.map((result2) => ({
        message: interpolateMessage(validator.message),
        ...setPropertyAbsolutePath(binderNode.name, result2),
        validator,
        value
      }));
    }
    return [
      {
        message: interpolateMessage(validator.message),
        ...setPropertyAbsolutePath(binderNode.name, result),
        validator,
        value
      }
    ];
  } catch (error) {
    console.error(`${binderNode.name} - Validator ${validator.constructor.name} threw an error:`, error);
    return [{ message: "Validator threw an error", property: binderNode.name, validator, value }];
  }
}

// node_modules/@vaadin/hilla-lit-form/BinderRoot.js
var _defaultValue, _value2, _emptyValue, _submitting, _validating, _validationRequest, _config, _validations, _context;
var BinderRoot = class extends BinderNode {
  /**
   *
   * @param Model - The constructor (the class reference) of the form model. The Binder instantiates the top-level model
   * @param config - The options object, which can be used to config the onChange and onSubmit callbacks.
   *
   * ```
   * binder = new BinderRoot(OrderModel);
   * or
   * binder = new BinderRoot(OrderModel, {onSubmit: async (order) => {endpoint.save(order)}});
   * ```
   */
  constructor(Model, config) {
    super(createDetachedModel(Model));
    __privateAdd(this, _defaultValue);
    // Initialized in the `read()` method
    __privateAdd(this, _value2);
    // Initialized in the `read()` method
    __privateAdd(this, _emptyValue);
    __privateAdd(this, _submitting, false);
    __privateAdd(this, _validating, false);
    __privateAdd(this, _validationRequest);
    __privateAdd(this, _config);
    __privateAdd(this, _validations, /* @__PURE__ */ new Map());
    __privateAdd(this, _context, this);
    this.model[_parent] = this;
    __privateSet(this, _context, (config == null ? void 0 : config.context) ?? this);
    __privateSet(this, _config, config);
    this.initializeValue(true);
    __privateSet(this, _emptyValue, this.value);
  }
  /**
   * The initial value of the form, before any fields are edited by the user.
   */
  get defaultValue() {
    return __privateGet(this, _defaultValue);
  }
  set defaultValue(newValue) {
    __privateSet(this, _defaultValue, newValue);
    this.dispatchEvent(CHANGED);
  }
  get binder() {
    return this;
  }
  /**
   * The current value of the form.
   */
  get value() {
    return __privateGet(this, _value2);
  }
  set value(newValue) {
    if (newValue === __privateGet(this, _value2)) {
      return;
    }
    const oldValue = __privateGet(this, _value2);
    __privateSet(this, _value2, newValue);
    this[_update](oldValue);
    this[_updateValidation]().catch(() => {
    });
  }
  /**
   * Indicates the submitting status of the form.
   * True if the form was submitted, but the submit promise is not resolved yet.
   */
  get submitting() {
    return __privateGet(this, _submitting);
  }
  /**
   * Indicates the validating status of the form.
   * True when there is an ongoing validation.
   */
  get validating() {
    return __privateGet(this, _validating);
  }
  /**
   * Read the given value into the form and clear validation errors. Clears the form if the value is undefined.
   *
   * @param value - The value to read, or undefined to clear.
   */
  read(value) {
    if (value === void 0 || value === null) {
      this.clear();
      return;
    }
    this.defaultValue = value;
    if (
      // Skip when no value is set yet (e.g., invoked from constructor)
      this.value && // Clear validation state, then proceed if update is needed
      this[_clearValidation]() && // When value is dirty, another update is coming from invoking the value
      // setter below, so we skip this one to prevent duplicate updates
      this.value === value
    ) {
      this[_update](this.value);
    }
    this.value = this.defaultValue;
  }
  /**
   * Reset the form to the previous value
   */
  reset() {
    this.read(__privateGet(this, _defaultValue));
  }
  /**
   * Sets the form to empty value, as defined in the Model.
   */
  clear() {
    this.read(__privateGet(this, _emptyValue));
  }
  /**
   * Submit the current form value to a predefined
   * onSubmit callback.
   *
   * It's a no-op if the onSubmit callback is undefined.
   */
  async submit() {
    var _a5;
    const onSubmit = (_a5 = __privateGet(this, _config)) == null ? void 0 : _a5.onSubmit;
    if (onSubmit) {
      return this.submitTo(onSubmit);
    }
    return void 0;
  }
  /**
   * Submit the current form value to callback
   *
   * @param endpointMethod - the callback function
   */
  async submitTo(endpointMethod) {
    const errors = await this.validate();
    if (errors.length) {
      throw new ValidationError(errors);
    }
    __privateSet(this, _submitting, true);
    this[_update](this.value);
    this.dispatchEvent(CHANGED);
    try {
      return await endpointMethod.call(__privateGet(this, _context), this.value);
    } catch (error) {
      if (error instanceof EndpointValidationError && error.validationErrorData.length) {
        const valueErrors = [];
        error.validationErrorData.forEach((data) => {
          const res = /Object of type '(.+)' has invalid property '(.+)' with value '(.+)', validation error: '(.+)'/u.exec(
            data.message
          );
          const [property, value, message] = res ? res.splice(2) : [data.parameterName ?? "", void 0, data.message];
          valueErrors.push({
            message,
            property,
            validator: new ServerValidator(message),
            value,
            validatorMessage: data.validatorMessage
          });
        });
        this[_setErrorsWithDescendants](valueErrors);
        throw new ValidationError(valueErrors);
      }
      throw error;
    } finally {
      __privateSet(this, _submitting, false);
      this.defaultValue = this.value;
      this[_update](this.value);
    }
  }
  async requestValidation(model, validator) {
    let modelValidations;
    if (__privateGet(this, _validations).has(model)) {
      modelValidations = __privateGet(this, _validations).get(model);
    } else {
      modelValidations = /* @__PURE__ */ new Map();
      __privateGet(this, _validations).set(model, modelValidations);
    }
    await this.performValidation();
    if (modelValidations.has(validator)) {
      return modelValidations.get(validator);
    }
    const promise = runValidator(model, validator, this.constructor.interpolateMessageCallback);
    modelValidations.set(validator, promise);
    const valueErrors = await promise;
    modelValidations.delete(validator);
    if (modelValidations.size === 0) {
      __privateGet(this, _validations).delete(model);
    }
    if (__privateGet(this, _validations).size === 0) {
      this.completeValidation();
    }
    return valueErrors;
  }
  /**
   * Determines and returns the field directive strategy for the bound element.
   * Override to customise the binding strategy for a component.
   * The Binder extends BinderNode, see the inherited properties and methods below.
   *
   * @param elm - the bound element
   * @param model - the bound model
   */
  // eslint ignored to allow overriding
  // eslint-disable-next-line @typescript-eslint/class-methods-use-this
  getFieldStrategy(elm, model) {
    return getDefaultFieldStrategy(elm, model);
  }
  performValidation() {
    if (!__privateGet(this, _validationRequest)) {
      __privateSet(this, _validating, true);
      this.dispatchEvent(CHANGED);
      __privateSet(this, _validationRequest, Promise.resolve().then(() => {
        __privateSet(this, _validationRequest, void 0);
      }));
    }
    return __privateGet(this, _validationRequest);
  }
  completeValidation() {
    __privateSet(this, _validating, false);
    this.dispatchEvent(CHANGED);
  }
  [_update](oldValue) {
    var _a5, _b3;
    (_b3 = (_a5 = __privateGet(this, _config)) == null ? void 0 : _a5.onChange) == null ? void 0 : _b3.call(__privateGet(this, _context), oldValue);
    this.dispatchEvent(CHANGED);
  }
};
_defaultValue = new WeakMap();
_value2 = new WeakMap();
_emptyValue = new WeakMap();
_submitting = new WeakMap();
_validating = new WeakMap();
_validationRequest = new WeakMap();
_config = new WeakMap();
_validations = new WeakMap();
_context = new WeakMap();
__publicField(BinderRoot, "interpolateMessageCallback");

// node_modules/@vaadin/hilla-lit-form/Binder.js
var Binder = class extends BinderRoot {
  /**
   *
   * @param context - The form view component instance to update.
   * @param Model - The constructor (the class reference) of the form model. The Binder instantiates the top-level model
   * @param config - The options object, which can be used to config the onChange and onSubmit callbacks.
   *
   * ```
   * binder = new Binder(orderView, OrderModel);
   * or
   * binder = new Binder(orderView, OrderModel, {onSubmit: async (order) => {endpoint.save(order)}});
   * ```
   */
  constructor(context, Model, config) {
    const changeCallback = (config == null ? void 0 : config.onChange) ?? (typeof context.requestUpdate === "function" ? () => context.requestUpdate() : void 0);
    super(Model, {
      ...config ?? {},
      onChange: changeCallback,
      context
    });
    __publicField(this, "context");
    this.context = context;
  }
};

// node_modules/@vaadin/hilla-lit-form/index.js
function __REGISTER__(feature, vaadinObj = window.Vaadin ?? (window.Vaadin = {})) {
  vaadinObj.registrations ?? (vaadinObj.registrations = []);
  vaadinObj.registrations.push({
    is: feature ? `${"@vaadin/hilla-lit-form"}/${feature}` : "@vaadin/hilla-lit-form",
    version: "24.5.5"
  });
}
__REGISTER__();

export {
  Required,
  IsNumber,
  Email,
  Null,
  NotNull,
  NotEmpty,
  NotBlank,
  AssertTrue,
  AssertFalse,
  Min,
  Max,
  DecimalMin,
  DecimalMax,
  Negative,
  NegativeOrZero,
  Positive,
  PositiveOrZero,
  Size,
  Digits,
  Past,
  Future,
  Pattern,
  ValidityStateValidator,
  _createEmptyItemValue,
  _parent,
  _key,
  _fromString,
  _validators,
  _meta,
  _getPropertyModel,
  _enum,
  _items,
  hasFromString,
  modelDetachedParent,
  createDetachedModel,
  AbstractModel,
  PrimitiveModel,
  BooleanModel,
  NumberModel,
  StringModel,
  makeEnumEmptyValueCreator,
  EnumModel,
  getObjectModelOwnAndParentGetters,
  makeObjectEmptyValueCreator,
  ObjectModel,
  ArrayModel,
  m,
  _validity,
  defaultValidity,
  _updateValidation,
  _update,
  _setErrorsWithDescendants,
  _clearValidation,
  getBinderNode,
  CHANGED,
  BinderNode,
  isFieldElement,
  AbstractFieldStrategy,
  VaadinFieldStrategy,
  GenericFieldStrategy,
  CheckedFieldStrategy,
  CheckedGroupFieldStrategy,
  ComboBoxFieldStrategy,
  VaadinStringFieldStrategy,
  VaadinDateTimeFieldStrategy,
  MultiSelectComboBoxFieldStrategy,
  SelectedFieldStrategy,
  getDefaultFieldStrategy,
  field,
  ValidationError,
  ServerValidator,
  runValidator,
  BinderRoot,
  Binder
};
//# sourceMappingURL=chunk-FENHNDAW.js.map
