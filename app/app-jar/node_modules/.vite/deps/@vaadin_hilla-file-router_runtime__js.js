import {
  Navigate,
  createBrowserRouter,
  useLocation,
  useMatches
} from "./chunk-XKZX7QM4.js";
import {
  _,
  d,
  u,
  w
} from "./chunk-NVUXQDW4.js";
import "./chunk-DHQHMXN4.js";
import "./chunk-FOJBNPP3.js";
import "./chunk-SV5EQZIV.js";
import "./chunk-AHZXUB6W.js";
import "./chunk-5KP7IUG2.js";
import "./chunk-AVWG52NB.js";
import {
  require_jsx_runtime
} from "./chunk-SKCOSPGW.js";
import {
  require_react
} from "./chunk-IF5A3MEL.js";
import {
  __privateAdd,
  __privateGet,
  __privateMethod,
  __privateSet,
  __publicField,
  __toESM
} from "./chunk-547O27LD.js";

// node_modules/@vaadin/hilla-file-router/runtime/createRoute.js
function createRoute(path, flowLayout, moduleOrChildren, children) {
  let module;
  if (Array.isArray(moduleOrChildren)) {
    children = moduleOrChildren;
  } else {
    module = moduleOrChildren;
  }
  return {
    path,
    module,
    children,
    flowLayout
  };
}

// node_modules/@vaadin/hilla-react-auth/ProtectedRoute.js
var import_jsx_runtime2 = __toESM(require_jsx_runtime(), 1);
var import_react2 = __toESM(require_react(), 1);

// node_modules/@vaadin/hilla-react-auth/useAuth.js
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);
var import_react = __toESM(require_react(), 1);
var initialState = {
  initializing: true,
  loading: false
};
var AuthContext = (0, import_react.createContext)({
  state: initialState,
  login() {
    throw new Error("AuthContext not initialized");
  },
  logout() {
    throw new Error("AuthContext not initialized");
  },
  hasAccess() {
    throw new Error("AuthContext not initialized");
  }
});

// node_modules/@vaadin/hilla-react-auth/ProtectedRoute.js
function ProtectedRoute({ redirectPath, access, element }) {
  const {
    state: { initializing, loading, user },
    hasAccess
  } = (0, import_react2.useContext)(AuthContext);
  const location = useLocation();
  if (initializing || loading) {
    return (0, import_jsx_runtime2.jsx)("div", {});
  }
  if (!hasAccess(access)) {
    return (0, import_jsx_runtime2.jsx)(Navigate, { to: redirectPath, state: { from: location }, replace: true });
  }
  return element;
}
ProtectedRoute.type = "ProtectedRoute";
function protectRoute(route, redirectPath = "/login") {
  var _a2;
  const { handle } = route;
  const requiresAuth = (handle == null ? void 0 : handle.loginRequired) ?? (handle == null ? void 0 : handle.requiresLogin) ?? ((_a2 = handle == null ? void 0 : handle.rolesAllowed) == null ? void 0 : _a2.length);
  if (requiresAuth) {
    route.element = (0, import_jsx_runtime2.jsx)(
      ProtectedRoute,
      {
        redirectPath,
        access: handle,
        element: route.element
      }
    );
  }
  return route;
}

// node_modules/@vaadin/hilla-react-auth/index.js
function __REGISTER__(feature, vaadinObj = window.Vaadin ?? (window.Vaadin = {})) {
  vaadinObj.registrations ?? (vaadinObj.registrations = []);
  vaadinObj.registrations.push({
    is: feature ? `${"@vaadin/hilla-react-auth"}/${feature}` : "@vaadin/hilla-react-auth",
    version: "24.5.5"
  });
}
__REGISTER__();

// node_modules/@vaadin/hilla-file-router/runtime/RouterConfigurationBuilder.js
var import_react3 = __toESM(require_react(), 1);

// node_modules/@vaadin/hilla-file-router/shared/convertComponentNameToTitle.js
var viewPattern = /view/giu;
var upperCaseSplitPattern = /(?=[A-Z])/gu;
function convertComponentNameToTitle(component) {
  let name;
  if (component && (typeof component === "object" || typeof component === "function") && "name" in component && typeof component.name === "string") {
    ({ name } = component);
  } else {
    name = String(component);
  }
  return name.replace(viewPattern, "").split(upperCaseSplitPattern).join(" ");
}

// node_modules/@vaadin/hilla-file-router/shared/transformTree.js
function transformTree(nodes, transformer) {
  return transformer(nodes, (...n2) => transformTree(n2, transformer));
}

// node_modules/@vaadin/hilla-file-router/runtime/RouterConfigurationBuilder.js
function isReactRouteModule(module) {
  return module ? "default" in module && typeof module.default === "function" : true;
}
function createRouteEntry(route) {
  return [`${route.path ?? ""}-${route.children ? "n" : "i"}`, route];
}
var RouteHandleFlags = ((RouteHandleFlags2) => {
  RouteHandleFlags2["FLOW_LAYOUT"] = "flowLayout";
  RouteHandleFlags2["IGNORE_FALLBACK"] = "ignoreFallback";
  return RouteHandleFlags2;
})(RouteHandleFlags || {});
function hasRouteHandleFlag(route, flag) {
  return typeof route.handle === "object" && flag in route.handle && route.handle[flag];
}
var _modifiers;
var RouterConfigurationBuilder = class {
  constructor() {
    __privateAdd(this, _modifiers, []);
  }
  /**
   * Adds the given routes to the current list of routes. All the routes are
   * deeply merged to preserve the path uniqueness.
   *
   * @param routes - A list of routes to add to the current list.
   */
  withReactRoutes(routes) {
    return this.update(routes);
  }
  /**
   * Adds the given file routes to the current list of routes. All the routes
   * are transformed to React RouterObjects and deeply merged to preserve the
   * path uniqueness.
   *
   * @param routes - A list of routes to add to the current list.
   */
  withFileRoutes(routes) {
    return this.update(routes, (original, added, children) => {
      var _a2, _b, _c;
      if (added) {
        const { module, path, flowLayout } = added;
        if (!isReactRouteModule(module)) {
          throw new Error(`The module for the "${path}" section doesn't have the React component exported by default`);
        }
        const element = (module == null ? void 0 : module.default) ? (0, import_react3.createElement)(module.default) : void 0;
        const handle = {
          ...module == null ? void 0 : module.config,
          title: ((_a2 = module == null ? void 0 : module.config) == null ? void 0 : _a2.title) ?? convertComponentNameToTitle(module == null ? void 0 : module.default),
          flowLayout: ((_b = module == null ? void 0 : module.config) == null ? void 0 : _b.flowLayout) ?? flowLayout
        };
        if (path === "" && !children) {
          return {
            ...original,
            element,
            handle,
            index: true
          };
        }
        return {
          ...original,
          path: ((_c = module == null ? void 0 : module.config) == null ? void 0 : _c.route) ?? path,
          element,
          children,
          handle
        };
      }
      return original;
    });
  }
  /**
   * Adds the given server route element to each branch of the current list of
   * routes.
   *
   * @param component - The React component to add to each branch of the
   * current list of routes.
   * @param config - An optional configuration that will be applied to
   * each fallback component.
   */
  withFallback(component, config) {
    this.withLayout(component);
    const fallbackRoutes = [
      { path: "*", element: (0, import_react3.createElement)(component), handle: config },
      { index: true, element: (0, import_react3.createElement)(component), handle: config }
    ];
    this.update(fallbackRoutes, (original, added, children) => {
      if (original && !hasRouteHandleFlag(
        original,
        "ignoreFallback"
        /* IGNORE_FALLBACK */
      )) {
        if (!children) {
          return original;
        }
        const _fallback = [...fallbackRoutes];
        if (children.some(({ path }) => path === "*")) {
          _fallback.shift();
        }
        if (children.some(({ index: i, path }) => i ?? (path == null ? void 0 : path.includes("?")))) {
          _fallback.pop();
        }
        return {
          ...original,
          children: [...children, ..._fallback]
        };
      }
      return added;
    });
    return this;
  }
  /**
   * Adds the layoutComponent as the parent layout to views with the flowLayouts ViewConfiguration set.
   *
   * @param layoutComponent - layout component to use, usually Flow
   */
  withLayout(layoutComponent) {
    __privateGet(this, _modifiers).push((originalRoutes) => {
      if (originalRoutes === void 0) {
        return originalRoutes;
      }
      const [serverRoutesTree, clientRoutesTree] = transformTree(
        originalRoutes,
        (routes, next) => (
          // Split single routes list onto two filtered lists
          routes.reduce(
            ([serverRoutesList, clientRoutesList], route) => {
              var _a2;
              if (hasRouteHandleFlag(
                route,
                "flowLayout"
                /* FLOW_LAYOUT */
              )) {
                return [[...serverRoutesList ?? [], route], clientRoutesList];
              }
              if (!((_a2 = route.children) == null ? void 0 : _a2.length)) {
                return [serverRoutesList, [...clientRoutesList ?? [], route]];
              }
              const [serverRouteSubtree, clientRouteSubtree] = next(...route.children);
              return [
                serverRouteSubtree ? [
                  ...serverRoutesList ?? [],
                  {
                    ...route,
                    children: serverRouteSubtree
                  }
                ] : serverRoutesList,
                clientRouteSubtree ? [
                  ...clientRoutesList ?? [],
                  {
                    ...route,
                    children: clientRouteSubtree
                  }
                ] : clientRoutesList
              ];
            },
            [void 0, void 0]
          )
        )
      );
      return [
        // The server subtree is wrapped with the server layout component,
        // which applies the top-level server layout to all matches.
        ...serverRoutesTree ? [
          {
            element: (0, import_react3.createElement)(layoutComponent),
            children: serverRoutesTree,
            handle: {
              [
                "ignoreFallback"
                /* IGNORE_FALLBACK */
              ]: true
            }
          }
        ] : [],
        // The client route subtree is preserved without wrapping.
        ...clientRoutesTree ?? []
      ];
    });
    return this;
  }
  /**
   * Protects all the routes that require authentication. For more details see
   * {@link @vaadin/hilla-react-auth#protectRoutes} function.
   *
   * @param redirectPath - the path to redirect to if the route is protected
   * and the user is not authenticated.
   */
  protect(redirectPath) {
    this.update(void 0, (route, _2, children) => {
      const finalRoute = protectRoute(route, redirectPath);
      finalRoute.children = children;
      return finalRoute;
    });
    return this;
  }
  update(routes, callback = (original, overriding, children) => ({
    ...original,
    ...overriding,
    children
  })) {
    __privateGet(this, _modifiers).push(
      (existingRoutes) => transformTree(
        [existingRoutes, routes],
        ([original, added], next) => {
          if (original && added) {
            const originalMap = new Map(original.map((route) => createRouteEntry(route)));
            const addedMap = new Map(added.map((route) => createRouteEntry(route)));
            const paths = /* @__PURE__ */ new Set([...originalMap.keys(), ...addedMap.keys()]);
            for (const path of paths) {
              const originalRoute = originalMap.get(path);
              const addedRoute = addedMap.get(path);
              let route;
              if (originalRoute && addedRoute) {
                route = callback(originalRoute, addedRoute, next(originalRoute.children, addedRoute.children));
              } else if (originalRoute) {
                route = callback(originalRoute, void 0, next(originalRoute.children, void 0));
              } else {
                route = callback(void 0, addedRoute, next(void 0, addedRoute.children));
              }
              if (route) {
                originalMap.set(path, route);
              }
            }
            return [...originalMap.values()];
          } else if (original) {
            return original.map((route) => callback(route, void 0, next(route.children, void 0))).filter(Boolean);
          } else if (added) {
            return added.map((route) => callback(void 0, route, next(void 0, route.children))).filter(Boolean);
          }
          return void 0;
        }
      )
    );
    return this;
  }
  /**
   * Builds the router with the current list of routes.
   */
  build(options) {
    const routes = __privateGet(this, _modifiers).reduce((acc, mod) => mod(acc) ?? acc, void 0) ?? [];
    return {
      routes,
      router: createBrowserRouter([...routes], { basename: new URL(document.baseURI).pathname, ...options })
    };
  }
};
_modifiers = new WeakMap();

// node_modules/@vaadin/hilla-file-router/runtime/useViewConfig.js
function useViewConfig() {
  var _a2;
  const matches = useMatches();
  return (_a2 = matches[matches.length - 1]) == null ? void 0 : _a2.handle;
}

// node_modules/@vaadin/hilla-react-signals/polyfills.js
if (!("withResolvers" in Promise)) {
  Object.defineProperty(Promise, "withResolvers", {
    configurable: true,
    value() {
      let resolve;
      let reject;
      const promise = new Promise((_resolve, _reject) => {
        resolve = _resolve;
        reject = _reject;
      });
      return { resolve, reject, promise };
    }
  });
}

// node_modules/@vaadin/hilla-react-signals/core.js
_();

// node_modules/nanoid/url-alphabet/index.js
var urlAlphabet = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";

// node_modules/nanoid/index.browser.js
var nanoid = (size = 21) => {
  let id = "";
  let bytes = crypto.getRandomValues(new Uint8Array(size));
  while (size--) {
    id += urlAlphabet[bytes[size] & 63];
  }
  return id;
};

// node_modules/@vaadin/hilla-react-signals/events.js
function createSetStateEvent(value) {
  return {
    id: nanoid(),
    type: "set",
    value,
    accepted: false
  };
}
function createReplaceStateEvent(expected, value) {
  return {
    id: nanoid(),
    type: "replace",
    value,
    expected,
    accepted: false
  };
}
function createIncrementStateEvent(delta) {
  return {
    id: nanoid(),
    type: "increment",
    value: delta,
    accepted: false
  };
}

// node_modules/@vaadin/hilla-react-signals/FullStackSignal.js
var ENDPOINT = "SignalsHandler";
var _onFirstSubscribe, _onLastUnsubscribe, _subscribeCount;
var DependencyTrackingSignal = class extends u {
  constructor(value, onFirstSubscribe, onLastUnsubscribe) {
    var _a2, _b;
    if (!((_b = (_a2 = window.Vaadin) == null ? void 0 : _a2.featureFlags) == null ? void 0 : _b.fullstackSignals)) {
      throw new Error(
        `The Hilla Fullstack Signals API is currently considered experimental and may change in the future. To use it you need to explicitly enable it in Copilot or by adding com.vaadin.experimental.fullstackSignals=true to vaadin-featureflags.properties`
      );
    }
    super(value);
    __privateAdd(this, _onFirstSubscribe);
    __privateAdd(this, _onLastUnsubscribe);
    // -1 means to ignore the first subscription that is created internally in the
    // FullStackSignal constructor.
    __privateAdd(this, _subscribeCount, -1);
    __privateSet(this, _onFirstSubscribe, onFirstSubscribe);
    __privateSet(this, _onLastUnsubscribe, onLastUnsubscribe);
  }
  S(node) {
    super.S(node);
    if (__privateGet(this, _subscribeCount) === 0) {
      __privateGet(this, _onFirstSubscribe).call(this);
    }
    __privateSet(this, _subscribeCount, __privateGet(this, _subscribeCount) + 1);
  }
  U(node) {
    super.U(node);
    __privateSet(this, _subscribeCount, __privateGet(this, _subscribeCount) - 1);
    if (__privateGet(this, _subscribeCount) === 0) {
      __privateGet(this, _onLastUnsubscribe).call(this);
    }
  }
};
_onFirstSubscribe = new WeakMap();
_onLastUnsubscribe = new WeakMap();
_subscribeCount = new WeakMap();
var _id, _config, _subscription;
var ServerConnection = class {
  constructor(id, config) {
    __privateAdd(this, _id);
    __privateAdd(this, _config);
    __privateAdd(this, _subscription);
    __privateSet(this, _config, config);
    __privateSet(this, _id, id);
  }
  get subscription() {
    return __privateGet(this, _subscription);
  }
  connect() {
    const { client, endpoint, method, params } = __privateGet(this, _config);
    __privateGet(this, _subscription) ?? __privateSet(this, _subscription, client.subscribe(ENDPOINT, "subscribe", {
      providerEndpoint: endpoint,
      providerMethod: method,
      clientSignalId: __privateGet(this, _id),
      params
    }));
    return __privateGet(this, _subscription);
  }
  async update(event) {
    await __privateGet(this, _config).client.call(ENDPOINT, "update", {
      clientSignalId: __privateGet(this, _id),
      event
    });
  }
  disconnect() {
    var _a2;
    (_a2 = __privateGet(this, _subscription)) == null ? void 0 : _a2.cancel();
    __privateSet(this, _subscription, void 0);
  }
};
_id = new WeakMap();
_config = new WeakMap();
_subscription = new WeakMap();
var $update = Symbol("update");
var $processServerResponse = Symbol("processServerResponse");
var _pending, _error, _paused, _FullStackSignal_instances, connect_fn, disconnect_fn;
var FullStackSignal = class extends DependencyTrackingSignal {
  constructor(value, config) {
    super(
      value,
      () => __privateMethod(this, _FullStackSignal_instances, connect_fn).call(this),
      () => __privateMethod(this, _FullStackSignal_instances, disconnect_fn).call(this)
    );
    __privateAdd(this, _FullStackSignal_instances);
    /**
     * The unique identifier of the signal necessary to communicate with the
     * server.
     */
    __publicField(this, "id", nanoid());
    /**
     * The server connection manager.
     */
    __publicField(this, "server");
    /**
     * Defines whether the signal is currently awaits a server-side response.
     */
    __publicField(this, "pending", w(() => __privateGet(this, _pending).value));
    /**
     * Defines whether the signal has an error.
     */
    __publicField(this, "error", w(() => __privateGet(this, _error).value));
    __privateAdd(this, _pending, d(false));
    __privateAdd(this, _error, d(void 0));
    // Paused at the very start to prevent the signal from sending the initial
    // value to the server.
    __privateAdd(this, _paused, true);
    this.server = new ServerConnection(this.id, config);
    this.subscribe((v) => {
      if (!__privateGet(this, _paused)) {
        __privateGet(this, _pending).value = true;
        __privateGet(this, _error).value = void 0;
        this[$update](createSetStateEvent(v));
      }
    });
    __privateSet(this, _paused, false);
  }
  /**
   * Sets the local value of the signal without sending any events to the server
   * @param value - The new value.
   * @internal
   */
  setValueLocal(value) {
    __privateSet(this, _paused, true);
    this.value = value;
    __privateSet(this, _paused, false);
  }
  /**
   * A method to update the server with the new value.
   *
   * @param event - The event to update the server with.
   */
  [$update](event) {
    this.server.update(event).catch((error) => {
      __privateGet(this, _error).value = error instanceof Error ? error : new Error(String(error));
    }).finally(() => {
      __privateGet(this, _pending).value = false;
    });
  }
};
_pending = new WeakMap();
_error = new WeakMap();
_paused = new WeakMap();
_FullStackSignal_instances = new WeakSet();
connect_fn = function() {
  this.server.connect().onSubscriptionLost(() => "resubscribe").onNext((event) => {
    __privateSet(this, _paused, true);
    this[$processServerResponse](event);
    __privateSet(this, _paused, false);
  });
};
disconnect_fn = function() {
  if (this.server.subscription === void 0) {
    return;
  }
  this.server.disconnect();
};

// node_modules/@vaadin/hilla-react-signals/ValueSignal.js
var _pendingRequests, _ValueSignal_instances, applyAcceptedEvent_fn;
var ValueSignal = class extends FullStackSignal {
  constructor() {
    super(...arguments);
    __privateAdd(this, _ValueSignal_instances);
    __privateAdd(this, _pendingRequests, /* @__PURE__ */ new Map());
  }
  /**
   * Sets the value.
   * Note that the value change event that is propagated to the server as the
   * result of this operation is not taking the last seen value into account and
   * will overwrite the shared value on the server unconditionally (AKA: "Last
   * Write Wins"). If you need to perform a conditional update, use the
   * `replace` method instead.
   *
   * @param value - The new value.
   */
  set(value) {
    this.value = value;
  }
  /**
   * Replaces the value with a new one only if the current value is equal to the
   * expected value.
   *
   * @param expected - The expected value.
   * @param newValue - The new value.
   */
  replace(expected, newValue) {
    this[$update](createReplaceStateEvent(expected, newValue));
  }
  /**
   * Tries to update the value by applying the callback function to the current
   * value. In case of a concurrent change, the callback is run again with an
   * updated input value. This is repeated until the result can be applied
   * without concurrent changes, or the operation is canceled.
   *
   * Note that there is no guarantee that cancel() will be effective always,
   * since a succeeding operation might already be on its way to the server.
   *
   * @param callback - The function that is applied on the current value to
   *                   produce the new value.
   * @returns An operation subscription that can be canceled.
   */
  update(callback) {
    const newValue = callback(this.value);
    const event = createReplaceStateEvent(this.value, newValue);
    this[$update](event);
    const waiter = Promise.withResolvers();
    const pendingRequest = { callback, waiter, canceled: false };
    __privateGet(this, _pendingRequests).set(event.id, pendingRequest);
    return {
      cancel: () => {
        pendingRequest.canceled = true;
        pendingRequest.waiter.resolve();
      }
    };
  }
  [$processServerResponse](event) {
    const record = __privateGet(this, _pendingRequests).get(event.id);
    if (record) {
      __privateGet(this, _pendingRequests).delete(event.id);
    }
    if (!event.accepted && record) {
      if (!record.canceled) {
        this.update(record.callback);
      }
    }
    if (event.accepted || event.type === "snapshot") {
      if (record) {
        record.waiter.resolve();
      }
      __privateMethod(this, _ValueSignal_instances, applyAcceptedEvent_fn).call(this, event);
    }
  }
};
_pendingRequests = new WeakMap();
_ValueSignal_instances = new WeakSet();
applyAcceptedEvent_fn = function(event) {
  if (event.type === "set" || event.type === "snapshot") {
    this.value = event.value;
  } else if (event.type === "replace") {
    if (JSON.stringify(this.value) === JSON.stringify(event.expected)) {
      this.value = event.value;
    }
  }
};

// node_modules/@vaadin/hilla-react-signals/NumberSignal.js
var _sentIncrementEvents;
var NumberSignal = class extends ValueSignal {
  constructor() {
    super(...arguments);
    __privateAdd(this, _sentIncrementEvents, /* @__PURE__ */ new Map());
  }
  /**
   * Increments the value by the specified delta. The delta can be negative to
   * decrease the value.
   *
   * This method differs from using the `++` or `+=` operators directly on the
   * signal value. It performs an atomic operation to prevent conflicts from
   * concurrent changes, ensuring that other users' modifications are not
   * accidentally overwritten.
   *
   * @param delta - The delta to increment the value by. The delta can be
   * negative.
   */
  incrementBy(delta) {
    if (delta === 0) {
      return;
    }
    this.setValueLocal(this.value + delta);
    const event = createIncrementStateEvent(delta);
    __privateGet(this, _sentIncrementEvents).set(event.id, event);
    this[$update](event);
  }
  [$processServerResponse](event) {
    if (event.accepted && event.type === "increment") {
      if (__privateGet(this, _sentIncrementEvents).has(event.id)) {
        __privateGet(this, _sentIncrementEvents).delete(event.id);
        return;
      }
      this.setValueLocal(this.value + event.value);
    } else {
      super[$processServerResponse](event);
    }
  }
};
_sentIncrementEvents = new WeakMap();

// node_modules/@vaadin/hilla-file-router/runtime/createMenuItems.js
function __REGISTER__2(feature, vaadinObj = window.Vaadin ?? (window.Vaadin = {})) {
  vaadinObj.registrations ?? (vaadinObj.registrations = []);
  vaadinObj.registrations.push({
    is: feature ? `${"@vaadin/hilla-file-router"}/${feature}` : "@vaadin/hilla-file-router",
    version: "24.5.5"
  });
}
var _a;
var viewsSignal = d((_a = window.Vaadin) == null ? void 0 : _a.views);
function createMenuItems() {
  __REGISTER__2("createMenuItems", window.Vaadin);
  const collator = new Intl.Collator("en-US");
  if (!viewsSignal.value) {
    return [];
  }
  return Object.entries(viewsSignal.value).filter(([_2, value]) => {
    var _a2;
    return !((_a2 = value.menu) == null ? void 0 : _a2.exclude);
  }).map(([path, config]) => {
    var _a2, _b, _c;
    return {
      to: path,
      icon: (_a2 = config.menu) == null ? void 0 : _a2.icon,
      title: ((_b = config.menu) == null ? void 0 : _b.title) ?? config.title,
      order: (_c = config.menu) == null ? void 0 : _c.order
    };
  }).sort((menuA, menuB) => {
    const ordersDiff = (menuA.order ?? Number.MAX_VALUE) - (menuB.order ?? Number.MAX_VALUE);
    return ordersDiff !== 0 ? ordersDiff : collator.compare(menuA.to, menuB.to);
  });
}
if (import.meta.hot) {
  import.meta.hot.on("fs-route-update", () => {
    fetch("?v-r=routeinfo").then(async (resp) => resp.json()).then((json) => {
      viewsSignal.value = json;
    }).catch((e) => {
      console.error("Failed to fetch route info", e);
    });
  });
}
export {
  RouterConfigurationBuilder,
  createMenuItems,
  createRoute,
  useViewConfig,
  viewsSignal
};
//# sourceMappingURL=@vaadin_hilla-file-router_runtime__js.js.map
